<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-01-07 Mon 19:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RFC7234: Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
* {
  box-sizing: border-box;
}

html {
  padding: 0;
}

body {
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 15px;
  line-height: 1.6;
  padding: 0;
  margin: 0;
  color: #24292e;
  word-wrap: break-word;
}

b, strong {
  font-weight: 700;
}

p {
  margin: 0 0 16px;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a:active, a:hover {
  outline-width: 0;
}

.underline{
  text-decoration: underline;
}

del{
  text-decoration: line-through;
}

i {
  font-style: italic;
}

ul, ol {
  padding-left: 1em;
}

ruby {
  border-bottom: 1px solid #d9d9d9;
}

ruby > rt {
  color: #6a737d;
  text-align: center;
}

h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h1.title {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h1 {
  font-size: 2.5em;
}

.outline-2 h2 {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h3 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h4 {
  font-size: 1.25em
}

.outline-2 h5 {
  font-size: 1.1em
}

.outline-2 h6 {
  font-size: 1.1em
}

.outline-2 code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;

  color: #c7254e;
  background-color: #f9f2f4;
  white-space: normal;
  font-family: Consolas,Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,sans-serif;
}

.outline-2 table{
  width: 100%;
}

.org-ul,
.org-ol,
.org-dl,
.org-dl > dt,
.org-dl > dd,
.outline-2 p,
.outline-2 blockquote,
.outline-2 table,
.outline-2 pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.org-ul,
.org-ol,
.org-dl {
  padding-left: 2em;
}

.org-dl > dt {
  float: left;
  max-width: 40%;
  margin-bottom: 3px;
  margin-right: 2em;
  font-size: 110%;
  font-family: Courier New;
  font-weight: bolder;
  color: #1c3030;
  clear: left;
}

.org-dl > dd {
  text-align: justify;
  margin-bottom: 14pt;
  overflow: hidden;
  clear: right;
}

table tbody tr:nth-child(odd){
  background-color: #efefef;
}

.org-center {
  text-align: center;
}

.org-left {
  text-align: left;
}

.org-right {
  text-align: right;
}

pre,
blockquote {
  margin-bottom: 1em;
}

pre {
  margin: 0;
  padding: 1em;
  line-height: 1.45;
  font-size: 95%;
  font-family: Consolas,Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,sans-serif;
  border-radius: 3px;
  overflow: auto;
}

blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
  margin: 0;
}

.org-src-container, .example {
  width: 100%;
  overflow-x: auto;
  border-left: 0.25em solid #dfe2e5;
  border-radius: 0.5rem;
  background-color: #f6f8fa;
  margin-bottom: 16px;
}

.org-src-container pre {
  margin-bottom: 0;
}

.timestamp {
  font-family: Courier New;
  color: #888888;
}

#table-of-contents {
  font-size: 9pt;
  position: fixed;
  right: 0em;
  top: 0em;
  background: white;
  -webkit-box-shadow: 0 0 1em #777777;
  -moz-box-shadow: 0 0 1em #777777;
  -webkit-border-bottom-left-radius: 5px;
  -moz-border-radius-bottomleft: 5px;
  text-align: right;
  max-height: 80%;
  overflow: auto;
  z-index: 200;
}

#table-of-contents h2 {
  font-size: 14px;
  font-weight: normal;
  padding: 0 .5em;
  margin: 16px 0;
  text-align: left;
}

#table-of-contents ul {
  margin-left: 14pt;
  margin-bottom: 10pt;
  padding: 0
}

#table-of-contents li {
  padding: 0;
  margin: 1px;
  list-style: none;
}

#table-of-contents ul>:first-child {
  color: blue;
}

#table-of-contents #text-table-of-contents {
  display: none;
  text-align: left;
}

#table-of-contents:hover #text-table-of-contents {
  display: block;
  padding: 0.5em;
  margin-top: -1.5em;
}

#content {
  width: 980px;
  padding: 45px 15px 15px 15px;
  margin-right: auto;
  margin-left: auto;
}

@media screen and (max-width: 980px) {
  #content {
    width: 100%;
  }
  #table-of-contents {
    float: right;
    border: 1px solid #CCC;
    max-width: 75%;
    overflow: auto;
  }
  .org-dl > dt {
    float: none;
  }
}

.footdef {
}
.footdef sup {
  float: left;
  width: 3em;
}
.footdef > .footpara {
  margin-left: 3em;
  overflow-x: hidden;
}
.org-src-container {
  width: 100%;
  overflow-x: auto;
}
.github-repo {
  position: absolute;
  top: 0;
  left: -24px;
  margin-top: 32px;
  padding: 0 20px 0 40px;
  background-color: rgba(0,0,0,.2);
  height: 22px;
  line-height: 22px;
  padding-left: 42px;
  transform: rotate(-45deg);
  transform-origin: 40% 50%;
}
.github-repo:hover,
.github-repo:active {
  text-decoration: none;
}
.github-repo svg {
  position: absolute;
  width: 18px;
  height: 18px;
  left: 20px;
  top: 2px;
}
.github-repo span {
  color: #fff;
}
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">RFC7234: Hypertext Transfer Protocol (HTTP/1.1): Caching</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3ea0b18">摘要 / Abstract</a></li>
<li><a href="#orga688a65">备忘状态 / Status of This Memo</a></li>
<li><a href="#orga31f7ca">Copyright Notice</a></li>
<li><a href="#org3548e07">1. 引言 / Introduction</a>
<ul>
<li><a href="#org56f5b8d">1.1. 一致性和错误处理 / Conformance and Error Handling</a></li>
<li><a href="#org4c3fc32">1.2. 句法标记 / Syntax Notation</a>
<ul>
<li><a href="#orgd2ac10d">1.2.1. 秒差 / Delta Seconds</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org00d9855">2. 缓存操作的概况 / Overview of Cache Operation</a></li>
<li><a href="#orga05eb41">3. 将响应存储到缓存 / Storing Responses in Caches</a>
<ul>
<li><a href="#orgb02ed9d">3.1. 存储不完整的响应 / Storing Incomplete Responses</a></li>
<li><a href="#orga28b8b1">3.2. 存储回应给认证请求的响应 / Storing Responses to Authenticated Requests</a></li>
<li><a href="#org15206ea">3.3. 结合部分内容 / Combining Partial Content</a></li>
</ul>
</li>
<li><a href="#org937cf43">4. 从缓存中构造响应 / Constructing Responses from Caches</a>
<ul>
<li><a href="#org64a44b1">4.1. 使用 Vary 来计算次要缓存键 / Calculating Secondary Keys with Vary</a></li>
<li><a href="#org85ed084">4.2. 新鲜度 / Freshness</a>
<ul>
<li><a href="#org4e92c7f">4.2.1. 计算保鲜期 / Calculating Freshness Lifetime</a></li>
<li><a href="#org4c48fcc">4.2.2. 计算启发式新鲜度 / Calculating Heuristic Freshness</a></li>
<li><a href="#org3fee265">4.2.3. 计算年龄 / Calculating Age</a></li>
<li><a href="#orga71285a">4.2.4. 提供陈旧的响应 / Serving Stale Responses</a></li>
</ul>
</li>
<li><a href="#org7ccec2c">4.3. 验证 / Validation</a>
<ul>
<li><a href="#orgd178c24">4.3.1. 发送验证请求 / Sending a Validation Request</a></li>
<li><a href="#orgb0cd77f">4.3.2. 处理接收到的验证请求 / Handling a Received Validation Request</a></li>
<li><a href="#orgdb9d4f2">4.3.3. 处理验证响应 / Handling a Validation Response</a></li>
<li><a href="#org84ebeaf">4.3.4. 依据验证结果使已存储的响应唤发新鲜 / Freshening Stored Responses upon Validation</a></li>
<li><a href="#org62bfcfb">4.3.5. 经由 HEAD 请求使用响应唤发新鲜 / Freshening Responses via HEAD</a></li>
</ul>
</li>
<li><a href="#org104decc">4.4. 失效 / Invalidation</a></li>
</ul>
</li>
<li><a href="#org711b085">5. 头字段定义 / Header Field Definitions</a>
<ul>
<li><a href="#orgb943d27">5.1. Age</a></li>
<li><a href="#org96b62f3">5.2. Cache-Control</a>
<ul>
<li><a href="#org8707cd3">5.2.1. 请求消息中的缓存控制指令 / Request Cache-Control Directives</a>
<ul>
<li><a href="#orge31ad97">5.2.1.1. max-age</a></li>
<li><a href="#org2366c46">5.2.1.2. max-stale</a></li>
<li><a href="#org993888e">5.2.1.3. min-fresh</a></li>
<li><a href="#orga64526f">5.2.1.4. no-cache</a></li>
<li><a href="#orgeead007">5.2.1.5. no-store</a></li>
<li><a href="#orge5b428d">5.2.1.6. no-transform</a></li>
<li><a href="#orgdb45a14">5.2.1.7. only-if-cached</a></li>
</ul>
</li>
<li><a href="#org1336445">5.2.2. 响应消息中的缓存控制指令 / Response Cache-Control Directives</a>
<ul>
<li><a href="#org19ae67e">5.2.2.1. must-revalidate</a></li>
<li><a href="#org6dee7ff">5.2.2.2. no-cache</a></li>
<li><a href="#org15305e1">5.2.2.3. no-store</a></li>
<li><a href="#org453b87f">5.2.2.4. no-transform</a></li>
<li><a href="#org300811e">5.2.2.5. public</a></li>
<li><a href="#orgc298f3c">5.2.2.6. private</a></li>
<li><a href="#orge47f656">5.2.2.7. proxy-revalidate</a></li>
<li><a href="#orgc309465">5.2.2.8. max-age</a></li>
<li><a href="#orgf601e80">5.2.2.9. s-maxage</a></li>
</ul>
</li>
<li><a href="#orgd8f8d17">5.2.3. 缓存控制扩展 / Cache Control Extensions</a></li>
</ul>
</li>
<li><a href="#org304d2d1">5.3. Expires</a></li>
<li><a href="#orga139761">5.4. Pragma</a></li>
<li><a href="#org203fe8a">5.5. Warning</a>
<ul>
<li><a href="#orgb2503cc">5.5.1. Warning: 110 - "Response is Stale"</a></li>
<li><a href="#org26c6391">5.5.2. Warning: 111 - "Revalidation Failed"</a></li>
<li><a href="#org0637a23">5.5.3. Warning: 112 - "Disconnected Operation"</a></li>
<li><a href="#org61c78c6">5.5.4. Warning: 113 - "Heuristic Expiration"</a></li>
<li><a href="#org2498663">5.5.5. Warning: 199 - "Miscellaneous Warning"</a></li>
<li><a href="#org3ffd641">5.5.6. Warning: 214 - "Transformation Applied"</a></li>
<li><a href="#orgbf8e92c">5.5.7. Warning: 299 - "Miscellaneous Persistent Warning"</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgace9974">6. 历史列表 / History Lists</a></li>
<li><a href="#orgf20038c">7. IANA 注意事项 / IANA Considerations</a>
<ul>
<li><a href="#orgb841771">7.1. 缓存指令登记表 / Cache Directive Registry</a>
<ul>
<li><a href="#org785241a">7.1.1. 手续 / Procedure</a></li>
<li><a href="#org0611a08">7.1.2. 新的缓存控制指令的注意事项 / Considerations for New Cache Control Directives</a></li>
<li><a href="#orgc2896c5">7.1.3. 登记 / Registrations</a></li>
</ul>
</li>
<li><a href="#orgf57606b">7.2. 警告码登记表 / Warn Code Registry</a>
<ul>
<li><a href="#org37163f9">7.2.1. 手续 / Procedure</a></li>
<li><a href="#org614b44a">7.2.2. 登记 / Registrations</a></li>
</ul>
</li>
<li><a href="#org857923c">7.3. 头字段登记 / Header Field Registration</a></li>
</ul>
</li>
<li><a href="#orgf9e4b61">8. 安全注意事项 / Security Considerations</a></li>
<li><a href="#org9f32532">9. 鸣谢 / Acknowledgments</a></li>
<li><a href="#org2dbfe2e">10. 参考资料 / References</a>
<ul>
<li><a href="#org13349db">10.1. 规范性参考资料 / Normative References</a></li>
<li><a href="#org8fdaaa1">10.2. 信息性参考资料 / Informative References</a></li>
</ul>
</li>
<li><a href="#orga6bc8f3">附录 A：相对 RFC 2616 的变化 / Appendix A. Changes from RFC 2616</a></li>
<li><a href="#org981c4e6">附录 B：引进的 ABNF / Appendix B. Imported ABNF</a></li>
<li><a href="#org72bdc79">附录 C：ABNF 集合 / Appendix C. Collected ABNF</a></li>
<li><a href="#org37dfe9c">索引 / Index</a></li>
<li><a href="#org79cb7b1">Authors' Addresses</a></li>
</ul>
</div>
</div>
<a class="github-repo" href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <svg height="18" width="18" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
  <span>View Repo</span>
</a>

<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img alt="" src="https://img.shields.io/github/license/duoani/HTTP-RFCs.zh-cn.svg?style=social"/>
</a>
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img src="https://img.shields.io/github/stars/duoani/HTTP-RFCs.zh-cn.svg?style=social&label=Stars"/>
</a>

<div class="org-src-container">
<pre class="src src-text">                                                       PROPOSED STANDARD
                                                            Errata Exist
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7234                                         Adobe
Obsoletes: 2616                                       M. Nottingham, Ed.
Category: Standards Track                                         Akamai
ISSN: 2070-1721                                          J. Reschke, Ed.
                                                              greenbytes
                                                               June 2014
</pre>
</div>

<div id="outline-container-org3ea0b18" class="outline-2">
<h2 id="org3ea0b18">摘要 / Abstract</h2>
<div class="outline-text-2" id="text-org3ea0b18">
<blockquote>
<p>
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.
</p>
</blockquote>

<p>
超文本传输协议（HTTP）是一种<ruby>无状态<rt>stateless</rt></ruby>的应用层协议，适用于分布式、协作式的超文本信息系统。本文档定义了 HTTP 的缓存以及相关的头字段，这些头字段负责控制缓存的行为，或者表明是一种<ruby>可缓存<rt>cacheable</rt></ruby>的响应消息。
</p>
</div>
</div>

<div id="outline-container-orga688a65" class="outline-2">
<h2 id="orga688a65">备忘状态 / Status of This Memo</h2>
<div class="outline-text-2" id="text-orga688a65">
<blockquote>
<p>
This is an Internet Standards Track document.
</p>
</blockquote>

<p>
这是一个 Internet Standards Track 文档。
</p>

<blockquote>
<p>
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in <a href="https://tools.ietf.org/html/rfc5741">Section 2</a> of RFC 5741.
</p>
</blockquote>

<p>
本文档是<ruby>互联网工程任务组<rt>Internet Engineering Task Force</rt></ruby>（IETF）的产品。它代表了 IETF 社区的共识。它已经接受公众审核并且已经被<ruby>互联网工程指导组<rt>Internet Engineering Steering Group</rt></ruby>（IESG）批准发布。有关<ruby>互联网标准<rt>Internet Standards</rt></ruby>的更多信息，请参阅 RFC 5741 <a href="https://tools.ietf.org/html/rfc5741">章节 2</a>。
</p>

<blockquote>
<p>
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at <a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>.
</p>
</blockquote>

<p>
关于本文档的当前状态，任何勘误以及如何提供反馈的信息可以从 <a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a> 获得。
</p>
</div>
</div>

<div id="outline-container-orga31f7ca" class="outline-2">
<h2 id="orga31f7ca">Copyright Notice</h2>
<div class="outline-text-2" id="text-orga31f7ca">
<blockquote>
<p>
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>
</blockquote>

<blockquote>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
</p>
</blockquote>

<blockquote>
<p>
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org3548e07" class="outline-2">
<h2 id="org3548e07"><a id="ID-74ce75cf-fa87-485a-9d0c-406cca46608b"></a>1. 引言 / Introduction</h2>
<div class="outline-text-2" id="text-org3548e07">
<blockquote>
<p>
HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches. This document defines aspects of HTTP/1.1 related to caching and reusing response messages.
</p>
</blockquote>

<p>
HTTP 通常用于分布式信息系统，通过使用响应缓存能够提升这些系统的性能。本文档定义了 HTTP/1.1 缓存响应消息以及复用响应消息相关的内容。
</p>

<blockquote>
<p>
An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server <b>MAY</b> employ a cache, though a cache cannot be used by a server that is acting as a tunnel.
</p>
</blockquote>

<p>
HTTP <ruby>缓存<rt>cache</rt></ruby>，是一种响应消息的本地存储，以及控制其内的消息的存储、获取和删除的子系统。缓存存储了<ruby>可缓存的<rt>cacheable</rt></ruby>响应是为了减少将来的响应时间和网络带宽消耗。任何客户端或者服务器 <b>可以</b> 使用缓存，但是，当服务器作为<ruby>隧道<rt>tunnel</rt></ruby>而使用时，不能使用缓存。 
</p>

<blockquote>
<p>
A shared cache is a cache that stores responses to be reused by more than one user; shared caches are usually (but not always) deployed as a part of an intermediary. A private cache, in contrast, is dedicated to a single user; often, they are deployed as a component of a user agent.
</p>
</blockquote>

<p>
<ruby>共享缓存<rt>shared cache</rt></ruby>是一种缓存，它存储响应用于给一个以上的用户来复用，通常（但并不总是）部署作为一个中间人的一部分。与之相对的是<ruby>私有缓存<rt>private cache</rt></ruby>，这种缓存专门用于某一个用户，通常部署为一个用户代理的一个组件。
</p>

<blockquote>
<p>
The goal of caching in HTTP/1.1 is to significantly improve performance by reusing a prior response message to satisfy a current request. A stored response is considered "fresh", as defined in <a href="#org85ed084">Section 4.2</a>, if the response can be reused without "validation" (checking with the origin server to see if the cached response remains valid for this request). A fresh response can therefore reduce both latency and network overhead each time it is reused. When a cached response is not fresh, it might still be reusable if it can be freshened by validation (<a href="#org7ccec2c">Section 4.3</a>) or if the origin is unavailable (<a href="#orga71285a">Section 4.2.4</a>).
</p>
</blockquote>

<p>
在 HTTP/1.1 中，缓存通过复用一个之前的响应消息来满足当前的请求，其目的是显著提升性能。一个已存储的响应，如果它在不需要“验证”的情况就可以用来复用，那么，它被认为是“<ruby>新鲜的<rt>fresh</rt></ruby>”（<a href="#org85ed084">章节 4.2</a>）。所谓“<ruby>验证<rt>validation</rt></ruby>”，是指和源服务器一起检查，看看这个已存储的响应是否仍然有效于这个请求。因此，每一次复用一个新鲜的响应的时候，都可以减少双方的延迟以及网络开销。当一个已存储的响应不再新鲜，它可能仍旧可以获得复用，如果它可以通过验证（<a href="#org7ccec2c">章节 4.3</a>）而<ruby>唤发新鲜<rt>freshened</rt></ruby>，或者原始的已不可用（<a href="#orga71285a">章节 4.2.4</a>）。
</p>

<blockquote>
<p>
译注：本文所述的“验证”指的是“新鲜度验证”，也可以叫作“过期时间验证”。
</p>
</blockquote>
</div>

<div id="outline-container-org56f5b8d" class="outline-3">
<h3 id="org56f5b8d">1.1. 一致性和错误处理 / Conformance and Error Handling</h3>
<div class="outline-text-3" id="text-org56f5b8d">
<blockquote>
<p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [<a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>].
</p>
</blockquote>

<p>
本文档中的关键词 <b><ruby>必须<rt>MUST</rt></ruby></b>、<b><ruby>禁止<rt>MUST NOT</rt></ruby></b>、<b><ruby>要求<rt>REQUIRED</rt></ruby></b>、<b><ruby>必须<rt>SHALL</rt></ruby></b>、<b><ruby>禁止<rt>SHALL NOT</rt></ruby></b>、<b><ruby>应该<rt>SHOULD</rt></ruby></b>、<b><ruby>不应当<rt>SHOULD NOT</rt></ruby></b>、<b><ruby>推荐<rt>RECOMMENDED</rt></ruby></b>、<b><ruby>可以<rt>MAY</rt></ruby></b> 和 <b><ruby>可选<rt>OPTIONAL</rt></ruby></b> 的意义与【<a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>】一致。
</p>

<blockquote>
<p>
Conformance criteria and considerations regarding error handling are defined in <a href="RFC7230.html#ID-A0441F72-9799-4667-9477-1E05885946A1">Section 2.5</a> of [RFC7230].
</p>
</blockquote>

<p>
关于错误处理的一致性标准以及注意事项已在<a href="RFC7230.html#ID-A0441F72-9799-4667-9477-1E05885946A1">【RFC7230】章节 2.5</a> 中定义了。
</p>
</div>
</div>

<div id="outline-container-org4c3fc32" class="outline-3">
<h3 id="org4c3fc32">1.2. 句法标记 / Syntax Notation</h3>
<div class="outline-text-3" id="text-org4c3fc32">
<blockquote>
<p>
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7 of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). <a href="#org981c4e6">Appendix B</a> describes rules imported from other documents. <a href="#org72bdc79">Appendix C</a> shows the collected grammar with all list operators expanded to standard ABNF notation.
</p>
</blockquote>

<p>
本规范使用了<ruby>扩展巴科斯范式<rt>Augmented Backus-Naur Form</rt></ruby>（ABNF）标记法【<a href="https://tools.ietf.org/html/rfc5234">RFC5234</a>】，另外，出于定义的紧凑性的考虑，本规范对 ABNF 规则进行了扩展（见<a href="RFC7230.html#ID-b9db011d-fe47-4781-929a-4b1b0aa55aec">章节 7</a>），允许使用一个 <code>#</code> 操作符（类似于 <code>*</code> 操作符，指代“重复”）来定义一种以逗号分隔的列表。<a href="#org981c4e6">附录 B</a> 描述了从其他文档中引进的规则。<a href="#org72bdc79">附录 C</a> 展示了所有已收集的包含列表扩展规则以及标准 ABNF 标记的语法。
</p>
</div>

<div id="outline-container-orgd2ac10d" class="outline-4">
<h4 id="orgd2ac10d"><a id="ID-26b0d760-fc0b-4d1e-b9be-e38abdb549e6"></a>1.2.1. 秒差 / Delta Seconds</h4>
<div class="outline-text-4" id="text-orgd2ac10d">
<blockquote>
<p>
The <code>delta-seconds</code> rule specifies a non-negative integer, representing time in seconds.
</p>
</blockquote>

<p>
<code>delta-seconds</code> 规则指定了一个非负整数来以秒数表示时间。
</p>

<div class="org-src-container">
<pre class="src src-text">delta-seconds  = 1*DIGIT
</pre>
</div>

<blockquote>
<p>
A recipient parsing a <code>delta-seconds</code> value and converting it to binary form ought to use an arithmetic type of at least 31 bits of non-negative integer range. If a cache receives a <code>delta-seconds</code> value greater than the greatest integer it can represent, or if any of its subsequent calculations overflows, the cache <b>MUST</b> consider the value to be either 2147483648 (2<sup>31</sup>) or the greatest positive integer it can conveniently represent.
</p>
</blockquote>

<p>
接收端在解析一个 <code>delta-seconds</code> 值并将它转换为<ruby>二进制形式<rt>binary form</rt></ruby>的时候，应该使用一种至少 31 位的非负整数范围的算术类型。如果一个缓存接收到一个 <code>delta-seconds</code> 的值大于缓存能够表示的最大整数，或者如果它接下来的任何运算出现数据溢出的情况，那么，缓存 <b>必须</b> 将该值视作 2147483648 (2<sup>31</sup>) 或者视作它能够方便表示的最大正整数。
</p>

<blockquote>
<p>
<b>Note:</b> The value 2147483648 is here for historical reasons, effectively represents infinity (over 68 years), and does not need to be stored in binary form; an implementation could produce it as a canned string if any overflow occurs, even if the calculations are performed with an arithmetic type incapable of directly representing that number. What matters here is that an overflow be detected and not treated as a negative value in later calculations.
</p>
</blockquote>

<p>
<b>注意：</b> 这里的 2147483648 数值是出于历史的原因，有效地表示无限（超过 68 年），并且并不需要存储为二进制形式，也就是说，如果发生了任何溢出，HTTP 实现可以使用预制的字符串来产生这个值，即使执行运算的算术类型无法直接表示这个数值。重要的是检测到了一个数据溢出，并且在后续的运算当中没有将其作为一个负值来对待。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org00d9855" class="outline-2">
<h2 id="org00d9855"><a id="ID-a09dfe13-47b3-4258-a219-ba801a1f0467"></a>2. 缓存操作的概况 / Overview of Cache Operation</h2>
<div class="outline-text-2" id="text-org00d9855">
<blockquote>
<p>
Proper cache operation preserves the semantics of HTTP transfers ([RFC7231]) while eliminating the transfer of information already held in the cache. Although caching is an entirely <b>OPTIONAL</b> feature of HTTP, it can be assumed that reusing a cached response is desirable and that such reuse is the default behavior when no requirement or local configuration prevents it. Therefore, HTTP cache requirements are focused on preventing a cache from either storing a non-reusable response or reusing a stored response inappropriately, rather than mandating that caches always store and reuse particular responses.
</p>
</blockquote>

<p>
恰当的缓存操作可以在消除已存储在缓存中的消息的网络传输的同时还能保持 HTTP 传输的语义。虽然缓存是一种完全 <b>可选的</b> HTTP 功能，但我们可以认为复用一个已缓存的响应是大家想要的，并且这样的复用行为是默认的（如果没有要求或本地配置阻止去缓存的话）。所以，HTTP 缓存的要求主要集中在阻止一个缓存去存储一个不可复用的响应，或者不恰当地复用一个已存储的响应这些方面；而不是在是否准许缓存总是存储并复用具体的响应。
</p>

<blockquote>
<p>
Each cache entry consists of a cache key and one or more HTTP responses corresponding to prior requests that used the same key. The most common form of cache entry is a successful result of a retrieval request: i.e., a <code>200 (OK)</code> response to a GET request, which contains a representation of the resource identified by the request target (<a href="RFC7231.html#ID-698bab73-07b1-4349-8a03-5a4a89d966d8">Section 4.3.1</a> of [RFC7231]). However, it is also possible to cache permanent redirects, negative results (e.g., <code>404 (Not Found)</code>), incomplete results (e.g., <code>206 (Partial Content)</code>), and responses to methods other than GET if the method's definition allows such caching and defines something suitable for use as a cache key.
</p>
</blockquote>

<p>
每个<ruby>缓存条目<rt>cache entry</rt></ruby>是由一个缓存 key（映射键）以及一个或多个 HTTP 响应组成的，这些响应对应于之前有使用过相同的 key 的请求。缓存条目最常见的形式是一个检索请求（<a href="RFC7231.html#ID-698bab73-07b1-4349-8a03-5a4a89d966d8">【RFC7231】章节 4.3.1</a>）的成功返回结果，比如，一个回应给 GET 请求的 <code>200 (OK)</code> 响应。这种成功返回结果包含了一个由请求目标所标识的资源表示形式。但是，它同样可能去缓存一个永久重定向（<code>301</code>，见<a href="RFC7231.html#ID-e883e3aa-aac3-46ca-83cc-2a085889f9d2">【RFC7231】章节 6.4.2</a>）、否定的结果（比如，<code>404 (Not Found)</code>）、不完整的结果（比如，<code>206 (Partial Content)</code>）、以及回应给非 GET 方法的响应（如果方法的定义允许这种缓存行为并定义了某种适合用作一个缓存 key 的东西）。
</p>

<blockquote>
<p>
The primary cache key consists of the request method and target URI. However, since HTTP caches in common use today are typically limited to caching responses to GET, many caches simply decline other methods and use only the URI as the primary cache key.
</p>
</blockquote>

<p>
主要的缓存 key 是由<ruby>请求方法<rt>request method</rt></ruby>以及目标 URI 组成的。但是，因为如今普遍使用的 HTTP 缓存通常都被限制为只对 GET 的响应进行缓存，因此，许多缓存简单地拒绝其他方法，并只使用 URI 作为主要的缓存 key。
</p>

<blockquote>
<p>
If a request target is subject to content negotiation, its cache entry might consist of multiple stored responses, each differentiated by a secondary key for the values of the original request's selecting header fields (<a href="#org64a44b1">Section 4.1</a>).
</p>
</blockquote>

<p>
如果请求目标受到<ruby>内容协商<rt>content negotiation</rt></ruby>的影响，那么它的缓存条目可能是由多个已存储的响应来组成的，每一个响应由一个次要的 key 来进行区分，这个次要的 key 的值是原始请求选定的头字段（<a href="#org64a44b1">章节 4.1</a>）。
</p>
</div>
</div>

<div id="outline-container-orga05eb41" class="outline-2">
<h2 id="orga05eb41"><a id="ID-e41d8ccc-5b69-40e3-a8ab-ca27327f15fa"></a>3. 将响应存储到缓存 / Storing Responses in Caches</h2>
<div class="outline-text-2" id="text-orga05eb41">
<blockquote>
<p>
A cache <b>MUST NOT</b> store a response to any request, unless:
</p>

<ul class="org-ul">
<li>The request method is understood by the cache and defined as being cacheable, and</li>
<li>the response status code is understood by the cache, and</li>
<li>the "<code>no-store</code>" cache directive (see <a href="#org96b62f3">Section 5.2</a>) does not appear in request or response header fields, and</li>
<li>the "<code>private</code>" response directive (see <a href="#orgc298f3c">Section 5.2.2.6</a>) does not appear in the response, if the cache is shared, and</li>
<li>the <code>Authorization</code> header field (see <a href="RFC7235.html#ID-14671c8e-e5a4-4f9d-ad1d-6460328ed7f5">Section 4.2</a> of [RFC7235]) does not appear in the request, if the cache is shared, unless the response explicitly allows it (see <a href="#orga28b8b1">Section 3.2</a>), and</li>
<li>the response either:
<ul class="org-ul">
<li>contains an <code>Expires</code> header field (see <a href="#org304d2d1">Section 5.3</a>), or</li>
<li>contains a <code>max-age</code> response directive (see <a href="#orgc309465">Section 5.2.2.8</a>), or</li>
<li>contains a <code>s-maxage</code> response directive (see <a href="#orgf601e80">Section 5.2.2.9</a>) and the cache is shared, or</li>
<li>contains a Cache Control Extension (see <a href="#orgd8f8d17">Section 5.2.3</a>) that allows it to be cached, or</li>
<li>has a status code that is defined as cacheable by default (see <a href="#org4c48fcc">Section 4.2.2</a>), or</li>
<li>contains a <code>public</code> response directive (see <a href="#org300811e">Section 5.2.2.5</a>).</li>
</ul></li>
</ul>
</blockquote>

<p>
除了可以存储回应给以下请求的响应以外，缓存 <b>禁止</b> 存储任何响应：
</p>

<ul class="org-ul">
<li><ruby>请求方法<rt>request method</rt></ruby>为缓存所理解，并被定义为<ruby>可缓存的<rt>cacheable</rt></ruby>，并且：</li>
<li><ruby>响应状态码<rt>response status code</rt></ruby>为缓存所理解，并且：</li>
<li><code>no-store</code> <ruby>缓存指令<rt>cache directive</rt></ruby>（<a href="#org96b62f3">章节 5.2</a>）没有出现在请求或者响应的头字段里，并且：</li>
<li><code>private</code> 响应指令（<a href="#orgc298f3c">章节 5.2.2.6</a>）没有出现在响应里，如果这是个共享缓存的话，并且：</li>
<li><code>Authorization</code> 头字段（<a href="RFC7235.html#ID-14671c8e-e5a4-4f9d-ad1d-6460328ed7f5">【RFC7235】章节 4.2</a>）没有出现在请求里，如果这是个共享缓存的话，除非响应明确允许它（<a href="#orga28b8b1">章节 3.2</a>），并且：</li>
<li>响应符合以下情况之一：
<ul class="org-ul">
<li>包含一个 <code>Expires</code> 头字段（<a href="#org304d2d1">章节 5.3</a>），或者：</li>
<li>包含一个 <code>max-age</code> 响应指令（<a href="#orgc309465">章节 5.2.2.8</a>），或者：</li>
<li>包含一个 <code>s-maxage</code> 响应指令（<a href="#orgf601e80">章节 5.2.2.9</a>）并且缓存是共享的，或者：</li>
<li>包含一个<ruby>缓存控制扩展<rt>Cache Control Extension</rt></ruby>（<a href="#orgd8f8d17">章节 5.2.3</a>），该缓存控制扩展允许缓存这个响应，或者：</li>
<li>带有一个状态码，该状态码默认是可缓存的（<a href="#org4c48fcc">章节 4.2.2</a>），或者：</li>
<li>包含一个 <code>public</code> 响应指令（<a href="#org300811e">章节 5.2.2.5</a>）。</li>
</ul></li>
</ul>

<blockquote>
<p>
Note that any of the requirements listed above can be overridden by a <code>cache-control</code> extension; see <a href="#orgd8f8d17">Section 5.2.3</a>.
</p>
</blockquote>

<p>
需要注意的是，上述所列出的任何要求都可以被 <code>cache-control</code> 扩展所覆盖，见<a href="#orgd8f8d17">章节 5.2.3</a>。
</p>

<blockquote>
<p>
In this context, a cache has "understood" a request method or a response status code if it recognizes it and implements all specified caching-related behavior.
</p>
</blockquote>

<p>
在这个场景中，一个缓存已经“理解”一个请求方法或者一个响应状态码，指的是缓存可以识别到它并实现了所有缓存相关的行为。
</p>

<blockquote>
<p>
Note that, in normal operation, some caches will not store a response that has neither a cache validator nor an explicit expiration time, as such responses are not usually useful to store. However, caches are not prohibited from storing such responses.
</p>
</blockquote>

<p>
需要注意的是，在常规操作中，如果一个响应既没有<ruby>缓存验证器<rt>cache validator</rt></ruby>也没有一个<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>，某些缓存将不会存储这种响应，因为存储这种响应通常是没有用处的。但是，缓存不会被禁止存储这种响应。
</p>
</div>

<div id="outline-container-orgb02ed9d" class="outline-3">
<h3 id="orgb02ed9d">3.1. 存储不完整的响应 / Storing Incomplete Responses</h3>
<div class="outline-text-3" id="text-orgb02ed9d">
<blockquote>
<p>
A response message is considered complete when all of the octets indicated by the message framing ([<a href="RFC7230.html">RFC7230</a>]) are received prior to the connection being closed. If the request method is GET, the response status code is <code>200 (OK)</code>, and the entire response header section has been received, a cache <b>MAY</b> store an incomplete response message body if the cache entry is recorded as incomplete. Likewise, a <code>206 (Partial Content)</code> response <b>MAY</b> be stored as if it were an incomplete <code>200 (OK)</code> cache entry. However, a cache <b>MUST NOT</b> store incomplete or partial-content responses if it does not support the <code>Range</code> and <code>Content-Range</code> header fields or if it does not understand the range units used in those fields.
</p>
</blockquote>

<p>
在连接被关闭之前，所有由<ruby>消息分帧<rt>message framing</rt></ruby>（【<a href="RFC7230.html">RFC7230</a>】）所表明的<ruby>字节<rt>octets</rt></ruby>都已被接收到，那么，这个响应消息被认为是<ruby>完整的<rt>complete</rt></ruby>。如果请求方法是 GET，响应状态码是 <code>200 (OK)</code>，并且整个<ruby>响应头部<rt>response header section</rt></ruby>都已经被接收到，那么，缓存 <b>可以</b> 存储一个<ruby>不完整<rt>incomplete</rt></ruby>的<ruby>响应消息体<rt>response message body</rt></ruby>，如果对应的缓存条目是被记录为不完整的话。同样，一个 <code>206 (Partial Content)</code> 响应 <b>可以</b> 被缓存作为一个不完整的 <code>200 (OK)</code> 的缓存条目。但是，如果缓存并不支持 <code>Range</code> 和 <code>Content-Range</code> 头字段，或者它并不理解用在这些头字段中的<ruby>范围单位<rt>range unit</rt></ruby>，那么，缓存 <b>禁止</b> 存储<ruby>不完整<rt>incomplete</rt></ruby>的或者<ruby>部分内容<rt>partial-content</rt></ruby>的响应。
</p>

<blockquote>
<p>
A cache <b>MAY</b> complete a stored incomplete response by making a subsequent range request ([<a href="RFC7233.html">RFC7233</a>]) and combining the successful response with the stored entry, as defined in <a href="#org15206ea">Section 3.3</a>. A cache <b>MUST NOT</b> use an incomplete response to answer requests unless the response has been made complete or the request is partial and specifies a range that is wholly within the incomplete response. A cache <b>MUST NOT</b> send a partial response to a client without explicitly marking it as such using the <code>206 (Partial Content)</code> status code.
</p>
</blockquote>

<p>
缓存 <b>可以</b> 通过发起后续<ruby>范围请求<rt>range request</rt></ruby>（【<a href="RFC7233.html">RFC7233</a>】）并将<ruby>成功响应<rt>successful response</rt></ruby>和已存储的条目进行结合，来使一个已存储的不完整响应补充完整，正如<a href="#org15206ea">章节 3.3</a> 所定义的。缓存 <b>禁止</b> 使用一个不完整响应来回应请求，除非这个响应已被补充完整，或者这个请求是一个<ruby>部分请求<rt>partial request</rt></ruby>并指定了一个范围且这个范围统统在该不完整响应以内。对于没有明确地使用 <code>206 (Partial Content)</code> 状态码进行标记的<ruby>部分响应<rt>partial response</rt></ruby>，缓存 <b>禁止</b> 发送这种<ruby>部分响应<rt>partial response</rt></ruby>到一个客户端。
</p>
</div>
</div>

<div id="outline-container-orga28b8b1" class="outline-3">
<h3 id="orga28b8b1"><a id="ID-d6b247ad-fe70-4ddf-9bd3-ebc35ea6ac99"></a>3.2. 存储回应给认证请求的响应 / Storing Responses to Authenticated Requests</h3>
<div class="outline-text-3" id="text-orga28b8b1">
<blockquote>
<p>
A shared cache <b>MUST NOT</b> use a cached response to a request with an <code>Authorization</code> header field (<a href="RFC7235.html#ID-14671c8e-e5a4-4f9d-ad1d-6460328ed7f5">Section 4.2</a> of [RFC7235]) to satisfy any subsequent request unless a cache directive that allows such responses to be stored is present in the response.
</p>
</blockquote>

<p>
如果共享缓存所缓存的一个响应的 key 对应于一个带有 <code>Authorization</code> 头字段（<a href="RFC7235.html#ID-14671c8e-e5a4-4f9d-ad1d-6460328ed7f5">【RFC7235】章节 4.2</a>）的请求，那么，共享缓存 <b>禁止</b> 使用这个已缓存的响应来满足任何后续的请求，除非这个响应里出现了一个缓存指令，该指令允许这个响应被存储。
</p>

<blockquote>
<p>
In this specification, the following <code>Cache-Control</code> response directives (<a href="#org1336445">Section 5.2.2</a>) have such an effect: <code>must-revalidate</code>, <code>public</code>, and <code>s-maxage</code>.
</p>
</blockquote>

<p>
在本规范中，以下 <code>Cache-Control</code> 响应指令（<a href="#org1336445">章节 5.2.2</a>）有上述这种影响：<code>must-revalidate</code>、<code>public</code>、以及 <code>s-maxage</code>。
</p>

<blockquote>
<p>
Note that cached responses that contain the "<code>must-revalidate</code>" and/or "<code>s-maxage</code>" response directives are not allowed to be served stale (<a href="#orga71285a">Section 4.2.4</a>) by shared caches. In particular, a response with either "<code>max-age=0, must-revalidate</code>" or "<code>s-maxage=0</code>" cannot be used to satisfy a subsequent request without revalidating it on the origin server.
</p>
</blockquote>

<p>
需要注意的是，如果已缓存的响应包含有 <code>must-revalidate</code> 并且/或者 <code>s-maxage</code> 响应指令，那么，这些缓存响应是不允许被共享缓存用来<ruby>提供陈旧响应<rt>serve stale</rt></ruby>的（<a href="#orga71285a">章节 4.2.4</a>）。实践中，一个响应，如果它带有 <code>max-age=0, must-revalidate</code>，或者带有 <code>s-maxage=0</code>，那么，在没有经过源服务器<ruby>重新验证<rt>revalidating</rt></ruby>的情况下，它是不能用来满足后续请求的。
</p>

<blockquote>
<p>
译注：所谓 "serve stale"，指的是：提供陈旧的缓存响应来作为响应，即使这个已缓存的响应已经过期。对于一个请求，当对应的已缓存的响应已经过期（stale），并且源服务器无响应或者响应一个错误，这时候，缓存服务器返回这个 stale 的响应来作为回应，而不是返回错误。在大多数情况下，与其响应超时或返回其他错误，倒不如返回给用户一个能用的但过期的响应。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org15206ea" class="outline-3">
<h3 id="org15206ea"><a id="ID-f00b0325-c5eb-4b84-8b33-3cc68031d045"></a>3.3. 结合部分内容 / Combining Partial Content</h3>
<div class="outline-text-3" id="text-org15206ea">
<blockquote>
<p>
A response might transfer only a partial representation if the connection closed prematurely or if the request used one or more <code>Range</code> specifiers ([<a href="RFC7233.html">RFC7233</a>]). After several such transfers, a cache might have received several ranges of the same representation. A cache <b>MAY</b> combine these ranges into a single stored response, and reuse that response to satisfy later requests, if they all share the same strong validator and the cache complies with the client requirements in <a href="RFC7233.html#ID-a995c03a-651b-4bd1-9429-30f97b353acd">Section 4.3</a> of [RFC7233].
</p>
</blockquote>

<p>
如果连接被过早地关闭了，或者请求使用了一个或多个 Range 规格，那么，一个响应可能只传输一个表示形式的一部分（【<a href="RFC7233.html">RFC7233</a>】）。历经多次这样的传输以后，缓存可能已接收到同一个表示形式的许多范围。缓存 <b>可以</b> 将这些范围合并为单个已存储的响应，并复用这个响应来满足接下来的请求，如果这些请求都共享同一个强验证器，并且缓存遵从<a href="RFC7233.html#ID-a995c03a-651b-4bd1-9429-30f97b353acd">【RFC7233】章节 4.3</a> 对于客户端方面的要求的话。
</p>

<blockquote>
<p>
When combining the new response with one or more stored responses, a cache <b>MUST</b>:
</p>

<ul class="org-ul">
<li>delete any <code>Warning</code> header fields in the stored response with warn-code <code>1xx</code> (see Section 5.5);</li>
<li>retain any <code>Warning</code> header fields in the stored response with warn-code <code>2xx</code>; and,</li>
<li>use other header fields provided in the new response, aside from <code>Content-Range</code>, to replace all instances of the corresponding header fields in the stored response.</li>
</ul>
</blockquote>

<p>
当将一个或多个已存储的响应结合成一个新的响应的时候，缓存 <b>必须</b> 对这个新响应做如下处理：
</p>

<ul class="org-ul">
<li>删除在已存储的响应里警告码为 <code>1xx</code> 的任何 <code>Warning</code> 头字段（见章节 5.5）；</li>
<li>保留在已存储的响应里警告码为 <code>2xx</code> 的任何 <code>Warning</code> 头字段；并且</li>
<li>使用新响应所提供的其他头字段，除以 <code>Content-Range</code> 以外，来替换所有在已存储的响应中对应的头字段。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org937cf43" class="outline-2">
<h2 id="org937cf43"><a id="ID-cd0b2da5-6fd4-4ce2-9f59-27ba0d529181"></a>4. 从缓存中构造响应 / Constructing Responses from Caches</h2>
<div class="outline-text-2" id="text-org937cf43">
<blockquote>
<p>
When presented with a request, a cache <b>MUST NOT</b> reuse a stored response, unless:
</p>

<ul class="org-ul">
<li>The presented effective request URI (<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">Section 5.5</a> of [RFC7230]) and that of the stored response match, and</li>
<li>the request method associated with the stored response allows it to be used for the presented request, and</li>
<li>selecting header fields nominated by the stored response (if any) match those presented (see <a href="#org64a44b1">Section 4.1</a>), and</li>
<li>the presented request does not contain the <code>no-cache</code> pragma (<a href="#orga139761">Section 5.4</a>), nor the <code>no-cache</code> cache directive (<a href="#org8707cd3">Section 5.2.1</a>), unless the stored response is successfully validated (<a href="#org7ccec2c">Section 4.3</a>), and</li>
<li>the stored response does not contain the <code>no-cache</code> cache directive (<a href="#org6dee7ff">Section 5.2.2.2</a>), unless it is successfully validated (<a href="#org7ccec2c">Section 4.3</a>), and</li>
<li>the stored response is either:
<ul class="org-ul">
<li>fresh (see <a href="#org85ed084">Section 4.2</a>), or</li>
<li>allowed to be served stale (see <a href="#orga71285a">Section 4.2.4</a>), or</li>
<li>successfully validated (see <a href="#org7ccec2c">Section 4.3</a>).</li>
</ul></li>
</ul>
</blockquote>

<p>
当面临一个请求的时候，缓存 <b>禁止</b> 复用一个已存储的响应，除非：
</p>

<ul class="org-ul">
<li>所面临的<ruby>实际请求 URI<rt>effective request URI</rt></ruby>（<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">【RFC7230】章节 5.5</a>）与已存储的响应所对应的实际请求 URI 相匹配，并且：</li>
<li>已存储的响应所关联的请求方法允许这个响应用于所面临的请求，并且：</li>
<li>由已存储的响应所<ruby>指定<rt>nominated</rt></ruby>的选择头字段与所面临的请求的头字段相匹配（<a href="#org64a44b1">章节 4.1</a>），并且：</li>
<li>所面临的请求并没有包含一个值为 <code>no-cache</code> 的 <code>Pragma</code> 头字段（<a href="#orga139761">章节 5.4</a>），也没有包含一个值为 <code>no-cache</code> 的缓存指令（<a href="#org8707cd3">章节 5.2.1</a>），除非已存储的响应是<ruby>被成功验证的<rt>successfully validated</rt></ruby>（<a href="#org7ccec2c">章节 4.3</a>），并且：</li>
<li>已存储的响应并没有包含一个 <code>no-cache</code> 缓存指令（<a href="#org6dee7ff">章节 5.2.2.2</a>），除非它是被成功验证的（<a href="#org7ccec2c">章节 4.3</a>），并且：</li>
<li>已存储的响应是以下情况之一：
<ul class="org-ul">
<li><ruby>新鲜的<rt>fresh</rt></ruby>（<a href="#org85ed084">章节 4.2</a>），或者：</li>
<li>允许<ruby>作为陈旧响应来提供<rt>served stale</rt></ruby>（<a href="#orga71285a">章节 4.2.4</a>），或者：</li>
<li>被成功验证的（<a href="#org7ccec2c">章节 4.3</a>）。</li>
</ul></li>
</ul>

<blockquote>
<p>
译注：所谓“<ruby>成功验证<rt>successfully validated</rt></ruby>”，指的是源服务器确认了这个被缓存所存储的响应的仍然新鲜，可以继续用于响应请求。
</p>
</blockquote>

<blockquote>
<p>
Note that any of the requirements listed above can be overridden by a cache-control extension; see <a href="#orgd8f8d17">Section 5.2.3</a>.
</p>
</blockquote>

<p>
需要注意的是，上述所列出的任何要求都可以被 <code>cache-control</code> 扩展所覆盖，见<a href="#orgd8f8d17">章节 5.2.3</a>。
</p>

<blockquote>
<p>
When a stored response is used to satisfy a request without validation, a cache <b>MUST</b> generate an <code>Age</code> header field (<a href="#orgb943d27">Section 5.1</a>), replacing any present in the response with a value equal to the stored response's <code>current_age</code>; see <a href="#org3fee265">Section 4.2.3</a>.
</p>
</blockquote>

<p>
在没有<ruby>验证<rt>validation</rt></ruby>的情况下将一个已存储的响应用于满足一个请求时，缓存 <b>必须</b> 生成一个 <code>Age</code> 头字段（<a href="#orgb943d27">章节 5.1</a>），其值等于已存储的响应的 <code>current_age</code>，来替换掉出现在该响应里的任何 <code>Age</code> 字段，见<a href="#org3fee265">章节 4.2.3</a>。
</p>

<blockquote>
<p>
A cache <b>MUST</b> write through requests with methods that are unsafe (<a href="RFC7231.html#ID-2f967e3d-8694-430b-ad06-e748fd39b281">Section 4.2.1</a> of [RFC7231]) to the origin server; i.e., a cache is not allowed to generate a reply to such a request before having forwarded the request and having received a corresponding response.
</p>
</blockquote>

<p>
如果请求带有对源服务器来说是<ruby>不安全的方法<rt>unsafe methods</rt></ruby>（<a href="RFC7231.html#ID-2f967e3d-8694-430b-ad06-e748fd39b281">【RFC7231】章节 4.2.1</a>），那么，缓存 <b>必须</b> 使用<ruby>直写模式<rt>write through</rt></ruby>来写入请求，也就是说，在缓存已经转发这种请求并且已经接收到一个对应的响应之前，不允许缓存生成一个回复到这种请求上。
</p>

<blockquote>
<p>
译注：缓存有两种基础写入策略：<ruby>直写模式<rt>Write-through</rt></ruby>和<ruby>回写模式<rt>Write-back</rt></ruby>，详情见 <a href="https://en.wikipedia.org/wiki/Cache_(computing)#WRITE-THROUGH">Wikipedia: Cache - Writing Policies</a>。
</p>
</blockquote>

<blockquote>
<p>
Also, note that unsafe requests might invalidate already-stored responses; see <a href="#org104decc">Section 4.4</a>.
</p>
</blockquote>

<p>
另外，还需要注意的是，不安全的请求可能会使已经存储的响应置为无效，见<a href="#org104decc">章节 4.4</a>。
</p>

<blockquote>
<p>
When more than one suitable response is stored, a cache <b>MUST</b> use the most recent response (as determined by the <code>Date</code> header field). It can also forward the request with "<code>Cache-Control: max-age=0</code>" or "<code>Cache-Control: no-cache</code>" to disambiguate which response to use.
</p>
</blockquote>

<p>
当存储了超过一个以上的合适响应，缓存 <b>必须</b> 使用时间最近的响应（由 <code>Date</code> 头字段的时间来决定）。它还可以在转发这个请求的时候带上 <code>Cache-Control: max-age=0</code> 或者 <code>Cache-Control: no-cache</code> 以区分使用的是哪一个响应。
</p>

<blockquote>
<p>
A cache that does not have a clock available <b>MUST NOT</b> use stored responses without revalidating them upon every use.
</p>
</blockquote>

<p>
如果缓存不具有一个可用的时钟功能，那么，在每次使用已存储的响应的时候，<b>禁止</b> 在没有重新验证的情况下使用它们。
</p>
</div>

<div id="outline-container-org64a44b1" class="outline-3">
<h3 id="org64a44b1"><a id="ID-352eb301-a424-48e9-9027-3c6633da4b77"></a>4.1. 使用 Vary 来计算次要缓存键 / Calculating Secondary Keys with Vary</h3>
<div class="outline-text-3" id="text-org64a44b1">
<blockquote>
<p>
When a cache receives a request that can be satisfied by a stored response that has a <code>Vary</code> header field (<a href="RFC7231.html#ID-ca7f8781-b183-4563-a90a-b9b7ad4f1032">Section 7.1.4</a> of [RFC7231]), it <b>MUST NOT</b> use that response unless all of the selecting header fields nominated by the <code>Vary</code> header field match in both the original request (i.e., that associated with the stored response), and the presented request.
</p>
</blockquote>

<p>
一个缓存，当它接收到一个请求，而这个请求可以通过一个已缓存的带有一个 <code>Vary</code> 头字段（<a href="RFC7231.html#ID-ca7f8781-b183-4563-a90a-b9b7ad4f1032">【RFC7231】章节 7.1.4</a>）的响应来满足，那么，它 <b>禁止</b> 使用这种响应，除非所有由 <code>Vary</code> 头字段所指定的<ruby>选择头字段<rt>selecting header fields</rt></ruby>既与原始请求（即这个已存储响应所关联的那个请求）相匹配，也与所面临的请求相匹配。
</p>

<blockquote>
<p>
The selecting header fields from two requests are defined to match if and only if those in the first request can be transformed to those in the second request by applying any of the following:
</p>

<ul class="org-ul">
<li>adding or removing whitespace, where allowed in the header field's syntax</li>
<li>combining multiple header fields with the same field name (see <a href="RFC7230.html#ID-a6c4dceb-8a19-4799-a39b-b7240755c672">Section 3.2</a> of [RFC7230])</li>
<li>normalizing both header field values in a way that is known to have identical semantics, according to the header field's specification (e.g., reordering field values when order is not significant; case-normalization, where values are defined to be case-insensitive)</li>
</ul>
</blockquote>

<p>
来自这两个请求的<ruby>选择头字段<rt>selecting header fields</rt></ruby>是定义为相互匹配的，当且仅当在第一个请求的选择头字段，通过应用以下任何方式，能够转换为在第二个请求的选择头字段：
</p>

<ul class="org-ul">
<li>在头字段的句法所允许的位置添加或删除空白</li>
<li>合并多个相同字段名称的头字段（<a href="RFC7230.html#ID-a6c4dceb-8a19-4799-a39b-b7240755c672">【RFC7230】章节 3.2</a>）</li>
<li>依据头字段的规范，使用已知是具有同等语义的方式，来规范化两者的头字段值（比如，将头字段的值进行<ruby>重新排序<rt>reordering</rt></ruby>，如果它的顺序并不重要的话；对于值是定义为不区分大小写的地方进行<ruby>大小写规范化<rt>case-normalization</rt></ruby>）。</li>
</ul>

<blockquote>
<p>
If (after any normalization that might take place) a header field is absent from a request, it can only match another request if it is also absent there.
</p>
</blockquote>

<p>
如果（在进行过任何规范化操作以后）一个请求缺少某一个头字段，那么，它只能匹配上另一个同样缺少这个头字段的请求。
</p>

<blockquote>
<p>
A <code>Vary</code> header field-value of "*" always fails to match.
</p>
</blockquote>

<p>
值为 "*" 的 <code>Vary</code> 头字段总是无法匹配。
</p>

<blockquote>
<p>
The stored response with matching selecting header fields is known as the selected response.
</p>
</blockquote>

<p>
带有匹配上的<ruby>选择头字段<rt>selecting header fields</rt></ruby>的已存储响应，被称为<ruby>已选响应<rt>selected response</rt></ruby>。
</p>

<blockquote>
<p>
If multiple selected responses are available (potentially including responses without a <code>Vary</code> header field), the cache will need to choose one to use. When a selecting header field has a known mechanism for doing so (e.g., qvalues on <code>Accept</code> and similar request header fields), that mechanism <b>MAY</b> be used to select preferred responses; of the remainder, the most recent response (as determined by the <code>Date</code> header field) is used, as per <a href="#org937cf43">Section 4</a>.
</p>
</blockquote>

<p>
如果有多个可用的已选响应（可能包括没有 <code>Vary</code> 头字段的响应），缓存将需要选择一个来使用。当一个选择头字段有已知的机制用于做这种选择的时候（比如，<code>Accept</code> 上的 <code>qvalue</code> 以及类似的请求头字段），这种机制 <b>可以</b> 被用来选择<ruby>最优响应（可能多个）<rt>preferred responses</rt></ruby>。选择好最优响应以后，使用时间最近的那一个响应，见<a href="#org937cf43">章节 4</a>。
</p>

<blockquote>
<p>
If no selected response is available, the cache cannot satisfy the presented request. Typically, it is forwarded to the origin server in a (possibly conditional; see <a href="#org7ccec2c">Section 4.3</a>) request.
</p>
</blockquote>

<p>
如果没有可用的已选响应，那么，缓存无法满足所面临的请求。通常，它会以一个（可能是条件化的，见<a href="#org7ccec2c">章节 4.3</a>）请求将其转发到源服务器。
</p>
</div>
</div>

<div id="outline-container-org85ed084" class="outline-3">
<h3 id="org85ed084"><a id="ID-d414d2f7-d865-4b94-9efd-6b2578df86aa"></a>4.2. 新鲜度 / Freshness</h3>
<div class="outline-text-3" id="text-org85ed084">
<blockquote>
<p>
A fresh response is one whose age has not yet exceeded its freshness lifetime. Conversely, a stale response is one where it has.
</p>
</blockquote>

<p>
<ruby>新鲜的响应<rt>fresh response</rt></ruby>，是日期还没超过它的<ruby>保鲜期<rt>freshness lifetime</rt></ruby>的一种响应。相反，<ruby>陈旧的响应<rt>stale response</rt></ruby>，是日期已经超过它的保鲜期的一种响应。
</p>

<blockquote>
<p>
A response's freshness lifetime is the length of time between its generation by the origin server and its expiration time. An explicit expiration time is the time at which the origin server intends that a stored response can no longer be used by a cache without further validation, whereas a heuristic expiration time is assigned by a cache when no explicit expiration time is available.
</p>
</blockquote>

<p>
响应的<ruby>保鲜期<rt>freshness lifetime</rt></ruby>是从它被源服务器生成开始到它的<ruby>过期时间<rt>expiration time</rt></ruby>之间的时间长度。<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>，是源服务器打算让一个已存储的响应，在没有进一步的验证的情况下，不再能够被缓存所使用的那个时间点。与之相对，<ruby>启发式过期时间<rt>heuristic expiration time</rt></ruby>，是当没有可用的<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>的时候由缓存所指派的过期时间。
</p>

<blockquote>
<p>
译注：<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>与<ruby>启发式过期时间<rt>heuristic expiration time</rt></ruby>都是专业术语，下文会多次引用这两个术语。
</p>
</blockquote>

<blockquote>
<p>
A response's age is the time that has passed since it was generated by, or successfully validated with, the origin server.
</p>
</blockquote>

<p>
一个响应的“年龄”指的是从它被源服务器生成开始，或者从它被源服务器成功验证开始，已经过去了多长时间。
</p>

<blockquote>
<p>
When a response is "fresh" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.
</p>
</blockquote>

<p>
当一个响应在缓存中是“新鲜的”，那么，它能够被用于满足后续的请求，而不需要事先与源服务器取得联系。
</p>

<blockquote>
<p>
The primary mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using either the <code>Expires</code> header field (<a href="#org304d2d1">Section 5.3</a>) or the <code>max-age</code> response directive (<a href="#orgc309465">Section 5.2.2.8</a>). Generally, origin servers will assign future explicit expiration times to responses in the belief that the representation is not likely to change in a semantically significant way before the expiration time is reached.
</p>
</blockquote>

<p>
确定新鲜度的主要机制是源服务器提供一个未来的<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>，可以使用 <code>Expires</code> 头字段（<a href="#org304d2d1">章节 5.3</a>）来提供，也可以使用 <code>max-age</code> 响应指令（<a href="#orgc309465">章节 5.2.2.8</a>）来提供。通常，源服务器会为响应指派一个未来的明确过期时间，认为在过期时间来临之前，表示形式不太可能会有语义上的重大变化。
</p>

<blockquote>
<p>
If an origin server wishes to force a cache to validate every request, it can assign an explicit expiration time in the past to indicate that the response is already stale. Compliant caches will normally validate a stale cached response before reusing it for subsequent requests (see <a href="#orga71285a">Section 4.2.4</a>).
</p>
</blockquote>

<p>
如果源服务器希望强制让缓存每一次请求都要向源服务器进行验证，那么，它可以指派一个过去的<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>，来表明这个响应已经是<ruby>陈旧的<rt>stale</rt></ruby>。遵从规范的缓存将会在复用一个陈旧的已缓存的响应来满足后续请求之前，正常地验证它（见<a href="#orga71285a">章节 4.2.4</a>）。
</p>

<blockquote>
<p>
Since origin servers do not always provide explicit expiration times, caches are also allowed to use a heuristic to determine an expiration time under certain circumstances (see <a href="#org4c48fcc">Section 4.2.2</a>).
</p>
</blockquote>

<p>
因为源服务器并不总是会提供<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>的，因此，在某种情况下，规范还允许缓存使用<ruby>启发式方法<rt>heuristic</rt></ruby>来确定一个过期时间（<a href="#org4c48fcc">章节 4.2.2</a>）。
</p>

<blockquote>
<p>
The calculation to determine if a response is fresh is:
</p>
</blockquote>

<p>
确定一个响应是否<ruby>新鲜<rt>fresh</rt></ruby>的计算方法为：
</p>

<div class="org-src-container">
<pre class="src src-text">response_is_fresh = (freshness_lifetime &gt; current_age)
</pre>
</div>

<blockquote>
<p>
<code>freshness_lifetime</code> is defined in <a href="#org4e92c7f">Section 4.2.1</a>; <code>current_age</code> is defined in <a href="#org3fee265">Section 4.2.3</a>.
</p>
</blockquote>

<p>
<code>freshness_lifetime</code> 定义在<a href="#org4e92c7f">章节 4.2.1</a>，<code>current_age</code> 定义在<a href="#org3fee265">章节 4.2.3</a>。
</p>

<blockquote>
<p>
Clients can send the <code>max-age</code> or <code>min-fresh</code> cache directives in a request to constrain or relax freshness calculations for the corresponding response (<a href="#org8707cd3">Section 5.2.1</a>).
</p>
</blockquote>

<p>
客户端能够在请求中发送 <code>max-age</code> 或者 <code>min-fresh</code> 缓存指令来限制或放松对应响应的新鲜度计算（<a href="#org8707cd3">章节 5.2.1</a>）。
</p>

<blockquote>
<p>
When calculating freshness, to avoid common problems in date parsing:
</p>

<ul class="org-ul">
<li>Although all date formats are specified to be case-sensitive, a cache recipient <b>SHOULD</b> match day, week, and time-zone names case-insensitively.</li>
<li>If a cache recipient's internal implementation of time has less resolution than the value of an <code>HTTP-date</code>, the recipient <b>MUST</b> internally represent a parsed <code>Expires</code> date as the nearest time equal to or earlier than the received value.</li>
<li>A cache recipient <b>MUST NOT</b> allow local time zones to influence the calculation or comparison of an age or expiration time.</li>
<li>A cache recipient <b>SHOULD</b> consider a date with a zone abbreviation other than GMT or UTC to be invalid for calculating expiration.</li>
</ul>
</blockquote>

<p>
当计算新鲜度的时候，为了避免日期解析的常见问题：
</p>

<ul class="org-ul">
<li>虽然所有日期格式都被指定为<ruby>区分大小写<rt>case-sensitive</rt></ruby>，但是，<ruby>缓存接收端<rt>cache recipient</rt></ruby> <b>应当</b> 使用<ruby>不区分大小写<rt>case-insensitive</rt></ruby>的方式来匹配<ruby>日<rt>day</rt></ruby>、<ruby>周<rt>week</rt></ruby>、以及<ruby>时区<rt>time-zone</rt></ruby>的名称。</li>
<li>如果缓存接收端关于时间的内部实现的精度低于 <code>HTTP-date</code> 的值的精度，那么，接收端 <b>必须</b> 以早于或等于所接收到的值的最接近的时间来内部表示一个解析过的 <code>Expires</code>。</li>
<li>缓存接收端 <b>禁止</b> 允许本地时区来影响<ruby>年龄或过期时间<rt>age or expiration time</rt></ruby>的计算或对比。</li>
<li>缓存接收端 <b>应当</b> 将一个带有时区缩写不是 GMT 或 UTC 的一个日期视为无效于过期时间计算。</li>
</ul>

<blockquote>
<p>
Note that freshness applies only to cache operation; it cannot be used to force a user agent to refresh its display or reload a resource. See <a href="#orgace9974">Section 6</a> for an explanation of the difference between caches and history mechanisms.
</p>
</blockquote>

<p>
需要注意的是，新鲜度仅适用于缓存操作，它并不能被用于强制一个用户代理去<ruby>刷新<rt>refresh</rt></ruby>它的展示或者<ruby>重新加载<rt>reload</rt></ruby>一个资源。关于缓存与历史记录的机制的不同点的解释，见<a href="#orgace9974">章节 6</a>。
</p>
</div>

<div id="outline-container-org4e92c7f" class="outline-4">
<h4 id="org4e92c7f"><a id="ID-297b33de-eb1e-4988-b28f-b21e8ecc5ffa"></a>4.2.1. 计算保鲜期 / Calculating Freshness Lifetime</h4>
<div class="outline-text-4" id="text-org4e92c7f">
<blockquote>
<p>
A cache can calculate the freshness lifetime (denoted as <code>freshness_lifetime</code>) of a response by using the first match of the following:
</p>

<ul class="org-ul">
<li>If the cache is shared and the <code>s-maxage</code> response directive (<a href="#orgf601e80">Section 5.2.2.9</a>) is present, use its value, or</li>
<li>If the <code>max-age</code> response directive (<a href="#orgc309465">Section 5.2.2.8</a>) is present, use its value, or</li>
<li>If the <code>Expires</code> response header field (<a href="#org304d2d1">Section 5.3</a>) is present, use its value minus the value of the <code>Date</code> response header field, or</li>
<li>Otherwise, no explicit expiration time is present in the response. A heuristic freshness lifetime might be applicable; see <a href="#org4c48fcc">Section 4.2.2</a>.</li>
</ul>
</blockquote>

<p>
缓存能够计算一个响应的保鲜期（表示为 <code>freshness_lifetime</code>），通过使用下列第一个能够匹配上的方式：
</p>

<ul class="org-ul">
<li>如果缓存是共享的，并且响应中出现了 <code>s-maxage</code> 响应指令（<a href="#orgf601e80">章节 5.2.2.9</a>），那么，使用这个指令的值，或者：</li>
<li>如果响应中出现了 <code>max-age</code> 响应指令（<a href="#orgc309465">章节 5.2.2.8</a>），那么，使用这个指令的值，或者：</li>
<li>如果响应中出现了 <code>Expires</code> 响应头字段（<a href="#org304d2d1">章节 5.3</a>），那么，使用它的值减去 <code>Date</code> 响应头字段的值，或者：</li>
<li>否则，响应中没有出现<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>。可能适用于一个启发式保鲜期，见<a href="#org4c48fcc">章节 4.2.2</a>。</li>
</ul>

<blockquote>
<p>
Note that this calculation is not vulnerable to clock skew, since all of the information comes from the origin server.
</p>
</blockquote>

<p>
需要注意的是，这种计算是不会受到<ruby>时钟偏差<rt>clock skew</rt></ruby>的影响的，这是因为所有的信息都是来自源服务器的。
</p>

<blockquote>
<p>
When there is more than one value present for a given directive (e.g., two <code>Expires</code> header fields, multiple <code>Cache-Control: max-age</code> directives), the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale.
</p>
</blockquote>

<p>
当一个给定的指令中出现超过一个以上的值（比如，有两个 <code>Expires</code> 头字段、多个 <code>Cache-Control</code> 指令等），那么，这个指令的值被视为无效的。规范鼓励缓存把带有无效的新鲜度信息的那种响应视为是<ruby>陈旧的<rt>stale</rt></ruby>。
</p>
</div>
</div>

<div id="outline-container-org4c48fcc" class="outline-4">
<h4 id="org4c48fcc"><a id="ID-9bcea6ca-bab6-4324-9cdb-cf7855aeba01"></a>4.2.2. 计算启发式新鲜度 / Calculating Heuristic Freshness</h4>
<div class="outline-text-4" id="text-org4c48fcc">
<blockquote>
<p>
Since origin servers do not always provide explicit expiration times, a cache <b>MAY</b> assign a heuristic expiration time when an explicit time is not specified, employing algorithms that use other header field values (such as the <code>Last-Modified</code> time) to estimate a plausible expiration time. This specification does not provide specific algorithms, but does impose worst-case constraints on their results.
</p>
</blockquote>

<p>
因为源服务器并不总是会提供<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>的，因此，当它没有指定一个过期时间的时候，缓存可以指派一个<ruby>启发式过期时间<rt>heuristic expiration time</rt></ruby>，原理是利用一种使用其他头字段值来估算出一个看似合理的过期时间的算法。本规范并没有提供具体的算法，但是对它们的计算结果的最差情况实施了约束。
</p>

<blockquote>
<p>
A cache <b>MUST NOT</b> use heuristics to determine freshness when an explicit expiration time is present in the stored response. Because of the requirements in <a href="#orga05eb41">Section 3</a>, this means that, effectively, heuristics can only be used on responses without explicit freshness whose status codes are defined as cacheable by default (see <a href="RFC7231.html#ID-8c218f07-c0c7-450c-bb2f-7af73aac3c39">Section 6.1</a> of [RFC7231]), and those responses without explicit freshness that have been marked as explicitly cacheable (e.g., with a "<code>public</code>" response directive).
</p>
</blockquote>

<p>
当一个已存储的响应中出现了一个<ruby>明确过期时间<rt>explicit expiration time</rt></ruby>的时候，缓存 <b>禁止</b> 使用启发式来确定新鲜度。由于<a href="#orga05eb41">章节 3</a> 中的要求，这意味着，实际上，启发式仅能用于没有明确新鲜度的响应，并且要求以下情况之一：
</p>

<ul class="org-ul">
<li>这些响应的状态码被定义为默认是可缓存的（见<a href="RFC7231.html#ID-8c218f07-c0c7-450c-bb2f-7af73aac3c39">【RFC7231】章节 6.1</a>）；</li>
<li>这些响应被明确标记为可缓存的（比如，带有一个 <code>public</code> 响应指定）。</li>
</ul>

<blockquote>
<p>
If the response has a <code>Last-Modified</code> header field (<a href="RFC7232.html#ID-9c92bfe5-3e6e-4b70-9cf5-9a5fd8810840">Section 2.2</a> of [RFC7232]), caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be <b>10%</b>.
</p>
</blockquote>

<p>
如果响应带有一个 <code>Last-Modified</code> 头字段（<a href="RFC7232.html#ID-9c92bfe5-3e6e-4b70-9cf5-9a5fd8810840">【RFC7232】章节 2.2</a>），规范鼓励缓存所使用的启发式过期时间的值不超过那个头字段的时间以后的某个比例，通常这个比例会设置为 <b>10%</b>。 
</p>

<blockquote>
<p>
When a heuristic is used to calculate freshness lifetime, a cache <b>SHOULD</b> generate a <code>Warning</code> header field with a <code>113</code> warn-code (see <a href="#org61c78c6">Section 5.5.4</a>) in the response if its <code>current_age</code> is more than 24 hours and such a warning is not already present.
</p>
</blockquote>

<p>
当使用启发式来计算<ruby>保鲜期<rt>freshness lifetime</rt></ruby>的时候，缓存 <b>应当</b> 在响应里生成一个 <code>Warning</code> 头字段，其值带有一个 <code>113</code> 警告码（见<a href="#org61c78c6">章节 5.5.4</a>），如果这个响应的 <code>current_age</code> 大于 24 小时而且响应中还没有出现这种警告的话。
</p>

<blockquote>
<p>
<b>Note:</b> <a href="https://tools.ietf.org/html/rfc2616#section-13.9">Section 13.9</a> of [RFC2616] prohibited caches from calculating heuristic freshness for URIs with <code>query</code> components (i.e., those containing '?'). In practice, this has not been widely implemented. Therefore, origin servers are encouraged to send explicit directives (e.g., <code>Cache-Control: no-cache</code>) if they wish to preclude caching.
</p>
</blockquote>

<p>
<b>注意：</b> 对于带有 <code>query</code> 组件的 URI（也就是说，包含有 "?" 的 URI），<a href="https://tools.ietf.org/html/rfc2616#section-13.9">【RFC2616】章节 13.9</a> 禁止缓存对这种 URI 计算启发式新鲜度。实践中，这项要求并未被广泛实现。因此，规范鼓励源服务器去发送明确的指令（比如，<code>Cache-Control: no-cache</code>），如果它们希望阻止缓存的话。
</p>
</div>
</div>

<div id="outline-container-org3fee265" class="outline-4">
<h4 id="org3fee265"><a id="ID-80278eea-c1e4-478a-b972-ca42270c1fd0"></a>4.2.3. 计算年龄 / Calculating Age</h4>
<div class="outline-text-4" id="text-org3fee265">
<blockquote>
<p>
The <code>Age</code> header field is used to convey an estimated age of the response message when obtained from a cache. The <code>Age</code> field value is the cache's estimate of the number of seconds since the response was generated or validated by the origin server. In essence, the <code>Age</code> value is the sum of the time that the response has been resident in each of the caches along the path from the origin server, plus the amount of time it has been in transit along network paths.
</p>
</blockquote>

<p>
<code>Age</code> 头字段被用于运载一个估算的年龄，这个年龄表示从一个缓存中获得这个响应消息时，这个响应消息的年龄。<code>Age</code> 字段的值是从这个响应被源服务器所生成或所验证的那一时刻开始，直到缓存使用这个响应来满足请求为止，所经历的时间秒数的估算值。本质上，<code>Age</code> 的值是由下列时间构成：
</p>

<ul class="org-ul">
<li>从源服务器开始，沿着响应消息的路径，响应消息驻留在每一个缓存节点里的时间之和，加上：</li>
<li>响应消息沿着网络路径在各个节点间进行传输的总耗时。</li>
</ul>

<blockquote>
<p>
译注：实际上，<code>Age</code> 值的计算并不是使用上述这些数据来生成，因为如果这样计算，就需要把响应在当前缓存节点的驻留时间加上所有上游缓存节点的驻留时间，还要加上各个节点间的传输时间，非常麻烦。
</p>
</blockquote>

<blockquote>
<p>
The following data is used for the age calculation:
</p>

<dl class="org-dl">
<dt>age_value</dt><dd>The term "<code>age_value</code>" denotes the value of the <code>Age</code> header field (<a href="#orgb943d27">Section 5.1</a>), in a form appropriate for arithmetic operation; or 0, if not available.</dd>
<dt>date_value</dt><dd>The term "<code>date_value</code>" denotes the value of the <code>Date</code> header field, in a form appropriate for arithmetic operations. See <a href="RFC7231.html#ID-5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1">Section 7.1.1.2</a> of [RFC7231] for the definition of the <code>Date</code> header field, and for requirements regarding responses without it.</dd>
<dt>now</dt><dd>The term "<code>now</code>" means "the current value of the clock at the host performing the calculation". A host ought to use NTP ([<a href="https://tools.ietf.org/html/rfc5905">RFC5905</a>]) or some similar protocol to synchronize its clocks to Coordinated Universal Time.</dd>
<dt>request_time</dt><dd>The current value of the clock at the host at the time the request resulting in the stored response was made.</dd>
<dt>response_time</dt><dd>The current value of the clock at the host at the time the response was received.</dd>
</dl>
</blockquote>

<p>
以下数据用于计算年龄：
</p>

<dl class="org-dl">
<dt>age_value</dt><dd>术语 <code>age_value</code> 表示 <code>Age</code> 头字段（<a href="#orgb943d27">章节 5.1</a>）的值，以一种适合算术运算的形式来表示，其中，0 代表不可用。</dd>
<dt>date_value</dt><dd>术语 <code>date_value</code> 表示 <code>Date</code> 头字段的值，以一种适合算术运算的形式来表示。<code>Date</code> 头字段的定义，以及响应不带有这个字段时的相关要求，见<a href="RFC7231.html#ID-5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1">【RFC7231】章节 7.1.1.2</a>。</dd>
<dt>now</dt><dd>术语 <code>now</code> 的含义是：在执行计算的时候，主机时钟的当前时间值。主机应该使用 NTP（【<a href="https://tools.ietf.org/html/rfc5905">RFC5905</a>】）或者某些类似的协议来同步它的时钟为 UTC 时间。</dd>
<dt>request_time</dt><dd>请求的发起时，主机时钟的当前时间值，这个请求会导致产生一个已存储的响应。</dd>
<dt>response_time</dt><dd>接收到响应时，主机时钟的当前时间值。</dd>
</dl>

<blockquote>
<p>
译注：
</p>
<ul class="org-ul">
<li><code>Date</code>：表示响应消息在源服务器中诞生的时间，其值是一个 <code>HTTP-date</code> （<a href="RFC7231.html#ID-5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1">【RFC7231】章节 7.1.1.2</a>）。</li>
<li><code>Age</code>：表示已缓存的响应的年龄，即，从这个响应被源服务器所生成或所验证的那一时刻开始，直到缓存使用这个响应来满足请求为止，所经历的时间秒数的估算值，其值是一个秒数。</li>
</ul>
</blockquote>

<blockquote>
<p>
译注：<code>now</code>、<code>request_time</code>、以及 <code>response_time</code> 都是本地时间，虽然上述的“主机”指的是同一个缓存所在的主机，但由于 <code>Date</code> 是由服务器时间生成的，并且消息链路中可能出现多个缓存主机，这样就涉及到多个主机间的时钟可能不同步的问题，即<ruby>时钟偏差<rt>clock skew</rt></ruby>，因此才需要使用 NTP 协议来同步时钟。
</p>
</blockquote>

<blockquote>
<p>
A response's age can be calculated in two entirely independent ways:
</p>

<ol class="org-ol">
<li>the "<code>apparent_age</code>": <code>response_time</code> minus <code>date_value</code>, if the local clock is reasonably well synchronized to the origin server's clock. If the result is negative, the result is replaced by zero.</li>
<li>the "<code>corrected_age_value</code>", if all of the caches along the response path implement HTTP/1.1. A cache <b>MUST</b> interpret this value relative to the time the request was initiated, not the time that the response was received.</li>
</ol>
</blockquote>

<p>
一个响应的年龄可以使用两种完全独立的方式来计算出来：
</p>

<ol class="org-ol">
<li><code>apparent_age</code>：<code>response_time</code> 减去 <code>date_value</code>，如果本地时钟与源服务器的时候同步得相当好的话。如果计算结果为负数，则将其改为 0。</li>
<li><code>corrected_age_value</code>：如果响应消息沿路的所有缓存都实现了 HTTP/1.1，才适用这种方式。缓存 <b>必须</b> 相对于发起请求的时刻来解释这个值，而不是相对于接收到响应的时刻。</li>
</ol>

<div class="org-src-container">
<pre class="src src-text">apparent_age = max(0, response_time - date_value);

response_delay = response_time - request_time;
corrected_age_value = age_value + response_delay;  
</pre>
</div>

<blockquote>
<p>
These are combined as
</p>
</blockquote>

<p>
两种方式合并为：
</p>

<div class="org-src-container">
<pre class="src src-text">corrected_initial_age = max(apparent_age, corrected_age_value);
</pre>
</div>

<blockquote>
<p>
unless the cache is confident in the value of the <code>Age</code> header field (e.g., because there are no HTTP/1.0 hops in the <code>Via</code> header field), in which case the <code>corrected_age_value</code> <b>MAY</b> be used as the <code>corrected_initial_age</code>.
</p>
</blockquote>

<p>
除非缓存确信 <code>Age</code> 头字段的值（比如，因为 <code>Via</code> 头字段里没有任何 HTTP/1.0 的节点），在这种情况下，<code>corrected_age_value</code> <b>可以</b> 作为 <code>corrected_initial_age</code> 来使用。
</p>

<blockquote>
<p>
The <code>current_age</code> of a stored response can then be calculated by adding the amount of time (in seconds) since the stored response was last validated by the origin server to the <code>corrected_initial_age</code>.
</p>
</blockquote>

<p>
然后，已存储的响应就可以计算出 <code>current_age</code> 了：通过把从这个已存储的响应最后一次被源服务器验证的时刻开始到现在为止所经历的总时长（秒），加入到 <code>corrected_initial_age</code> 上。
</p>

<div class="org-src-container">
<pre class="src src-text">resident_time = now - response_time;
current_age = corrected_initial_age + resident_time;
</pre>
</div>
</div>
</div>

<div id="outline-container-orga71285a" class="outline-4">
<h4 id="orga71285a"><a id="ID-630361ae-a4e3-4fec-b337-8eff30325ddf"></a>4.2.4. 提供陈旧的响应 / Serving Stale Responses</h4>
<div class="outline-text-4" id="text-orga71285a">
<blockquote>
<p>
A "stale" response is one that either has explicit expiry information or is allowed to have heuristic expiry calculated, but is not fresh according to the calculations in <a href="#org85ed084">Section 4.2</a>.
</p>
</blockquote>

<p>
一个 "stale"（陈旧的、不新鲜的）的响应是这样一种响应：或者带有明确的<ruby>过期信息<rt>expiry information</rt></ruby>或者允许去进行启发式的<ruby>过期计算<rt>expiry calculated</rt></ruby>，但根据<a href="#org85ed084">章节 4.2</a> 的计算，已不再<ruby>新鲜<rt>fresh</rt></ruby>。
</p>

<blockquote>
<p>
A cache <b>MUST NOT</b> generate a stale response if it is prohibited by an explicit in-protocol directive (e.g., by a "<code>no-store</code>" or "<code>no-cache</code>" cache directive, a "<code>must-revalidate</code>" cache-response-directive, or an applicable "<code>s-maxage</code>" or "<code>proxy-revalidate</code>" cache-response-directive; see <a href="#org1336445">Section 5.2.2</a>).
</p>
</blockquote>

<p>
缓存 <b>禁止</b> 生成一个<ruby>陈旧的响应<rt>stale response</rt></ruby>，如果它被一个明确的协议内的指令（比如，被一个 <code>no-store</code> 或者 <code>no-cache</code> <ruby>缓存指令<rt>cache directive</rt></ruby>、一个 <code>must-revalidate</code> <ruby>缓存响应指令<rt>cache-response-directive</rt></ruby>、或者一个适用的 <code>s-maxage</code> 或者 <code>proxy-revalidate</code> 缓存响应指令，见<a href="#org1336445">章节 5.2.2</a>）所禁止的话。
</p>

<blockquote>
<p>
A cache <b>MUST NOT</b> send stale responses unless it is disconnected (i.e., it cannot contact the origin server or otherwise find a forward path) or doing so is explicitly allowed (e.g., by the <code>max-stale</code> request directive; see <a href="#org8707cd3">Section 5.2.1</a>).
</p>
</blockquote>

<p>
缓存 <b>禁止</b> 发送陈旧的响应，除非它的连接被中断（也就是说，它不能够联系到源服务器或者找不到一个转发路径），或者被明确允许这样做（比如，通过 <code>max-stale</code> 请求指令，见<a href="#org8707cd3">章节 5.2.1</a>）。
</p>

<blockquote>
<p>
A cache <b>SHOULD</b> generate a <code>Warning</code> header field with the <code>110</code> warn-code (see <a href="#orgb2503cc">Section 5.5.1</a>) in stale responses. Likewise, a cache <b>SHOULD</b> generate a <code>112</code> warn-code (see <a href="#org0637a23">Section 5.5.3</a>) in stale responses if the cache is disconnected.
</p>
</blockquote>

<p>
缓存 <b>应当</b> 在<ruby>陈旧的响应<rt>stale responses</rt></ruby>中生成一个 <code>Warning</code> 头字段，其值带有一个 <code>110</code> 警告码（见<a href="#orgb2503cc">章节 5.5.1</a>）。同样，缓存 <b>应当</b> 在陈旧的响应中生成一个 <code>112</code> 警告码（见<a href="#org0637a23">章节 5.5.3</a>），如果缓存的连接被中断的话。
</p>

<blockquote>
<p>
A cache <b>SHOULD NOT</b> generate a new <code>Warning</code> header field when forwarding a response that does not have an <code>Age</code> header field, even if the response is already stale. A cache need not validate a response that merely became stale in transit.
</p>
</blockquote>

<p>
当缓存转发一个响应，但这个响应并没有一个 <code>Age</code> 头字段的时候，缓存 <b>不应当</b> 生成一个新的 <code>Warning</code> 头字段，即使这个响应已经是陈旧的。一个响应只在在传输过程中变成陈旧的，那么，缓存不需要验证这个响应。
</p>
</div>
</div>
</div>

<div id="outline-container-org7ccec2c" class="outline-3">
<h3 id="org7ccec2c"><a id="ID-47a8482e-e33f-435a-8abd-9a82f117f7a0"></a>4.3. 验证 / Validation</h3>
<div class="outline-text-3" id="text-org7ccec2c">
<blockquote>
<p>
When a cache has one or more stored responses for a requested URI, but cannot serve any of them (e.g., because they are not fresh, or one cannot be selected; see <a href="#org64a44b1">Section 4.1</a>), it can use the conditional request mechanism [RFC7232] in the forwarded request to give the next inbound server an opportunity to select a valid stored response to use, updating the stored metadata in the process, or to replace the stored response(s) with a new response. This process is known as "validating" or "revalidating" the stored response.
</p>
</blockquote>

<p>
对于所请求的一个 URI，当缓存已经存储了这个 URI 对应的一个或多个响应，但缓存却不能使用它们之中的任何一个来满足这个请求（比如，因为它们都不再新鲜，或者没有一个可以选择的，见<a href="#org64a44b1">章节 4.1</a>），这时候，缓存在转发这个请求时可以应用<ruby>条件请求<rt>conditional request</rt></ruby>的机制【RFC7232】，给下一个<ruby>入站服务器<rt>inbound server</rt></ruby>一个机会来选择一个有效的已存储的响应来使用，在这个过程中会更新已存储的元数据；或者使用一个新的响应到替换（可能是多个）已存储的响应。这个过程称为对已存储的响应进行“<ruby>验证<rt>validating</rt></ruby>”或者“<ruby>重新验证<rt>revalidating</rt></ruby>”。
</p>

<blockquote>
<p>
译注：所谓“入站”，即数据流朝向源服务器流动，见<a href="RFC7230.html#ID-e2d9bed8-d6ca-4b5d-ab4a-6b2b2576393e">【RFC7230】章节 2.3</a>。
</p>
</blockquote>
</div>

<div id="outline-container-orgd178c24" class="outline-4">
<h4 id="orgd178c24">4.3.1. 发送验证请求 / Sending a Validation Request</h4>
<div class="outline-text-4" id="text-orgd178c24">
<blockquote>
<p>
When sending a conditional request for cache validation, a cache sends one or more precondition header fields containing validator metadata from its stored response(s), which is then compared by recipients to determine whether a stored response is equivalent to a current representation of the resource.
</p>
</blockquote>

<p>
当发送一个条件请求来进行缓存验证的时候，缓存发送一个或多个前提条件头字段来包含<ruby>验证器元数据<rt>validator metadata</rt></ruby>，这些元数据来自（可能是多个）已存储的响应，然后，接收端会对比这些验证器，确定是否有一个已存储的响应等价于资源的一个当前表示形式。
</p>

<blockquote>
<p>
One such validator is the timestamp given in a <code>Last-Modified</code> header field (<a href="RFC7232.html#ID-9c92bfe5-3e6e-4b70-9cf5-9a5fd8810840">Section 2.2</a> of [RFC7232]), which can be used in an <code>If-Modified-Since</code> header field for response validation, or in an <code>If-Unmodified-Since</code> or <code>If-Range</code> header field for representation selection (i.e., the client is referring specifically to a previously obtained representation with that timestamp).
</p>
</blockquote>

<p>
<code>Last-Modified</code> 头字段（<a href="RFC7232.html#ID-9c92bfe5-3e6e-4b70-9cf5-9a5fd8810840">【RFC7232】章节 2.2</a>）里给出的<ruby>时间戳<rt>timestamp</rt></ruby>就是上述这些验证器中的一个，这个时间戳能够被用在 <code>If-Modified-Since</code> 头字段来验证响应，或者被用在 <code>If-Unmodified-Since</code> 或 <code>If-Range</code> 头字段来选择表示形式（也就是说，客户端特指之前所获取到的带有那个时间戳的那一个表示形式）。
</p>

<blockquote>
<p>
Another validator is the entity-tag given in an <code>ETag</code> header field (<a href="RFC7232.html#ID-0244a602-2c4a-46aa-96c4-3bd14c3eb244">Section 2.3</a> of [RFC7232]). One or more entity-tags, indicating one or more stored responses, can be used in an <code>If-None-Match</code> header field for response validation, or in an <code>If-Match</code> or <code>If-Range</code> header field for representation selection (i.e., the client is referring specifically to one or more previously obtained representations with the listed entity-tags).
</p>
</blockquote>

<p>
另一个验证器是 <code>ETag</code> 头字段（<a href="RFC7232.html#ID-0244a602-2c4a-46aa-96c4-3bd14c3eb244">【RFC7232】章节 2.3</a>）里给出的<ruby>实体标签<rt>entity-tag</rt></ruby>。一个或多个实体标签，表明一个或多个已存储的响应，能够被用在 <code>If-None-Match</code> 头字段来验证响应，或者被用在 <code>If-Match</code> 或 <code>If-Range</code> 头字段来选择表示形式（也就是说，客户端特指之前所获取到的带有这些实体标签的那一个或多个表示形式）。
</p>
</div>
</div>

<div id="outline-container-orgb0cd77f" class="outline-4">
<h4 id="orgb0cd77f"><a id="ID-A500DFDD-0DD6-454E-A94A-EDBC8D38946E"></a>4.3.2. 处理接收到的验证请求 / Handling a Received Validation Request</h4>
<div class="outline-text-4" id="text-orgb0cd77f">
<blockquote>
<p>
Each client in the request chain may have its own cache, so it is common for a cache at an intermediary to receive conditional requests from other (outbound) caches. Likewise, some user agents make use of conditional requests to limit data transfers to recently modified representations or to complete the transfer of a partially retrieved representation.
</p>
</blockquote>

<p>
在请求链路中的每一个客户端都可能有自己的缓存，所以，一个中间人缓存接收到来自其他的（<ruby>出站<rt>outbound</rt></ruby>）缓存的<ruby>条件请求<rt>conditional requests</rt></ruby>是很常见的。同样，某些用户代理利用条件请求来对数据传输限制为最近修改过的表示形式，或者限制为完成一个只接收到部分的表示形式的传输。
</p>

<blockquote>
<p>
译注：所谓“出站”，即数据流朝向客户端流动，见<a href="RFC7230.html#ID-e2d9bed8-d6ca-4b5d-ab4a-6b2b2576393e">【RFC7230】章节 2.3</a>。
</p>
</blockquote>

<blockquote>
<p>
If a cache receives a request that can be satisfied by reusing one of its stored <code>200 (OK)</code> or <code>206 (Partial Content)</code> responses, the cache <b>SHOULD</b> evaluate any applicable conditional header field preconditions received in that request with respect to the corresponding validators contained within the selected response. A cache <b>MUST NOT</b> evaluate conditional header fields that are only applicable to an origin server, found in a request with semantics that cannot be satisfied with a cached response, or applied to a target resource for which it has no stored responses; such preconditions are likely intended for some other (inbound) server.
</p>
</blockquote>

<p>
如果一个缓存接收到一个请求，而它能够通过复用它已存储的其中一个 <code>200 (OK)</code> 或 <code>206 (Partial Content)</code> 响应来满足这个请求，那么，这个缓存 <b>应当</b> 在包含在<ruby>已选响应<rt>selected response</rt></ruby>（<a href="#org64a44b1">章节 4.1</a>）中的验证器方面，对接收自那个请求中的对应的任何适用的<ruby>条件请求头字段<rt>conditional header field</rt></ruby>的前提条件进行<ruby>求值<rt>evaluate</rt></ruby>。缓存 <b>禁止</b> 对以下条件头字段进行求值：只适用于源服务器的头字段；在请求中找到的，但语义不能使用一个已缓存的响应来满足的头字段；或者应用于目标资源的头字段，因为这个缓存没有已存储的响应——上述这些前提条件可能是用于某些其他（<ruby>入站<rt>inbound</rt></ruby>）服务器的。
</p>

<blockquote>
<p>
The proper evaluation of conditional requests by a cache depends on the received precondition header fields and their precedence, as defined in <a href="RFC7232.html#ID-a8107f7c-c07e-4a0b-a0e5-fc41064ca2b2">Section 6</a> of [RFC7232]. The <code>If-Match</code> and <code>If-Unmodified-Since</code> conditional header fields are not applicable to a cache.
</p>
</blockquote>

<p>
缓存如何正确对条件请求进行<ruby>求值<rt>evaluation</rt></ruby>，依赖于其接收到的前提条件头字段以及它们的优先级，正如<a href="RFC7232.html#ID-a8107f7c-c07e-4a0b-a0e5-fc41064ca2b2">【RFC7232】章节 6</a> 所定义的。<code>If-Match</code> 和 <code>If-Unmodified-Since</code> 条件头字段并不适用于缓存。
</p>

<blockquote>
<p>
A request containing an <code>If-None-Match</code> header field (<a href="RFC7232.html#ID-30878863-9a64-4efe-bc9b-07386eae0ed7">Section 3.2</a> of [RFC7232]) indicates that the client wants to validate one or more of its own stored responses in comparison to whichever stored response is selected by the cache. If the field-value is "*", or if the field-value is a list of entity-tags and at least one of them matches the entity-tag of the selected stored response, a cache recipient <b>SHOULD</b> generate a <code>304 (Not Modified)</code> response (using the metadata of the selected stored response) instead of sending that stored response.
</p>
</blockquote>

<p>
一个请求，如果它包含有一个 <code>If-None-Match</code> 头字段（<a href="RFC7232.html#ID-30878863-9a64-4efe-bc9b-07386eae0ed7">【RFC7232】章节 3.2</a>），则表明：客户端想通过与缓存选定的任何已存储的响应相比较的方式，来验证客户端所拥有的一个或多个已存储的响应。如果它的字段值是 "*"，或者它的字段值是一个实体标签列表并且至少其中之一个与<ruby>已选的已存储的响应<rt>selected stored response</rt></ruby>相匹配，那么，缓存接收端 <b>应当</b> 生成一个 <code>304 (Not Modified)</code> 响应（使用那个已选的已存储的响应的元数据），而不是发送那个已存储的响应。
</p>

<blockquote>
<p>
When a cache decides to revalidate its own stored responses for a request that contains an <code>If-None-Match</code> list of entity-tags, the cache <b>MAY</b> combine the received list with a list of entity-tags from its own stored set of responses (fresh or stale) and send the union of the two lists as a replacement <code>If-None-Match</code> header field value in the forwarded request. If a stored response contains only partial content, the cache <b>MUST NOT</b> include its entity-tag in the union unless the request is for a range that would be fully satisfied by that partial stored response. If the response to the forwarded request is <code>304 (Not Modified)</code> and has an <code>ETag</code> header field value with an entity-tag that is not in the client's list, the cache <b>MUST</b> generate a <code>200 (OK)</code> response for the client by reusing its corresponding stored response, as updated by the <code>304</code> response metadata (<a href="#org84ebeaf">Section 4.3.4</a>).
</p>
</blockquote>

<p>
一个请求，其包含有一个 <code>If-None-Match</code> 头字段，字段值是实体标签的一个列表，当一个缓存决定为这个请求重新验证它所拥有的已存储的响应的时候，缓存 <b>可以</b> 将所接收到的列表与它所拥有的已存储的响应集合（新鲜的或陈旧的）的实体标签列表合并成一个列表，然后将这个联合列表代替到将要转发的请求的 <code>If-None-Match</code> 头字段值进行发送。如果某个已存储的响应包含的仅为表示形式的一<ruby>部分内容<rt>partial content</rt></ruby>，那么，缓存 <b>禁止</b> 将这个响应的实体标签包含进联合列表中，除非这个请求是一个范围请求且请求的范围可以被那个已存储的部分响应完全满足。如果转发请求后返回的是一个 <code>304 (Not Modified)</code> 响应，并且这个响应有一个 <code>ETag</code> 头字段值，字段值有一个实体标签没有出现在客户端所请求的实体标签列表中，那么，客户端 <b>必须</b> 通过复用这个实体标签所对应的已存储的响应来为这个客户生成一个 <code>200 (OK)</code> 响应，同时将刚才返回的那个 <code>304</code> 响应的元数据更新到这个 <code>200</code> 响应中去（<a href="#org84ebeaf">章节 4.3.4</a>）。
</p>

<blockquote>
<p>
If an <code>If-None-Match</code> header field is not present, a request containing an <code>If-Modified-Since</code> header field (<a href="RFC7232.html#ID-e71fa098-728a-46bf-b792-2388946ea0ee">Section 3.3</a> of [RFC7232]) indicates that the client wants to validate one or more of its own stored responses by modification date. A cache recipient <b>SHOULD</b> generate a <code>304 (Not Modified)</code> response (using the metadata of the selected stored response) if one of the following cases is true: 1) the selected stored response has a <code>Last-Modified</code> field-value that is earlier than or equal to the conditional timestamp; 2) no <code>Last-Modified</code> field is present in the selected stored response, but it has a <code>Date</code> field-value that is earlier than or equal to the conditional timestamp; or, 3) neither <code>Last-Modified</code> nor <code>Date</code> is present in the selected stored response, but the cache recorded it as having been received at a time earlier than or equal to the conditional timestamp.
</p>
</blockquote>

<p>
一个请求，如果没有出现 <code>If-None-Match</code> 头字段，而是包含有一个 <code>If-Modified-Since</code> 头字段（<a href="RFC7232.html#ID-e71fa098-728a-46bf-b792-2388946ea0ee">【RFC7232】章节 3.3</a>），则表明：客户端想通过<ruby>修改日期<rt>modification date</rt></ruby>来验证客户端所拥有的一个或多个已存储的响应。缓存接收端 <b>应当</b> 生成一个 <code>304 (Not Modified)</code> 响应（使用那个已选的已存储的响应的元数据），如果以下其中一种情况为真的话：
</p>

<ol class="org-ol">
<li>已选的已存储的响应有一个 <code>Last-Modified</code> 头字段，其值早于或等于条件式（即 <code>If-Modified-Since</code>）的时间戳。</li>
<li>已选的已存储的响应没有出现 <code>Last-Modified</code> 头字段，但它有一个 <code>Date</code> 头字段，其值早于或等于条件式的时间戳。</li>
<li>已选的已存储的响应既没有出现 <code>Last-Modified</code> 头字段，也没有出现 <code>Date</code> 头字段，但缓存记录到接收到这个响应的时间早于或等于条件式的时间戳。</li>
</ol>

<blockquote>
<p>
A cache that implements partial responses to range requests, as defined in [<a href="RFC7233.html">RFC7233</a>], also needs to evaluate a received <code>If-Range</code> header field (<a href="RFC7233.html#ID-2859ef1f-8309-4b7d-9e22-963391b5822a">Section 3.2</a> of [RFC7233]) with respect to its selected stored response.
</p>
</blockquote>

<p>
一个缓存，如果它还实现了对于范围请求的部分响应，正如【<a href="RFC7233.html">RFC7233</a>】所定义的，还需要在它的已选的已存储的响应方面，对所接收到的 <code>If-Range</code> 头字段（<a href="RFC7233.html#ID-2859ef1f-8309-4b7d-9e22-963391b5822a">【RFC7233】章节 3.2</a>）进行求值。
</p>
</div>
</div>

<div id="outline-container-orgdb9d4f2" class="outline-4">
<h4 id="orgdb9d4f2">4.3.3. 处理验证响应 / Handling a Validation Response</h4>
<div class="outline-text-4" id="text-orgdb9d4f2">
<blockquote>
<p>
Cache handling of a response to a conditional request is dependent upon its status code:
</p>

<ul class="org-ul">
<li>A <code>304 (Not Modified)</code> response status code indicates that the stored response can be updated and reused; see <a href="#org84ebeaf">Section 4.3.4</a>.</li>
<li>A full response (i.e., one with a payload body) indicates that none of the stored responses nominated in the conditional request is suitable. Instead, the cache <b>MUST</b> use the full response to satisfy the request and <b>MAY</b> replace the stored response(s).</li>
<li>However, if a cache receives a <code>5xx (Server Error)</code> response while attempting to validate a response, it can either forward this response to the requesting client, or act as if the server failed to respond. In the latter case, the cache <b>MAY</b> send a previously stored response (see <a href="#orga71285a">Section 4.2.4</a>).</li>
</ul>
</blockquote>

<p>
对于回应给条件请求的响应，缓存依据响应的状态码来进行处理：
</p>

<ul class="org-ul">
<li>一个 <code>304 (Not Modified)</code> 响应状态码表明：缓存可以更新及复用这个已缓存的响应，见<a href="#org84ebeaf">章节 4.3.4</a>。</li>
<li>一个<ruby>完全的响应<rt>full response</rt></ruby>（即，一个带有<ruby>有效载荷<rt>payload body</rt></ruby>的响应）表明：没有任何一个已存储的响应适用于回应这个条件请求。而是，缓存 <b>必须</b> 使用这个完全的响应来满足这个请求，并且 <b>可以</b> 将（可能是多个）已存储的响应替换为这个完全的响应。</li>
<li>然而，如果缓存在试图去验证响应的时候，接收到一个 <code>5xx (Server Error)</code> 响应，那么，它既可以转发这个响应给客户端，也可以将这种情况当作服务器<ruby>响应出错<rt>failed to respond</rt></ruby>来处理。对于后者，缓存 <b>可以</b> 发送一个之前已存储的响应（见<a href="#orga71285a">章节 4.2.4</a>）。</li>
</ul>
</div>
</div>

<div id="outline-container-org84ebeaf" class="outline-4">
<h4 id="org84ebeaf"><a id="ID-eb92f86f-35bf-4b7a-b1ae-579da32c29a5"></a>4.3.4. 依据验证结果使已存储的响应唤发新鲜 / Freshening Stored Responses upon Validation</h4>
<div class="outline-text-4" id="text-org84ebeaf">
<blockquote>
<p>
When a cache receives a <code>304 (Not Modified)</code> response and already has one or more stored <code>200 (OK)</code> responses for the same cache key, the cache needs to identify which of the stored responses are updated by this new response and then update the stored response(s) with the new information provided in the <code>304</code> response.
</p>
</blockquote>

<p>
当一个缓存接收到一个 <code>304 (Not Modified)</code> 响应，并且对于这个响应所对应的缓存 key，缓存已经有一个或多个已存储的 <code>200 (OK)</code> 响应，那么，这个缓存需要去标识出哪些已缓存的响应需要被这个新响应所更新，然后使用提供自 <code>304</code> 响应的新信息更新它们。
</p>

<blockquote>
<p>
The stored response to update is identified by using the first match (if any) of the following:
</p>

<ul class="org-ul">
<li>If the new response contains a strong validator (see Section 2.1 of [RFC7232]), then that strong validator identifies the selected representation for update. All of the stored responses with the same strong validator are selected. If none of the stored responses contain the same strong validator, then the cache <b>MUST NOT</b> use the new response to update any stored responses.</li>
<li>If the new response contains a weak validator and that validator corresponds to one of the cache's stored responses, then the most recent of those matching stored responses is selected for update.</li>
<li>If the new response does not include any form of validator (such as in the case where a client generates an <code>If-Modified-Since</code> request from a source other than the <code>Last-Modified</code> response header field), and there is only one stored response, and that stored response also lacks a validator, then that stored response is selected for update.</li>
</ul>
</blockquote>

<p>
通过使用下列第一个能够匹配上（如果能的话）的方式，来标识出哪些已存储的响应需要被更新：
</p>

<ul class="org-ul">
<li>如果新响应包含有一个<ruby>强验证器<rt>strong validator</rt></ruby>（【RFC7232】章节 2.1），那么，那个强验证器标识了用于更新的已选表示形式。带有同一个强验证器的所有已存储的响应都被选中。如果已缓存的响应没有一个包含同一个强验证器，那么，缓存 <b>禁止</b> 使用新响应去更新任何一个已存储的响应。</li>
<li>如果新响应包含有一个<ruby>弱验证器<rt>weak validator</rt></ruby>对应上缓存的已存储的响应中的某一个验证器，那么，这些匹配上的已存储的响应中时间最新近的那一个会被选中用于更新。</li>
<li>如果新响应并没有包含任何形式的验证器（比如一个客户端生成了一个 <code>If-Modified-Since</code> 请求，但生成来源并不是 <code>Last-Modified</code> 响应头字段这种情况），并且缓存只有一个已存储的响应，并且那个已存储的响应同样缺少验证器，那么，这个已存储的响应被选中用于更新。</li>
</ul>

<blockquote>
<p>
If a stored response is selected for update, the cache <b>MUST</b>:
</p>

<ul class="org-ul">
<li>delete any <code>Warning</code> header fields in the stored response with warn-code <code>1xx</code> (see <a href="#org203fe8a">Section 5.5</a>);</li>
<li>retain any <code>Warning</code> header fields in the stored response with warn-code <code>2xx</code>; and,</li>
<li>use other header fields provided in the <code>304 (Not Modified)</code> response to replace all instances of the corresponding header fields in the stored response.</li>
</ul>
</blockquote>

<p>
如果一个已存储的响应被选中用于更新，缓存 <b>必须</b>：
</p>

<ul class="org-ul">
<li>删除已存储的响应中的任何带有警告码为 <code>1xx</code> 的 <code>Warning</code> 头字段（见<a href="#org203fe8a">章节 5.5</a>）；</li>
<li>保留已存储的响应中的任何带有警告码为 <code>2xx</code> 的 <code>Warning</code> 头字段；并且：</li>
<li>使用 <code>304 (Not Modified)</code> 响应所提供的其他头字段，来替换所有在已存储的响应中对应的头字段。</li>
</ul>
</div>
</div>

<div id="outline-container-org62bfcfb" class="outline-4">
<h4 id="org62bfcfb">4.3.5. 经由 HEAD 请求使用响应唤发新鲜 / Freshening Responses via HEAD</h4>
<div class="outline-text-4" id="text-org62bfcfb">
<blockquote>
<p>
A response to the HEAD method is identical to what an equivalent request made with a GET would have been, except it lacks a body. This property of HEAD responses can be used to invalidate or update a cached GET response if the more efficient conditional GET request mechanism is not available (due to no validators being present in the stored response) or if transmission of the representation body is not desired even if it has changed.
</p>
</blockquote>

<p>
回应给 HEAD 方法的响应与回应给一个等价的 GET 方法的响应是相同的，除了它缺少一个消息体以外。HEAD 响应的这种性质能够用来失效或更新一个已缓存的 GET 响应，如果更高效的条件 GET 请求机制不可用的话（由于没有验证器出现在已存储的响应），或者如果不期望传输带有表示形式的消息体（即使它已经改变）。
</p>

<blockquote>
<p>
When a cache makes an inbound HEAD request for a given request target and receives a <code>200 (OK)</code> response, the cache <b>SHOULD</b> update or invalidate each of its stored GET responses that could have been selected for that request (see <a href="#org64a44b1">Section 4.1</a>).
</p>
</blockquote>

<p>
当一个缓存对一个给定的请求目标发起一个<ruby>入站<rt>inbound</rt></ruby> HEAD 请求，并接收到一个 <code>200 (OK)</code> 响应，那么，这个缓存 <b>应当</b> 更新或失效它所存储的每一个原本可以被那个请求选择的 GET 响应（见<a href="#org64a44b1">章节 4.1</a>）。
</p>

<blockquote>
<p>
For each of the stored responses that could have been selected, if the stored response and HEAD response have matching values for any received validator fields (<code>ETag</code> and <code>Last-Modified</code>) and, if the HEAD response has a <code>Content-Length</code> header field, the value of <code>Content-Length</code> matches that of the stored response, the cache <b>SHOULD</b> update the stored response as described below; otherwise, the cache <b>SHOULD</b> consider the stored response to be stale.
</p>
</blockquote>

<p>
对于每一个原本可以被选择的已存储的响应来说，如果已存储的响应与 HEAD 响应的任何接收到的<ruby>验证器头字段<rt>validator header fields</rt></ruby>（<code>ETag</code> 和 <code>Last-Modified</code>）的值都已经相互匹配上，并且，如果 HEAD 响应带有一个 <code>Content-Length</code> 头字段，其字段值与已存储的响应的 <code>Content-Length</code> 头字段的值相匹配，那么，缓存 <b>应当</b> 像上述那样更新那个已存储的响应；否则，缓存 <b>应当</b> 将那个已存储的响应视为<ruby>陈旧的<rt>stale</rt></ruby>。
</p>

<blockquote>
<p>
If a cache updates a stored response with the metadata provided in a HEAD response, the cache <b>MUST</b>:
</p>

<ul class="org-ul">
<li>delete any <code>Warning</code> header fields in the stored response with warn-code <code>1xx</code> (see <a href="#org203fe8a">Section 5.5</a>);</li>
<li>retain any <code>Warning</code> header fields in the stored response with warn-code <code>2xx</code>; and,</li>
<li>use other header fields provided in the HEAD response to replace all instances of the corresponding header fields in the stored response and append new header fields to the stored response's header section unless otherwise restricted by the <code>Cache-Control</code> header field.</li>
</ul>
</blockquote>

<p>
如果一个缓存使用 HEAD 响应所提供的元数据来更新一个已存储的响应的话，缓存 <b>必须</b>：
</p>

<ul class="org-ul">
<li>删除已存储的响应中的任何带有警告码为 <code>1xx</code> 的 <code>Warning</code> 头字段（见<a href="#org203fe8a">章节 5.5</a>）；</li>
<li>保留已存储的响应中的任何带有警告码为 <code>2xx</code> 的 <code>Warning</code> 头字段；并且：</li>
<li>使用 HEAD 响应所提供的其他头字段，来替换所有在已存储的响应中对应的头字段，并将新的头字段附加到已存储的响应的头部中去，除非 <code>Cache-Control</code> 头字段另有限制。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org104decc" class="outline-3">
<h3 id="org104decc"><a id="ID-f0828803-68c6-4dae-a418-6a6b4b57189e"></a>4.4. 失效 / Invalidation</h3>
<div class="outline-text-3" id="text-org104decc">
<blockquote>
<p>
Because unsafe request methods (<a href="RFC7231.html#ID-2f967e3d-8694-430b-ad06-e748fd39b281">Section 4.2.1</a> of [RFC7231]) such as PUT, POST or DELETE have the potential for changing state on the origin server, intervening caches can use them to keep their contents up to date.
</p>
</blockquote>

<p>
因为像 PUT、POST、DELETE 等这些不安全的请求方法（<a href="RFC7231.html#ID-2f967e3d-8694-430b-ad06-e748fd39b281">【RFC7231】章节 4.2.1</a>）可能会改变源服务器上的资源的状态，链路之间的缓存可以使用它们来保持它们的内容为最新。
</p>

<blockquote>
<p>
A cache <b>MUST</b> invalidate the effective Request URI (<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">Section 5.5</a> of [RFC7230]) as well as the URI(s) in the <code>Location</code> and <code>Content-Location</code> response header fields (if present) when a non-error status code is received in response to an unsafe request method.
</p>
</blockquote>

<p>
当响应中带有一个<ruby>非错误的状态码<rt>non-error status code</rt></ruby>，而这个响应是回应给一个不安全的请求方法的，那么，缓存 <b>必须</b> <ruby>失效<rt>invalidate</rt></ruby><ruby>实际请求 URI<rt>effective Request URI</rt></ruby>（<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">【RFC7230】章节 5.5</a>）以及在 <code>Location</code> 和 <code>Content-Location</code> 响应头字段（如果有出现的话）中的 URI。
</p>

<blockquote>
<p>
However, a cache <b>MUST NOT</b> invalidate a URI from a <code>Location</code> or <code>Content-Location</code> response header field if the <code>host</code> part of that URI differs from the <code>host</code> part in the effective request URI (<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">Section 5.5</a> of [RFC7230]). This helps prevent denial-of-service attacks.
</p>
</blockquote>

<p>
但是，如果 <code>Location</code> 或者 <code>Content-Location</code> 响应头字段中的 URI 的 <code>host</code> 部分不同于有效请求 URI（<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">【RFC7230】章节 5.5</a>）中的 <code>host</code> 部分的话，缓存 <b>禁止</b> 失效这种 URI。这样做有助于避免<ruby>拒绝服务攻击<rt>denial-of-service attacks</rt></ruby>。
</p>

<blockquote>
<p>
A cache <b>MUST</b> invalidate the effective request URI (<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">Section 5.5</a> of [RFC7230]) when it receives a non-error response to a request with a method whose safety is unknown.
</p>
</blockquote>

<p>
当缓存接收到一个<ruby>非错误的回应<rt>non-error response</rt></ruby>，而这个响应是回应给一个请求方法的安全性是未知的请求的，那么，缓存 <b>必须</b> 失效有效请求 URI（<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">【RFC7230】章节 5.5</a>）。
</p>

<blockquote>
<p>
Here, a "non-error response" is one with a <code>2xx (Successful)</code> or <code>3xx (Redirection)</code> status code. "Invalidate" means that the cache will either remove all stored responses related to the effective request URI or will mark these as "invalid" and in need of a mandatory validation before they can be sent in response to a subsequent request.
</p>
</blockquote>

<p>
所述“非错误的响应”，指的是带有状态码为 <code>2xx (Successful)</code> 或 <code>3xx (Redirection)</code> 的响应。所述“<ruby>失效<rt>invalidate</rt></ruby>”，意味着缓存将会这样做：要么移除该有效请求 URI 相关的所有已存储的响应，要么将这些已存储的响应标记为“<ruby>无效<rt>invalid</rt></ruby>”并且在它们可以用来响应给后续请求之前需要<ruby>强制的验证<rt>mandatory validation</rt></ruby>。
</p>

<blockquote>
<p>
Note that this does not guarantee that all appropriate responses are invalidated. For example, a state-changing request might invalidate responses in the caches it travels through, but relevant responses still might be stored in other caches that it has not.
</p>
</blockquote>

<p>
需要注意的是这样做并不保证所有合适的响应都会被失效。例如，一个会改变状态的请求可能会将它所途经的缓存中的响应置为失效，但存储在其他缓存中的相关响应仍然未被失效。
</p>
</div>
</div>
</div>

<div id="outline-container-org711b085" class="outline-2">
<h2 id="org711b085">5. 头字段定义 / Header Field Definitions</h2>
<div class="outline-text-2" id="text-org711b085">
<blockquote>
<p>
This section defines the syntax and semantics of HTTP/1.1 header fields related to caching.
</p>
</blockquote>

<p>
本章节定义了缓存相关的 HTTP/1.1 头字段的句法与语义。
</p>
</div>

<div id="outline-container-orgb943d27" class="outline-3">
<h3 id="orgb943d27"><a id="ID-0fda7a59-2592-493d-9ce1-01e72543c6c0"></a>5.1. Age</h3>
<div class="outline-text-3" id="text-orgb943d27">
<blockquote>
<p>
The "<code>Age</code>" header field conveys the sender's estimate of the amount of time since the response was generated or successfully validated at the origin server. <code>Age</code> values are calculated as specified in <a href="#org3fee265">Section 4.2.3</a>.
</p>
</blockquote>

<p>
<code>Age</code> 头字段运载了发送端的估算时长，该估算时长是从该响应被源服务器<ruby>生成<rt>generated</rt></ruby>或<ruby>成功验证<rt>successfully validated</rt></ruby>到现在所持续的时长。<a href="#org3fee265">章节 4.2.3</a> 指出了 <code>Age</code> 字段值的计算方法。
</p>

<div class="org-src-container">
<pre class="src src-text">Age = delta-seconds
</pre>
</div>

<blockquote>
<p>
The <code>Age</code> field-value is a non-negative integer, representing time in seconds (see <a href="#orgd2ac10d">Section 1.2.1</a>).
</p>
</blockquote>

<p>
<code>Age</code> 的字段值是一个非负整数，以秒为单位来表示时间（<a href="#orgd2ac10d">章节 1.2.1</a>）。
</p>

<blockquote>
<p>
The presence of an <code>Age</code> header field implies that the response was not generated or validated by the origin server for this request. However, lack of an <code>Age</code> header field does not imply the origin was contacted, since the response might have been received from an HTTP/1.0 cache that does not implement <code>Age</code>.
</p>
</blockquote>

<p>
<code>Age</code> 头字段的出现意味着这个响应并不是由源服务器生成的或验证的。但是，缺少 <code>Age</code> 头字段并不意味着缓存已与源服务器取得联系，因为这个响应也可能是接收自一个 HTTP/1.0 缓存，而 HTTP/1.0 缓存并没有实现 <code>Age</code>。
</p>
</div>
</div>

<div id="outline-container-org96b62f3" class="outline-3">
<h3 id="org96b62f3"><a id="ID-03c2dad4-a6d2-4d3c-b087-d08717bf09ec"></a>5.2. Cache-Control</h3>
<div class="outline-text-3" id="text-org96b62f3">
<blockquote>
<p>
The "<code>Cache-Control</code>" header field is used to specify directives for caches along the request/response chain. Such cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response.
</p>
</blockquote>

<p>
<code>Cache-Control</code> 头字段用于指定请求/响应链路中所使用的缓存指令。这些缓存指令是意向的，即请求中出现一个指令并不意味着响应中将会出现同一个指令。
</p>

<blockquote>
<p>
A cache <b>MUST</b> obey the requirements of the <code>Cache-Control</code> directives defined in this section. See <a href="#orgd8f8d17">Section 5.2.3</a> for information about how <code>Cache-Control</code> directives defined elsewhere are handled.
</p>
</blockquote>

<p>
缓存 <b>必须</b> 遵守本章节所定义的 <code>Cache-Control</code> 指令的要求。关于如何处理在别处（非本规范）定义的 <code>Cache-Control</code> 指令，见<a href="#orgd8f8d17">章节 5.2.3</a>。
</p>

<blockquote>
<p>
<b>Note:</b> Some HTTP/1.0 caches might not implement <code>Cache-Control</code>.
</p>
</blockquote>

<p>
<b>注意：</b> 某些 HTTP/1.0 缓存可能没有实现 <code>Cache-Control</code>。
</p>

<blockquote>
<p>
A proxy, whether or not it implements a cache, <b>MUST</b> pass cache directives through in forwarded messages, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to target a directive to a specific cache.
</p>
</blockquote>

<p>
一个代理，无论它是否有实现了缓存功能，<b>必须</b> 在转发消息的同时放行缓存指令的转发，无论这些指令对那个应用程序是否有意义，这是因为这些指令可能会应用于请求/响应链路中的所有接收端。发送一个指令以某一个具体的缓存为目标是不可能的。
</p>

<blockquote>
<p>
Cache directives are identified by a <code>token</code>, to be compared case-insensitively, and have an optional argument, that can use both <code>token</code> and <code>quoted-string</code> syntax. For the directives defined below that define arguments, recipients ought to accept both forms, even if one is documented to be preferred. For any directive not defined by this specification, a recipient <b>MUST</b> accept both forms.
</p>
</blockquote>

<p>
缓存指令由一个 <code>token</code> 所标识，不区分大小写，它可以带有一个可选的<ruby>实参<rt>argument</rt></ruby>，这个实参既可以使用 <code>token</code> 句法来表示，也可以使用 <code>quoted-string</code> 来表示。对于下文所定义的指令中有定义实参的，接收端应该能够同时接受这两种实参形式，即使其中一种形式是被注明为首选的。对于其他任何非本规范所定义的指令，接收端 <b>必须</b> 能够同时接受这两种实参形式。
</p>

<div class="org-src-container">
<pre class="src src-text">Cache-Control   = 1#cache-directive

cache-directive = token [ "=" ( token / quoted-string ) ]
</pre>
</div>

<blockquote>
<p>
For the cache directives defined below, no argument is defined (nor allowed) unless stated otherwise.
</p>
</blockquote>

<p>
对于下文所定义的指令中，除非另有说明，没有定义（也不允许有）实参。
</p>
</div>

<div id="outline-container-org8707cd3" class="outline-4">
<h4 id="org8707cd3"><a id="ID-a586b298-d3ba-44df-ab8f-69ad432b93a2"></a>5.2.1. 请求消息中的缓存控制指令 / Request Cache-Control Directives</h4>
<div class="outline-text-4" id="text-org8707cd3">
</div>

<div id="outline-container-orge31ad97" class="outline-5">
<h5 id="orge31ad97">5.2.1.1. max-age</h5>
<div class="outline-text-5" id="text-orge31ad97">
<blockquote>
<p>
Argument syntax:
</p>
</blockquote>

<p>
实参句法：
</p>

<div class="org-src-container">
<pre class="src src-text">delta-seconds (see Section 1.2.1)
</pre>
</div>

<blockquote>
<p>
The "<code>max-age</code>" request directive indicates that the client is unwilling to accept a response whose age is greater than the specified number of seconds. Unless the <code>max-stale</code> request directive is also present, the client is not willing to accept a stale response.
</p>
</blockquote>

<p>
<code>max-age</code> 请求指令表明，客户端不愿意去接受这一种响应：其年龄大于指令所指定的秒数值。除非也出现了 <code>max-stale</code> 请求指令，否则客户端不愿意接受一个<ruby>陈旧的响应<rt>stale response</rt></ruby>。
</p>

<blockquote>
<p>
译注：响应的<ruby>年龄<rt>age</rt></ruby>，见<a href="#org4e92c7f">章节 4.2.3</a>。
</p>
</blockquote>

<blockquote>
<p>
This directive uses the <code>token</code> form of the argument syntax: e.g., 'max-age=5' not 'max-age="5"'. A sender <b>SHOULD NOT</b> generate the <code>quoted-string</code> form.
</p>
</blockquote>

<p>
本指令的实参使用的是 <code>token</code> 形式的句法，比如：max-age=5，而不是 max-age="5"。发送端 <b>不应当</b> 将本指令生成为 <code>quoted-string</code> 的形式。
</p>
</div>
</div>

<div id="outline-container-org2366c46" class="outline-5">
<h5 id="org2366c46">5.2.1.2. max-stale</h5>
<div class="outline-text-5" id="text-org2366c46">
<blockquote>
<p>
Argument syntax:
</p>
</blockquote>

<p>
实参句法：
</p>

<div class="org-src-container">
<pre class="src src-text">delta-seconds (see Section 1.2.1)
</pre>
</div>

<blockquote>
<p>
The "<code>max-stale</code>" request directive indicates that the client is willing to accept a response that has exceeded its freshness lifetime. If <code>max-stale</code> is assigned a value, then the client is willing to accept a response that has exceeded its freshness lifetime by no more than the specified number of seconds. If no value is assigned to <code>max-stale</code>, then the client is willing to accept a stale response of any age.
</p>
</blockquote>

<p>
<code>max-stale</code> 请求指令表明，客户端愿意去接受这一种响应：已经超出了保鲜期的，即<ruby>陈旧的响应<rt>stale response</rt></ruby>。如果 <code>max-stale</code> 已被赋值，那么，客户端愿意去接受这一种响应：已经超出了保鲜期的，但超出的时长不大于本指令所指定的秒数值。如果 <code>max-stale</code> 还未被赋值，那么，客户端愿意去接受 <b>任意年龄</b> 的陈旧响应。
</p>

<blockquote>
<p>
译注：<ruby>陈旧的响应<rt>stale response</rt></ruby>，见<a href="#orga71285a">章节 4.2.4</a>。
</p>
</blockquote>

<blockquote>
<p>
This directive uses the <code>token</code> form of the argument syntax: e.g., 'max-stale=10' not 'max-stale="10"'. A sender <b>SHOULD NOT</b> generate the <code>quoted-string</code> form.
</p>
</blockquote>

<p>
本指令的实参使用的是 <code>token</code> 形式的句法，比如：max-stale=10，而不是 max-stale="10"。发送端 <b>不应当</b> 将本指令生成为 <code>quoted-string</code> 的形式。
</p>
</div>
</div>

<div id="outline-container-org993888e" class="outline-5">
<h5 id="org993888e">5.2.1.3. min-fresh</h5>
<div class="outline-text-5" id="text-org993888e">
<blockquote>
<p>
Argument syntax:
</p>
</blockquote>

<p>
实参句法：
</p>

<div class="org-src-container">
<pre class="src src-text">delta-seconds (see Section 1.2.1)
</pre>
</div>

<blockquote>
<p>
The "<code>min-fresh</code>" request directive indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.
</p>
</blockquote>

<p>
<code>min-fresh</code> 请求指令表明，客户端愿意去接受这一种响应：它的<ruby>保鲜期<rt>freshness lifetime</rt></ruby>不少于它的当前<ruby>年龄<rt>age</rt></ruby>加上本指令所指定的秒数时间。也就是说，客户端想要这样的一种响应：至少在指定的秒数值之内仍然是新鲜的。
</p>

<blockquote>
<p>
译注：<ruby>保鲜期<rt>freshness lifetime</rt></ruby>是一个秒数值，而不是一个绝对时间点，其定义见<a href="#org85ed084">章节 4.2</a>。
</p>
</blockquote>

<blockquote>
<p>
This directive uses the <code>token</code> form of the argument syntax: e.g., 'min-fresh=20' not 'min-fresh="20"'. A sender <b>SHOULD NOT</b> generate the <code>quoted-string</code> form.
</p>
</blockquote>

<p>
本指令的实参使用的是 <code>token</code> 形式的句法，比如：max-fresh=20，而不是 max-fresh="20"。发送端 <b>不应当</b> 将本指令生成为 <code>quoted-string</code> 的形式。
</p>
</div>
</div>

<div id="outline-container-orga64526f" class="outline-5">
<h5 id="orga64526f">5.2.1.4. no-cache</h5>
<div class="outline-text-5" id="text-orga64526f">
<blockquote>
<p>
The "<code>no-cache</code>" request directive indicates that a cache <b>MUST NOT</b> use a stored response to satisfy the request without successful validation on the origin server.
</p>
</blockquote>

<p>
<code>no-cache</code> 请求指令表明，缓存在没有经源服务器成功验证的情况下，<b>禁止</b> 使用一个已存储的响应来满足这个请求。
</p>
</div>
</div>

<div id="outline-container-orgeead007" class="outline-5">
<h5 id="orgeead007">5.2.1.5. no-store</h5>
<div class="outline-text-5" id="text-orgeead007">
<blockquote>
<p>
The "<code>no-store</code>" request directive indicates that a cache <b>MUST NOT</b> store any part of either this request or any response to it. This directive applies to both private and shared caches. "MUST NOT store" in this context means that the cache <b>MUST NOT</b> intentionally store the information in non-volatile storage, and <b>MUST</b> make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
</p>
</blockquote>

<p>
<code>no-store</code> 请求指令表明，缓存 <b>禁止</b> 存储这次请求及其对应的任何响应的任何部分。本指令既适用于<ruby>私有缓存<rt>private caches</rt></ruby>，也适用于<ruby>共享缓存<rt>shared caches</rt></ruby>。这里“禁止存储”的意思是缓存 <b>禁止</b> 在<ruby>非易失性存储器<rt>non-volatile storage</rt></ruby>中刻意存储信息，而且 <b>必须</b> 在转发这些信息以后，立刻、尽最大努力地去尝试从<ruby>易失性存储器<rt>volatile storage</rt></ruby>中移除它们。
</p>

<blockquote>
<p>
译注：私有缓存和共享缓存的描述，见<a href="#org3548e07">章节 1</a>。
</p>
</blockquote>

<blockquote>
<p>
译注：上述“信息”指的是这次请求以及对应的所有响应的任何部分。
</p>
</blockquote>

<blockquote>
<p>
This directive is <b>NOT</b> a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.
</p>
</blockquote>

<p>
本指令并不是一个可靠的或者充分的机制来保证私密性。特别是，恶意的或者折衷的缓存可能不<ruby>服从<rt>obey</rt></ruby>或者无法<ruby>识别<rt>recognize</rt></ruby>本指令，从而通信网络可能会遭到窃听。
</p>

<blockquote>
<p>
Note that if a request containing this directive is satisfied from a cache, the <code>no-store</code> request directive does not apply to the already stored response.
</p>
</blockquote>

<p>
需要注意的是，如果包含本指令的一个请求被一个缓存所满足，那么，<code>no-store</code> 请求指令并不适用于已经存储的响应。
</p>

<blockquote>
<p>
译注：<code>no-store</code> 是告诉缓存，不要存储本次请求及其回应给这个请求的响应，它是不会影响到早已存储在缓存中的响应的。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orge5b428d" class="outline-5">
<h5 id="orge5b428d">5.2.1.6. no-transform</h5>
<div class="outline-text-5" id="text-orge5b428d">
<blockquote>
<p>
The "<code>no-transform</code>" request directive indicates that an intermediary (whether or not it implements a cache) <b>MUST NOT</b> transform the payload, as defined in <a href="RFC7230.html#ID-b6641b58-3ac6-4fce-9c44-a3715ffdc8a0">Section 5.7.2</a> of [RFC7230].
</p>
</blockquote>

<p>
<code>no-transform</code> 请求指令表明，<ruby>中间人<rt>intermediary</rt></ruby>（无论是否有实现缓存） <b>禁止</b> 转换<ruby>有效载荷<rt>payload</rt></ruby>，正如<a href="RFC7230.html#ID-b6641b58-3ac6-4fce-9c44-a3715ffdc8a0">【RFC7230】章节 5.7.2</a> 所定义的。
</p>
</div>
</div>

<div id="outline-container-orgdb45a14" class="outline-5">
<h5 id="orgdb45a14">5.2.1.7. only-if-cached</h5>
<div class="outline-text-5" id="text-orgdb45a14">
<blockquote>
<p>
The "<code>only-if-cached</code>" request directive indicates that the client only wishes to obtain a stored response. If it receives this directive, a cache <b>SHOULD</b> either respond using a stored response that is consistent with the other constraints of the request, or respond with a <code>504 (Gateway Timeout)</code> status code. If a group of caches is being operated as a unified system with good internal connectivity, a member cache <b>MAY</b> forward such a request within that group of caches.
</p>
</blockquote>

<p>
<code>only-if-cached</code> 请求指令表明，客户端只希望获取一个已存储的响应。如果一个缓存接收到本指令，那么，它 <b>应当</b> 要么回应一个符合请求的其他约束的已存储的响应，要么回应一个 <code>504 (Gateway Timeout)</code> 状态码。如果一组缓存作为一个统一的系统来运作，它们之间具有良好的内部连通性，那么，组内的成员缓存 <b>可以</b> 在组内的缓存之间转发这种请求。
</p>
</div>
</div>
</div>

<div id="outline-container-org1336445" class="outline-4">
<h4 id="org1336445"><a id="ID-3b667767-3efc-4487-b0a4-5234780e5de2"></a>5.2.2. 响应消息中的缓存控制指令 / Response Cache-Control Directives</h4>
<div class="outline-text-4" id="text-org1336445">
</div>

<div id="outline-container-org19ae67e" class="outline-5">
<h5 id="org19ae67e">5.2.2.1. must-revalidate</h5>
<div class="outline-text-5" id="text-org19ae67e">
<blockquote>
<p>
The "<code>must-revalidate</code>" response directive indicates that once it has become stale, a cache <b>MUST NOT</b> use the response to satisfy subsequent requests without successful validation on the origin server.
</p>
</blockquote>

<p>
<code>must-revalidate</code> 响应指令表明：一旦这个响应消息变得陈旧，那么，缓存 <b>禁止</b> 在没有经过源服务器成功验证的情况下，使用这个响应来满足后续的请求。
</p>

<blockquote>
<p>
The <code>must-revalidate</code> directive is necessary to support reliable operation for certain protocol features. In all circumstances a cache <b>MUST</b> obey the <code>must-revalidate</code> directive; in particular, if a cache cannot reach the origin server for any reason, it <b>MUST</b> generate a <code>504 (Gateway Timeout)</code> response.
</p>
</blockquote>

<p>
为支持某些协议功能的可靠操作，<code>must-revalidat</code> 指令是很有必要的。在任何情况下，缓存 <b>必须</b> 服从 <code>must-revalidate</code> 指令。特别是如果一个缓存出于任何原因而不能访问源服务器的情况下，它 <b>必须</b> 生成一个 <code>504 (Gateway Timeout)</code> 响应。
</p>

<blockquote>
<p>
The <code>must-revalidate</code> directive ought to be used by servers if and only if failure to validate a request on the representation could result in incorrect operation, such as a silently unexecuted financial transaction.
</p>
</blockquote>

<p>
服务器应该使用 <code>must-revalidate</code> 指令，当且仅当在表示形式上验证一个请求失败时可能会导致不正确的操作，比如一个静默未执行的财务交易。
</p>
</div>
</div>

<div id="outline-container-org6dee7ff" class="outline-5">
<h5 id="org6dee7ff"><a id="ID-9c7307c8-5bc0-4812-ade1-d3080a39bf80"></a>5.2.2.2. no-cache</h5>
<div class="outline-text-5" id="text-org6dee7ff">
<blockquote>
<p>
Argument syntax:
</p>
</blockquote>

<p>
实参句法：
</p>

<div class="org-src-container">
<pre class="src src-text">#field-name
</pre>
</div>

<blockquote>
<p>
The "<code>no-cache</code>" response directive indicates that the response <b>MUST NOT</b> be used to satisfy a subsequent request without successful validation on the origin server. This allows an origin server to prevent a cache from using it to satisfy a request without contacting it, even by caches that have been configured to send stale responses.
</p>
</blockquote>

<p>
<code>no-cache</code> 响应指令表明：这个响应在没有经过源服务器的成功验证的情况下，<b>禁止</b> 被用来满足后续的请求。这样使得源服务器可以阻止缓存在不联系源服务器的情况下使用这个响应来满足某个请求，即使这些缓存已被配置为可以发送陈旧响应。
</p>

<blockquote>
<p>
If the <code>no-cache</code> response directive specifies one or more field-names, then a cache <b>MAY</b> use the response to satisfy a subsequent request, subject to any other restrictions on caching. However, any header fields in the response that have the field-name(s) listed <b>MUST NOT</b> be sent in the response to a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.
</p>
</blockquote>

<p>
如果 <code>no-cache</code> 响应指令指定了一个或多个<ruby>字段名<rt>field-names</rt></ruby>，那么，缓存 <b>可以</b> 使用这个响应来满足一个后续的请求，但会受到任何其他关于缓存方面的约束。然而，响应消息的 <code>no-cache</code> 指令中所列出的任何字段名 <b>禁止</b> 在没有经过源服务器成功验证的情况下，出现在回应给一个后续请求的响应中。这样使得源服务器可以阻止某些头字段在一个响应中被复用，但仍然允许缓存响应的剩余部分。
</p>

<blockquote>
<p>
The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.
</p>
</blockquote>

<p>
这里所说的<ruby>字段名<rt>field-names</rt></ruby>并不限于由本规范所定义的头字段集。字段名是不区分大小写的。
</p>

<blockquote>
<p>
This directive uses the <code>quoted-string</code> form of the argument syntax. A sender <b>SHOULD NOT</b> generate the <code>token</code> form (even if quoting appears not to be needed for single-entry lists).
</p>
</blockquote>

<p>
本指令的实参使用的是 <code>quoted-string</code> 形式的句法。发送端 <b>不应当</b> 将本指令生成为 <code>token</code> 的形式（即使在只有单一条目的列表中看起来并不需要引号）。
</p>

<blockquote>
<p>
<b>Note:</b> Although it has been back-ported to many implementations, some HTTP/1.0 caches will not recognize or obey this directive. Also, <code>no-cache</code> response directives with field-names are often handled by caches as if an unqualified <code>no-cache</code> directive was received; i.e., the special handling for the qualified form is not widely implemented.
</p>
</blockquote>

<p>
<b>注意：</b> 虽然本指令已被移植到许多实现上，但是，某些 HTTP/1.0 缓存将不会识别或者不会服从它。另外，带有字段名的 <code>no-cache</code> 响应指令常常被缓存当作<ruby>未经限定的<rt>unqualified</rt></ruby> <code>no-cache</code> 来处理，也就是说，对于限定形式的特殊处理并没有得到广泛的实现。
</p>
</div>
</div>

<div id="outline-container-org15305e1" class="outline-5">
<h5 id="org15305e1">5.2.2.3. no-store</h5>
<div class="outline-text-5" id="text-org15305e1">
<blockquote>
<p>
The "<code>no-store</code>" response directive indicates that a cache <b>MUST NOT</b> store any part of either the immediate request or response. This directive applies to both private and shared caches. "MUST NOT store" in this context means that the cache <b>MUST NOT</b> intentionally store the information in non-volatile storage, and <b>MUST</b> make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
</p>
</blockquote>

<p>
<code>no-store</code> 响应指令表明，缓存 <b>禁止</b> 存储这个响应及其引起这个响应的请求的任何部分。本指令既适用于私有缓存，也适用于共享缓存。这里“禁止存储”的意思是缓存 <b>禁止</b>
 在<ruby>非易失性存储器<rt>non-volatile storage</rt></ruby>中刻意存储信息，而且 <b>必须</b> 在转发这些信息以后，立刻、尽最大努力地去尝试从<ruby>易失性存储器<rt>volatile storage</rt></ruby>中移除它们。
</p>

<blockquote>
<p>
This directive is <b>NOT</b> a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.
</p>
</blockquote>

<p>
本指令并不是一个可靠的或者充分的机制来保证私密性。特别是，恶意的或者折衷的缓存可能不<ruby>服从<rt>obey</rt></ruby>或者无法<ruby>识别<rt>recognize</rt></ruby>本指令，从而通信网络可能会遭到窃听。
</p>
</div>
</div>

<div id="outline-container-org453b87f" class="outline-5">
<h5 id="org453b87f">5.2.2.4. no-transform</h5>
<div class="outline-text-5" id="text-org453b87f">
<blockquote>
<p>
The "<code>no-transform</code>" response directive indicates that an intermediary (regardless of whether it implements a cache) <b>MUST NOT</b> transform the payload, as defined in <a href="RFC7230.html#ID-b6641b58-3ac6-4fce-9c44-a3715ffdc8a0">Section 5.7.2</a> of [RFC7230].
</p>
</blockquote>

<p>
<code>no-transform</code> 响应指令表明，中间人（无论它是否有实现了缓存功能） <b>禁止</b> 转换有效载荷，其定义见<a href="RFC7230.html#ID-b6641b58-3ac6-4fce-9c44-a3715ffdc8a0">【RFC7230】章节 5.7.2</a>。
</p>
</div>
</div>

<div id="outline-container-org300811e" class="outline-5">
<h5 id="org300811e"><a id="ID-ad0dea37-836f-4c82-9241-3e6ce0d6fc51"></a>5.2.2.5. public</h5>
<div class="outline-text-5" id="text-org300811e">
<blockquote>
<p>
The "<code>public</code>" response directive indicates that any cache <b>MAY</b> store the response, even if the response would normally be non-cacheable or cacheable only within a private cache. (See <a href="#orga28b8b1">Section 3.2</a> for additional details related to the use of <code>public</code> in response to a request containing <code>Authorization</code>, and <a href="#orga05eb41">Section 3</a> for details of how <code>public</code> affects responses that would normally not be stored, due to their status codes not being defined as cacheable by default; see <a href="#org4c48fcc">Section 4.2.2</a>.)
</p>
</blockquote>

<p>
<code>public</code> 响应指令表明，任何缓存都 <b>可以</b> 存储这个响应，即使在正常情况下这个响应是不可缓存的或者仅可缓存于某个私有缓存中。（在回应给带有 <code>Authorization</code> 的请求的这种响应里使用 <code>public</code> 的更多详细信息，见<a href="#orga28b8b1">章节 3.2</a>；以及 <code>public</code> 如何影响正常情况下是不可存储的响应（由于它们的状态码没有定义为默认是可缓存的，见<a href="#org4c48fcc">章节 4.2.2</a>）的细节，见<a href="#orga05eb41">章节 3</a>；）
</p>
</div>
</div>

<div id="outline-container-orgc298f3c" class="outline-5">
<h5 id="orgc298f3c"><a id="ID-f740b5a2-4331-423d-b196-137d9b9e4d02"></a>5.2.2.6. private</h5>
<div class="outline-text-5" id="text-orgc298f3c">
<blockquote>
<p>
Argument syntax:
</p>
</blockquote>

<p>
实参句法：
</p>

<div class="org-src-container">
<pre class="src src-text">#field-name
</pre>
</div>

<blockquote>
<p>
The "<code>private</code>" response directive indicates that the response message is intended for a single user and <b>MUST NOT</b> be stored by a shared cache. A private cache <b>MAY</b> store the response and reuse it for later requests, even if the response would normally be non-cacheable.
</p>
</blockquote>

<p>
<code>private</code> 响应指令表明，这个响应消息是打算给某个单一用户使用的，并且 <b>禁止</b> 被共享缓存所存储。隐私缓存 <b>可以</b> 存储这个响应和在接下来的请求中复用这个响应，即使这个响应在正常情况下是不可缓存的。
</p>

<blockquote>
<p>
If the <code>private</code> response directive specifies one or more field-names, this requirement is limited to the field-values associated with the listed response header fields. That is, a shared cache <b>MUST NOT</b> store the specified field-names(s), whereas it <b>MAY</b> store the remainder of the response message.
</p>
</blockquote>

<p>
如果 <code>private</code> 响应指令指定了一个或多个字段名称，那么，这个要求仅限于所列出的响应头字段所关联的字段值。也就是说，共享缓存 <b>禁止</b> 存储 <code>private</code> 所指定的字段名，但它 <b>可以</b> 存储响应消息的剩余部分。
</p>

<blockquote>
<p>
The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.
</p>
</blockquote>

<p>
这里所说的<ruby>字段名<rt>field-names</rt></ruby>并不限于由本规范所定义的头字段集。字段名是不区分大小写的。
</p>

<blockquote>
<p>
This directive uses the <code>quoted-string</code> form of the argument syntax. A sender <b>SHOULD NOT</b> generate the <code>token</code> form (even if quoting appears not to be needed for single-entry lists).
</p>
</blockquote>

<p>
本指令的实参使用的是 <code>quoted-string</code> 形式的句法。发送端 <b>不应当</b> 将本指令生成为 <code>token</code> 的形式（即使在只有单一条目的列表中看起来并不需要引号）。
</p>

<blockquote>
<p>
<b>Note:</b> This usage of the word "private" only controls where the response can be stored; it cannot ensure the privacy of the message content. Also, <code>private</code> response directives with field-names are often handled by caches as if an unqualified <code>private</code> directive was received; i.e., the special handling for the qualified form is not widely implemented.
</p>
</blockquote>

<p>
<b>注意：</b> 这里所使用的术语“private”（私有）仅控制响应能够存储在哪个地方，它并不能保证消息内容的隐私性。另外，带有字段名称的 <code>private</code> 响应指令常常被缓存当作<ruby>未经限定的<rt>unqualified</rt></ruby> <code>private</code> 来处理，也就是说，对于限定形式的特殊处理并没有得到广泛的实现。
</p>
</div>
</div>

<div id="outline-container-orge47f656" class="outline-5">
<h5 id="orge47f656">5.2.2.7. proxy-revalidate</h5>
<div class="outline-text-5" id="text-orge47f656">
<blockquote>
<p>
The "<code>proxy-revalidate</code>" response directive has the same meaning as the <code>must-revalidate</code> response directive, except that it does not apply to private caches.
</p>
</blockquote>

<p>
<code>proxy-revalidate</code> 响应指令与 <code>must-revalidate</code> 响应指令具有同样的含义，除了它并不能适用于私有缓存以外。
</p>
</div>
</div>

<div id="outline-container-orgc309465" class="outline-5">
<h5 id="orgc309465"><a id="ID-eb09a1c7-0ad4-4c20-9e07-4792ee9ce0fb"></a>5.2.2.8. max-age</h5>
<div class="outline-text-5" id="text-orgc309465">
<blockquote>
<p>
Argument syntax:
</p>
</blockquote>

<p>
实参句法：
</p>

<div class="org-src-container">
<pre class="src src-text">delta-seconds (see Section 1.2.1)
</pre>
</div>

<blockquote>
<p>
The "<code>max-age</code>" response directive indicates that the response is to be considered stale after its age is greater than the specified number of seconds.
</p>
</blockquote>

<p>
<code>max-age</code> 响应指令表明，在响应的年龄大于这个指令所指定的秒数以后，这个响应就被视为是<ruby>陈旧的<rt>stale</rt></ruby>。
</p>

<blockquote>
<p>
This directive uses the <code>token</code> form of the argument syntax: e.g., 'max-age=5' not 'max-age="5"'. A sender <b>SHOULD NOT</b> generate the <code>quoted-string</code> form.
</p>
</blockquote>

<p>
本指令的实参使用的是 <code>token</code> 形式的句法，比如：max-age=5，而不是 max-age="5"。发送端 <b>不应当</b> 将本指令生成为 <code>quoted-string</code> 的形式。
</p>
</div>
</div>

<div id="outline-container-orgf601e80" class="outline-5">
<h5 id="orgf601e80"><a id="ID-5296bb87-1709-4827-bef2-69177bbe3544"></a>5.2.2.9. s-maxage</h5>
<div class="outline-text-5" id="text-orgf601e80">
<blockquote>
<p>
Argument syntax:
</p>
</blockquote>

<p>
实参句法：
</p>

<div class="org-src-container">
<pre class="src src-text">delta-seconds (see Section 1.2.1)
</pre>
</div>

<blockquote>
<p>
The "<code>s-maxage</code>" response directive indicates that, in shared caches, the maximum age specified by this directive overrides the maximum age specified by either the <code>max-age</code> directive or the <code>Expires</code> header field. The <code>s-maxage</code> directive also implies the semantics of the <code>proxy-revalidate</code> response directive.
</p>
</blockquote>

<p>
<code>s-maxage</code> 响应指令表明，在共享缓存中，由本指令所指定的最大年龄值覆盖了 <code>max-age</code> 指令或者 <code>Expires</code> 头字段所指定的最大年龄值。<code>s-maxage</code> 指令还意味着 <code>proxy-revalidate</code> 响应指令的语义。
</p>

<blockquote>
<p>
This directive uses the <code>token</code> form of the argument syntax: e.g., 's-maxage=10' not 's-maxage="10"'. A sender <b>SHOULD NOT</b> generate the <code>quoted-string</code> form.
</p>
</blockquote>

<p>
本指令的实参使用的是 <code>token</code> 形式的句法，比如：s-maxage=10，而不是 s-maxage="10"。发送端 <b>不应当</b> 将本指令生成为 <code>quoted-string</code> 的形式。
</p>
</div>
</div>
</div>

<div id="outline-container-orgd8f8d17" class="outline-4">
<h4 id="orgd8f8d17"><a id="ID-eb7efc79-3c1d-439b-b0b3-d901848ad800"></a>5.2.3. 缓存控制扩展 / Cache Control Extensions</h4>
<div class="outline-text-4" id="text-orgd8f8d17">
<blockquote>
<p>
The <code>Cache-Control</code> header field can be extended through the use of one or more cache-extension tokens, each with an optional value. A cache <b>MUST</b> ignore unrecognized cache directives.
</p>
</blockquote>

<p>
可以通过使用一个或多个<ruby>缓存扩展标记<rt>cache-extension tokens</rt></ruby>来扩展 <code>Cache-Control</code> 头字段，每个缓存扩展都有一个可选的值。缓存 <b>必须</b> 忽略不能识别的缓存指令。
</p>

<blockquote>
<p>
Informational extensions (those that do not require a change in cache behavior) can be added without changing the semantics of other directives.
</p>
</blockquote>

<p>
<ruby>信息性的扩展<rt>Informational extensions</rt></ruby>（指的是并不要求改变缓存行为的那种扩展）能够被添加而不会改变其他指令的语义。
</p>

<blockquote>
<p>
Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the old directive are supplied, such that applications that do not understand the new directive will default to the behavior specified by the old directive, and those that understand the new directive will recognize it as modifying the requirements associated with the old directive. In this way, extensions to the existing cache-control directives can be made without breaking deployed caches.
</p>
</blockquote>

<p>
<ruby>行为扩展<rt>Behavioral extensions</rt></ruby>是为在现有的缓存指令的基础上充当修饰符而设计的。既支持新指令，也支持旧指令，以便于不理解新指令的应用程序可以进行由旧指令所指定的默认行为，而理解新指令的应用程序则会将它认为是对旧指令的相关要求进行修改。这样就能够制定对现有的缓存控制指令的扩展而不会破坏已部署好的缓存。
</p>

<blockquote>
<p>
For example, consider a hypothetical new response directive called "community" that acts as a modifier to the <code>private</code> directive: in addition to private caches, any cache that is shared only by members of the named community is allowed to cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including
</p>
</blockquote>

<p>
例如，假设有一个新的响应指令称为 "community"，充当 <code>private</code> 指令的修饰符：除了私有缓存以外，任何仅共享于 <code>community</code> 指令所指定的名称的团体的缓存也允许缓存这个响应。源服务器希望让 UCI 团体可以使用在它们的共享缓存中的另外一个私有响应来满足请求，可以在响应中包含以下内容：
</p>

<pre class="example">
Cache-Control: private, community="UCI"
</pre>

<blockquote>
<p>
A cache that recognizes such a <code>community</code> cache-extension could broaden its behavior in accordance with that extension. A cache that does not recognize the <code>community</code> cache-extension would ignore it and adhere to the <code>private</code> directive.
</p>
</blockquote>

<p>
能够识别这个 <code>community</code> 缓存扩展的一类缓存，可以依照这个扩展的定义来拓宽它的行为。而不能识别这个 <code>community</code> 缓存扩展的一类缓存，可以忽略它而去遵守 <code>private</code> 指令。
</p>
</div>
</div>
</div>

<div id="outline-container-org304d2d1" class="outline-3">
<h3 id="org304d2d1"><a id="ID-18d3caca-869d-4ae8-8038-2c57cd36fef5"></a>5.3. Expires</h3>
<div class="outline-text-3" id="text-org304d2d1">
<blockquote>
<p>
The "<code>Expires</code>" header field gives the date/time after which the response is considered stale. See <a href="#org85ed084">Section 4.2</a> for further discussion of the freshness model.
</p>
</blockquote>

<p>
<code>Expires</code> 头字段所给出的日期/时间，意思是在这个时间点以后，响应会被视为是陈旧的。对于新鲜度模型的进一步讨论，见<a href="#org85ed084">章节 4.2</a>。
</p>

<blockquote>
<p>
The presence of an <code>Expires</code> field does not imply that the original resource will change or cease to exist at, before, or after that time.
</p>
</blockquote>

<p>
<code>Expires</code> 头字段的出现并不意味着在那个时间点、之前、或者之后，原始资源将会出现变化或者不复存在。
</p>

<blockquote>
<p>
The <code>Expires</code> value is an <code>HTTP-date</code> timestamp, as defined in <a href="RFC7231.html#ID-2091e4af-684f-4511-aaa1-8094dc7dcb21">Section 7.1.1.1</a> of [RFC7231].
</p>
</blockquote>

<p>
<code>Expires</code> 的值是一个 <code>HTTP-date</code> 时间戳，其定义见<a href="RFC7231.html#ID-2091e4af-684f-4511-aaa1-8094dc7dcb21">【RFC7231】章节 7.1.1.1</a>。
</p>

<div class="org-src-container">
<pre class="src src-text">Expires = HTTP-date
</pre>
</div>

<blockquote>
<p>
For example
</p>
</blockquote>

<p>
例如：
</p>

<pre class="example">
Expires: Thu, 01 Dec 1994 16:00:00 GMT
</pre>

<blockquote>
<p>
A cache recipient <b>MUST</b> interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
</p>
</blockquote>

<p>
缓存接收端 <b>必须</b> 解释无效的日期格式，特别是值为 "0"，代替过去的时间（也就是说，已经过期）。
</p>

<blockquote>
<p>
If a response includes a <code>Cache-Control</code> field with the <code>max-age</code> directive (<a href="#orgc309465">Section 5.2.2.8</a>), a recipient <b>MUST</b> ignore the <code>Expires</code> field. Likewise, if a response includes the <code>s-maxage</code> directive (<a href="#orgf601e80">Section 5.2.2.9</a>), a shared cache recipient <b>MUST</b> ignore the <code>Expires</code> field. In both these cases, the value in <code>Expires</code> is only intended for recipients that have not yet implemented the <code>Cache-Control</code> field.
</p>
</blockquote>

<p>
如果响应包含有一个 <code>Cache-Control</code> 字段，这个字段带有一个 <code>max-age</code> 指令（<a href="#orgc309465">章节 5.2.2.8</a>），那么，接收端 <b>必须</b> 忽略 <code>Expires</code> 字段。同样，如果响应包含有一个 <code>s-maxage</code> 指令（<a href="#orgf601e80">章节 5.2.2.9</a>），那么，共享缓存接收端 <b>必须</b> 忽略 <code>Expires</code> 字段。在上述两种情况中，<code>Expires</code> 里的值是仅为还未实现 <code>Cache-Control</code> 字段的那些接收端而设的。
</p>

<blockquote>
<p>
An origin server without a clock <b>MUST NOT</b> generate an <code>Expires</code> field unless its value represents a fixed time in the past (always expired) or its value has been associated with the resource by a system or user with a reliable clock.
</p>
</blockquote>

<p>
不具有时钟功能的源服务器 <b>禁止</b> 生成一个 <code>Expires</code> 字段，除非它的值代表着一个过去的固定时间（总是过期的）或者它的值是由某些具有可靠时钟功能的其他系统或用户关联到资源上的。
</p>

<blockquote>
<p>
Historically, HTTP required the <code>Expires</code> field-value to be no more than a year in the future. While longer freshness lifetimes are no longer prohibited, extremely large values have been demonstrated to cause problems (e.g., clock overflows due to use of 32-bit integers for time values), and many caches will evict a response far sooner than that.
</p>
</blockquote>

<p>
历史上，HTTP 要求 <code>Expires</code> 的字段值不能超过未来一年的时间。虽然现在已经不再禁止更长的保鲜期，但极端大的值已被证明会引发问题（比如，由于使用了 32 位整数作为时间值而导致的时钟溢出），而且许多缓存会将远早于响应的过期时间的那些响应逐出缓存。
</p>
</div>
</div>

<div id="outline-container-orga139761" class="outline-3">
<h3 id="orga139761"><a id="ID-8414ec2d-e5b5-4f9c-8160-c354c12b7504"></a>5.4. Pragma</h3>
<div class="outline-text-3" id="text-orga139761">
<blockquote>
<p>
The "<code>Pragma</code>" header field allows backwards compatibility with HTTP/1.0 caches, so that clients can specify a "no-cache" request that they will understand (as <code>Cache-Control</code> was not defined until HTTP/1.1). When the <code>Cache-Control</code> header field is also present and understood in a request, <code>Pragma</code> is ignored.
</p>
</blockquote>

<p>
<code>Pragma</code> 头字段使得可以与 HTTP/1.0 的缓存保持向后兼容，以便客户端能够指定一个它们能够理解的 "no-cache" 请求（因为直到 HTTP/1.1 <code>Cache-Control</code> 才被定义出来）。当请求中还出现了 <code>Cache-Control</code> 头字段且被接收端所理解，那么，<code>Pragma</code> 会被忽略。
</p>


<blockquote>
<p>
In HTTP/1.0, <code>Pragma</code> was defined as an extensible field for implementation-specified directives for recipients. This specification deprecates such extensions to improve interoperability.
</p>
</blockquote>

<p>
在 HTTP/1.0 中，<code>Pragma</code> 被定义为是一个可扩展的字段，它的含义依据接收端实现所指定。为提升互操作性，本规范废弃了这种扩展。
</p>

<blockquote>
<p>
译注：也就是说，<code>Pragma</code> 是一个没有确定语义的字段，在不同的实现中可能有所不同。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Pragma           = 1#pragma-directive
pragma-directive = "no-cache" / extension-pragma
extension-pragma = token [ "=" ( token / quoted-string ) ]
</pre>
</div>

<blockquote>
<p>
When the <code>Cache-Control</code> header field is not present in a request, caches <b>MUST</b> consider the <code>no-cache</code> request pragma-directive as having the same effect as if "Cache-Control: no-cache" were present (see <a href="#org8707cd3">Section 5.2.1</a>).
</p>
</blockquote>

<p>
当请求中没有出现 <code>Cache-Control</code> 头字段，那么，缓存 <b>必须</b> 将 <code>Pragma</code> 的 <code>no-cache</code> 指令的效果视同为与 "Cache-Control: no-cache" 一致（见<a href="#org8707cd3">章节 5.2.1</a>）。
</p>

<blockquote>
<p>
When sending a <code>no-cache</code> request, a client ought to include both the pragma and cache-control directives, unless <code>Cache-Control: no-cache</code> is purposefully omitted to target other <code>Cache-Control</code> response directives at HTTP/1.1 caches. For example:
</p>
</blockquote>

<p>
当发送一个 <code>no-cache</code> 请求，客户端应该既包含 <code>Pragma</code> 也包含 <code>Cache-Control</code> 指令，除非有意忽略 <code>Cache-Control: no-cache</code> 而对 HTTP/1.1 缓存使用其他 <code>Cache-Control</code> 响应指令。例如：
</p>

<pre class="example">
GET / HTTP/1.1
Host: www.example.com
Cache-Control: max-age=30
Pragma: no-cache
</pre>

<blockquote>
<p>
will constrain HTTP/1.1 caches to serve a response no older than 30 seconds, while precluding implementations that do not understand <code>Cache-Control</code> from serving a cached response.
</p>
</blockquote>

<p>
上面例子将会迫使 HTTP/1.1 缓存去供应一个年龄不超过 30 秒的响应，而阻止并不理解 <code>Cache-Control</code> 的实现去供应一个已缓存的响应。
</p>

<blockquote>
<p>
<b>Note:</b> Because the meaning of "Pragma: no-cache" in responses is not specified, it does not provide a reliable replacement for "Cache-Control: no-cache" in them.
</p>
</blockquote>

<p>
<b>注意：</b> 因为响应中 "Pragma: no-cache" 的含义并不是明确的，因此，它并不能可靠地替代 "Cache-Control: no-cache"。
</p>
</div>
</div>

<div id="outline-container-org203fe8a" class="outline-3">
<h3 id="org203fe8a"><a id="ID-84f5867e-4a3e-45fa-b085-dd23e8598a6b"></a>5.5. Warning</h3>
<div class="outline-text-3" id="text-org203fe8a">
<blockquote>
<p>
The "Warning" header field is used to carry additional information about the status or transformation of a message that might not be reflected in the status code. This information is typically used to warn about possible incorrectness introduced by caching operations or transformations applied to the payload of the message.
</p>
</blockquote>

<blockquote>
<p>
Warnings can be used for other purposes, both cache-related and otherwise. The use of a warning, rather than an error status code, distinguishes these responses from true failures.
</p>
</blockquote>

<blockquote>
<p>
Warning header fields can in general be applied to any message, however some warn-codes are specific to caches and can only be applied to response messages.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Warning       = 1#warning-value

warning-value = warn-code SP warn-agent SP warn-text
                                      [ SP warn-date ]

warn-code  = 3DIGIT
warn-agent = ( uri-host [ ":" port ] ) / pseudonym
                ; the name or pseudonym of the server adding
                ; the Warning header field, for use in debugging
                ; a single "-" is recommended when agent unknown
warn-text  = quoted-string
warn-date  = DQUOTE HTTP-date DQUOTE
</pre>
</div>

<blockquote>
<p>
Multiple warnings can be generated in a response (either by the origin server or by a cache), including multiple warnings with the same warn-code number that only differ in warn-text.
</p>
</blockquote>

<blockquote>
<p>
A user agent that receives one or more Warning header fields SHOULD inform the user of as many of them as possible, in the order that they appear in the response. Senders that generate multiple Warning header fields are encouraged to order them with this user agent behavior in mind. A sender that generates new Warning header fields MUST append them after any existing Warning header fields.
</p>
</blockquote>

<blockquote>
<p>
Warnings are assigned three digit warn-codes. The first digit indicates whether the Warning is required to be deleted from a stored response after validation:
</p>

<ul class="org-ul">
<li>1xx warn-codes describe the freshness or validation status of the response, and so they MUST be deleted by a cache after validation. They can only be generated by a cache when validating a cached entry, and MUST NOT be generated in any other situation.</li>
<li>2xx warn-codes describe some aspect of the representation that is not rectified by a validation (for example, a lossy compression of the representation) and they MUST NOT be deleted by a cache after validation, unless a full response is sent, in which case they MUST be.</li>
</ul>
</blockquote>

<blockquote>
<p>
If a sender generates one or more 1xx warn-codes in a message to be sent to a recipient known to implement only HTTP/1.0, the sender MUST include in each corresponding warning-value a warn-date that matches the Date header field in the message. For example:
</p>
</blockquote>

<pre class="example">
HTTP/1.1 200 OK
Date: Sat, 25 Aug 2012 23:34:45 GMT
Warning: 112 - "network down" "Sat, 25 Aug 2012 23:34:45 GMT"

</pre>

<blockquote>
<p>
Warnings have accompanying warn-text that describes the error, e.g., for logging. It is advisory only, and its content does not affect interpretation of the warn-code.
</p>
</blockquote>

<blockquote>
<p>
If a recipient that uses, evaluates, or displays Warning header fields receives a warn-date that is different from the Date value in the same message, the recipient MUST exclude the warning-value containing that warn-date before storing, forwarding, or using the message. This allows recipients to exclude warning-values that were improperly retained after a cache validation. If all of the warning-values are excluded, the recipient MUST exclude the Warning header field as well.
</p>
</blockquote>

<blockquote>
<p>
The following warn-codes are defined by this specification, each with a recommended warn-text in English, and a description of its meaning. The procedure for defining additional warn codes is described in Section 7.2.1.
</p>
</blockquote>
</div>

<div id="outline-container-orgb2503cc" class="outline-4">
<h4 id="orgb2503cc"><a id="ID-de825a8a-6078-407b-b9f5-04547f6aa999"></a>5.5.1. Warning: 110 - "Response is Stale"</h4>
<div class="outline-text-4" id="text-orgb2503cc">
<blockquote>
<p>
A cache SHOULD generate this whenever the sent response is stale.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org26c6391" class="outline-4">
<h4 id="org26c6391">5.5.2. Warning: 111 - "Revalidation Failed"</h4>
<div class="outline-text-4" id="text-org26c6391">
<blockquote>
<p>
A cache SHOULD generate this when sending a stale response because an attempt to validate the response failed, due to an inability to reach the server.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org0637a23" class="outline-4">
<h4 id="org0637a23"><a id="ID-92abeb74-8480-43e6-9313-a585f36847de"></a>5.5.3. Warning: 112 - "Disconnected Operation"</h4>
<div class="outline-text-4" id="text-org0637a23">
<blockquote>
<p>
A cache SHOULD generate this if it is intentionally disconnected from the rest of the network for a period of time.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org61c78c6" class="outline-4">
<h4 id="org61c78c6"><a id="ID-cc9f6df6-f45c-43c5-bd4f-d7fc929df890"></a>5.5.4. Warning: 113 - "Heuristic Expiration"</h4>
<div class="outline-text-4" id="text-org61c78c6">
<blockquote>
<p>
A cache SHOULD generate this if it heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org2498663" class="outline-4">
<h4 id="org2498663">5.5.5. Warning: 199 - "Miscellaneous Warning"</h4>
<div class="outline-text-4" id="text-org2498663">
<blockquote>
<p>
The warning text can include arbitrary information to be presented to a human user or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org3ffd641" class="outline-4">
<h4 id="org3ffd641">5.5.6. Warning: 214 - "Transformation Applied"</h4>
<div class="outline-text-4" id="text-org3ffd641">
<blockquote>
<p>
This Warning code MUST be added by a proxy if it applies any transformation to the representation, such as changing the content-coding, media-type, or modifying the representation data, unless this Warning code already appears in the response.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgbf8e92c" class="outline-4">
<h4 id="orgbf8e92c">5.5.7. Warning: 299 - "Miscellaneous Persistent Warning"</h4>
<div class="outline-text-4" id="text-orgbf8e92c">
<blockquote>
<p>
The warning text can include arbitrary information to be presented to a human user or logged. A system receiving this warning MUST NOT take any automated action.
</p>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-orgace9974" class="outline-2">
<h2 id="orgace9974"><a id="ID-0d1aabac-3fc4-409f-b30a-fbc82c359bc9"></a>6. 历史列表 / History Lists</h2>
<div class="outline-text-2" id="text-orgace9974">
<blockquote>
<p>
User agents often have history mechanisms, such as "Back" buttons and history lists, that can be used to redisplay a representation retrieved earlier in a session.
</p>
</blockquote>

<blockquote>
<p>
The freshness model (Section 4.2) does not necessarily apply to history mechanisms. That is, a history mechanism can display a previous representation even if it has expired.
</p>
</blockquote>

<blockquote>
<p>
This does not prohibit the history mechanism from telling the user that a view might be stale or from honoring cache directives (e.g., Cache-Control: no-store).
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgf20038c" class="outline-2">
<h2 id="orgf20038c">7. IANA 注意事项 / IANA Considerations</h2>
<div class="outline-text-2" id="text-orgf20038c">
</div>
<div id="outline-container-orgb841771" class="outline-3">
<h3 id="orgb841771">7.1. 缓存指令登记表 / Cache Directive Registry</h3>
<div class="outline-text-3" id="text-orgb841771">
<blockquote>
<p>
The "Hypertext Transfer Protocol (HTTP) Cache Directive Registry" defines the namespace for the cache directives. It has been created and is now maintained at <a href="http://www.iana.org/assignments/http-cache-directives">http://www.iana.org/assignments/http-cache-directives</a>.
</p>
</blockquote>
</div>

<div id="outline-container-org785241a" class="outline-4">
<h4 id="org785241a">7.1.1. 手续 / Procedure</h4>
<div class="outline-text-4" id="text-org785241a">
<blockquote>
<p>
A registration MUST include the following fields:
</p>

<ul class="org-ul">
<li>Cache Directive Name</li>
<li>Pointer to specification text</li>
<li>Values to be added to this namespace require IETF Review (see [RFC5226], Section 4.1).</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-org0611a08" class="outline-4">
<h4 id="org0611a08">7.1.2. 新的缓存控制指令的注意事项 / Considerations for New Cache Control Directives</h4>
<div class="outline-text-4" id="text-org0611a08">
<blockquote>
<p>
New extension directives ought to consider defining:
</p>

<ul class="org-ul">
<li>What it means for a directive to be specified multiple times,</li>
<li>When the directive does not take an argument, what it means when an argument is present,</li>
<li>When the directive requires an argument, what it means when it is missing,</li>
<li>Whether the directive is specific to requests, responses, or able to be used in either.</li>
</ul>
</blockquote>

<blockquote>
<p>
See also Section 5.2.3.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgc2896c5" class="outline-4">
<h4 id="orgc2896c5">7.1.3. 登记 / Registrations</h4>
<div class="outline-text-4" id="text-orgc2896c5">
<blockquote>
<p>
The registry has been populated with the registrations below:
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Cache Directive</th>
<th scope="col" class="org-left">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">max-age</td>
<td class="org-left">Section 5.2.1.1, Section 5.2.2.8</td>
</tr>

<tr>
<td class="org-left">max-stale</td>
<td class="org-left">Section 5.2.1.2</td>
</tr>

<tr>
<td class="org-left">min-fresh</td>
<td class="org-left">Section 5.2.1.3</td>
</tr>

<tr>
<td class="org-left">must-revalidate</td>
<td class="org-left">Section 5.2.2.1</td>
</tr>

<tr>
<td class="org-left">no-cache</td>
<td class="org-left">Section 5.2.1.4, Section 5.2.2.2</td>
</tr>

<tr>
<td class="org-left">no-store</td>
<td class="org-left">Section 5.2.1.5, Section 5.2.2.3</td>
</tr>

<tr>
<td class="org-left">no-transform</td>
<td class="org-left">Section 5.2.1.6, Section 5.2.2.4</td>
</tr>

<tr>
<td class="org-left">only-if-cached</td>
<td class="org-left">Section 5.2.1.7</td>
</tr>

<tr>
<td class="org-left">private</td>
<td class="org-left">Section 5.2.2.6</td>
</tr>

<tr>
<td class="org-left">proxy-revalidate</td>
<td class="org-left">Section 5.2.2.7</td>
</tr>

<tr>
<td class="org-left">public</td>
<td class="org-left">Section 5.2.2.5</td>
</tr>

<tr>
<td class="org-left">s-maxage</td>
<td class="org-left">Section 5.2.2.9</td>
</tr>

<tr>
<td class="org-left">stale-if-error</td>
<td class="org-left">[RFC5861], Section 4</td>
</tr>

<tr>
<td class="org-left">stale-while-revalidate</td>
<td class="org-left">[RFC5861], Section 3</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgf57606b" class="outline-3">
<h3 id="orgf57606b">7.2. 警告码登记表 / Warn Code Registry</h3>
<div class="outline-text-3" id="text-orgf57606b">
<blockquote>
<p>
The "Hypertext Transfer Protocol (HTTP) Warn Codes" registry defines the namespace for warn codes. It has been created and is now maintained at <a href="http://www.iana.org/assignments/http-warn-codes">http://www.iana.org/assignments/http-warn-codes</a>.
</p>
</blockquote>
</div>

<div id="outline-container-org37163f9" class="outline-4">
<h4 id="org37163f9">7.2.1. 手续 / Procedure</h4>
<div class="outline-text-4" id="text-org37163f9">
<blockquote>
<p>
A registration MUST include the following fields:
</p>

<ul class="org-ul">
<li>Warn Code (3 digits)</li>
<li>Short Description</li>
<li>Pointer to specification text</li>
</ul>
</blockquote>

<blockquote>
<p>
Values to be added to this namespace require IETF Review (see [RFC5226], Section 4.1).
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org614b44a" class="outline-4">
<h4 id="org614b44a">7.2.2. 登记 / Registrations</h4>
<div class="outline-text-4" id="text-org614b44a">
<blockquote>
<p>
The registry has been populated with the registrations below:
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Warn Code</th>
<th scope="col" class="org-left">Short Description</th>
<th scope="col" class="org-left">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">110</td>
<td class="org-left">Response is Stale</td>
<td class="org-left">Section 5.5.1</td>
</tr>

<tr>
<td class="org-right">111</td>
<td class="org-left">Revalidation Failed</td>
<td class="org-left">Section 5.5.2</td>
</tr>

<tr>
<td class="org-right">112</td>
<td class="org-left">Disconnected Operation</td>
<td class="org-left">Section 5.5.3</td>
</tr>

<tr>
<td class="org-right">113</td>
<td class="org-left">Heuristic Expiration</td>
<td class="org-left">Section 5.5.4</td>
</tr>

<tr>
<td class="org-right">199</td>
<td class="org-left">Miscellaneous Warning</td>
<td class="org-left">Section 5.5.5</td>
</tr>

<tr>
<td class="org-right">214</td>
<td class="org-left">Transformation Applied</td>
<td class="org-left">Section 5.5.6</td>
</tr>

<tr>
<td class="org-right">299</td>
<td class="org-left">Miscellaneous Persistent Warning</td>
<td class="org-left">Section 5.5.7</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org857923c" class="outline-3">
<h3 id="org857923c">7.3. 头字段登记 / Header Field Registration</h3>
<div class="outline-text-3" id="text-org857923c">
<blockquote>
<p>
HTTP header fields are registered within the "Message Headers" registry maintained at <a href="http://www.iana.org/assignments/message-headers/">http://www.iana.org/assignments/message-headers/</a>.
</p>
</blockquote>

<blockquote>
<p>
This document defines the following HTTP header fields, so the "Permanent Message Header Field Names" registry has been updated accordingly (see [BCP90]).
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Protocol</th>
<th scope="col" class="org-left">Status</th>
<th scope="col" class="org-left">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Age</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left">Section 5.1</td>
</tr>

<tr>
<td class="org-left">Cache-Control</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left">Section 5.2</td>
</tr>

<tr>
<td class="org-left">Expires</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left">Section 5.3</td>
</tr>

<tr>
<td class="org-left">Pragma</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left">Section 5.4</td>
</tr>

<tr>
<td class="org-left">Warning</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left">Section 5.5</td>
</tr>
</tbody>
</table>

<blockquote>
<p>
The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgf9e4b61" class="outline-2">
<h2 id="orgf9e4b61"><a id="ID-258f834a-496c-4173-b6bd-dda94f1d74fe"></a>8. 安全注意事项 / Security Considerations</h2>
<div class="outline-text-2" id="text-orgf9e4b61">
<blockquote>
<p>
This section is meant to inform developers, information providers, and users of known security concerns specific to HTTP caching. More general security considerations are addressed in HTTP messaging [RFC7230] and semantics [RFC7231].
</p>
</blockquote>

<blockquote>
<p>
Caches expose additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network. Therefore, cache contents need to be protected as sensitive information.
</p>
</blockquote>

<blockquote>
<p>
In particular, various attacks might be amplified by being stored in a shared cache; such "cache poisoning" attacks use the cache to distribute a malicious payload to many clients, and are especially effective when an attacker can use implementation flaws, elevated privileges, or other techniques to insert such a response into a cache. One common attack vector for cache poisoning is to exploit differences in message parsing on proxies and in user agents; see Section 3.3.3 of [RFC7230] for the relevant requirements.
</p>
</blockquote>

<blockquote>
<p>
Likewise, implementation flaws (as well as misunderstanding of cache operation) might lead to caching of sensitive information (e.g., authentication credentials) that is thought to be private, exposing it to unauthorized parties.
</p>
</blockquote>

<blockquote>
<p>
Furthermore, the very use of a cache can bring about privacy concerns. For example, if two users share a cache, and the first one browses to a site, the second may be able to detect that the other has been to that site, because the resources from it load more quickly, thanks to the cache.
</p>
</blockquote>

<blockquote>
<p>
Note that the Set-Cookie response header field [RFC6265] does not inhibit caching; a cacheable response with a Set-Cookie header field can be (and often is) used to satisfy subsequent requests to caches. Servers who wish to control caching of these responses are encouraged to emit appropriate Cache-Control response header fields.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org9f32532" class="outline-2">
<h2 id="org9f32532">9. 鸣谢 / Acknowledgments</h2>
<div class="outline-text-2" id="text-org9f32532">
<blockquote>
<p>
See Section 10 of [RFC7230].
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org2dbfe2e" class="outline-2">
<h2 id="org2dbfe2e">10. 参考资料 / References</h2>
<div class="outline-text-2" id="text-org2dbfe2e">
</div>
<div id="outline-container-org13349db" class="outline-3">
<h3 id="org13349db">10.1. 规范性参考资料 / Normative References</h3>
<div class="outline-text-3" id="text-org13349db">
<dl class="org-dl">
<dt>[RFC2119]</dt><dd>Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, March 1997.</dd>
<dt>[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, RFC 5234, January 2008.</dd>
<dt>[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, RFC 7230, June 2014.</dd>
<dt>[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”, RFC 7231, June 2014.</dd>
<dt>[RFC7232]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests”, RFC 7232, June 2014.</dd>
<dt>[RFC7233]</dt><dd>Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Range Requests”, RFC 7233, June 2014.</dd>
<dt>[RFC7235]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Authentication”, RFC 7235, June 2014.</dd>
</dl>
</div>
</div>

<div id="outline-container-org8fdaaa1" class="outline-3">
<h3 id="org8fdaaa1">10.2. 信息性参考资料 / Informative References</h3>
<div class="outline-text-3" id="text-org8fdaaa1">
<dl class="org-dl">
<dt>[BCP90]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, “Registration Procedures for Message Header Fields”, BCP 90, RFC 3864, September 2004.</dd>
<dt>[RFC2616]</dt><dd>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol &#x2013; HTTP/1.1”, RFC 2616, June 1999.</dd>
<dt>[RFC5226]</dt><dd>Narten, T. and H. Alvestrand, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, RFC 5226, May 2008.</dd>
<dt>[RFC5861]</dt><dd>Nottingham, M., “HTTP Cache-Control Extensions for Stale Content”, RFC 5861, April 2010.</dd>
<dt>[RFC5905]</dt><dd>Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, “Network Time Protocol Version 4: Protocol and Algorithms Specification”, RFC 5905, June 2010.</dd>
<dt>[RFC6265]</dt><dd>Barth, A., “HTTP State Management Mechanism”, RFC 6265, April 2011.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orga6bc8f3" class="outline-2">
<h2 id="orga6bc8f3">附录 A：相对 RFC 2616 的变化 / Appendix A. Changes from RFC 2616</h2>
<div class="outline-text-2" id="text-orga6bc8f3">
<blockquote>
<p>
The specification has been substantially rewritten for clarity.
</p>
</blockquote>

<blockquote>
<p>
The conditions under which an authenticated response can be cached have been clarified. (Section 3.2)
</p>
</blockquote>

<blockquote>
<p>
New status codes can now define that caches are allowed to use heuristic freshness with them. Caches are now allowed to calculate heuristic freshness for URIs with query components. (Section 4.2.2)
</p>
</blockquote>

<blockquote>
<p>
The algorithm for calculating age is now less conservative. Caches are now required to handle dates with time zones as if they're invalid, because it's not possible to accurately guess. (Section 4.2.3)
</p>
</blockquote>

<blockquote>
<p>
The Content-Location response header field is no longer used to determine the appropriate response to use when validating. (Section 4.3)
</p>
</blockquote>

<blockquote>
<p>
The algorithm for selecting a cached negotiated response to use has been clarified in several ways. In particular, it now explicitly allows header-specific canonicalization when processing selecting header fields. (Section 4.1)
</p>
</blockquote>

<blockquote>
<p>
Requirements regarding denial-of-service attack avoidance when performing invalidation have been clarified. (Section 4.4)
</p>
</blockquote>

<blockquote>
<p>
Cache invalidation only occurs when a successful response is received. (Section 4.4)
</p>
</blockquote>

<blockquote>
<p>
Cache directives are explicitly defined to be case-insensitive. Handling of multiple instances of cache directives when only one is expected is now defined. (Section 5.2)
</p>
</blockquote>

<blockquote>
<p>
The "no-store" request directive doesn't apply to responses; i.e., a cache can satisfy a request with no-store on it and does not invalidate it. (Section 5.2.1.5)
</p>
</blockquote>

<blockquote>
<p>
The qualified forms of the private and no-cache cache directives are noted to not be widely implemented; for example, "private=foo" is interpreted by many caches as simply "private". Additionally, the meaning of the qualified form of no-cache has been clarified. (Section 5.2.2)
</p>
</blockquote>

<blockquote>
<p>
The "no-cache" response directive's meaning has been clarified. (Section 5.2.2.2)
</p>
</blockquote>

<blockquote>
<p>
The one-year limit on Expires header field values has been removed; instead, the reasoning for using a sensible value is given. (Section 5.3)
</p>
</blockquote>

<blockquote>
<p>
The Pragma header field is now only defined for backwards compatibility; future pragmas are deprecated. (Section 5.4)
</p>
</blockquote>

<blockquote>
<p>
Some requirements regarding production and processing of the Warning header fields have been relaxed, as it is not widely implemented. Furthermore, the Warning header field no longer uses RFC 2047 encoding, nor does it allow multiple languages, as these aspects were not implemented. (Section 5.5)
</p>
</blockquote>

<blockquote>
<p>
This specification introduces the Cache Directive and Warn Code Registries, and defines considerations for new cache directives. (Section 7.1 and Section 7.2)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org981c4e6" class="outline-2">
<h2 id="org981c4e6"><a id="ID-dd632d27-1596-43fe-90f8-dba848353e12"></a>附录 B：引进的 ABNF / Appendix B. Imported ABNF</h2>
<div class="outline-text-2" id="text-org981c4e6">
<blockquote>
<p>
The following core rules are included by reference, as defined in Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII character).
</p>
</blockquote>

<blockquote>
<p>
The rules below are defined in [RFC7230]:
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">OWS           = &lt;OWS, see [RFC7230], Section 3.2.3&gt;
field-name    = &lt;field-name, see [RFC7230], Section 3.2&gt;
quoted-string = &lt;quoted-string, see [RFC7230], Section 3.2.6&gt;
token         = &lt;token, see [RFC7230], Section 3.2.6&gt;

port          = &lt;port, see [RFC7230], Section 2.7&gt;
pseudonym     = &lt;pseudonym, see [RFC7230], Section 5.7.1&gt; 
uri-host      = &lt;uri-host, see [RFC7230], Section 2.7&gt;
</pre>
</div>

<blockquote>
<p>
The rules below are defined in other parts:
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">HTTP-date     = &lt;HTTP-date, see [RFC7231], Section 7.1.1.1&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org72bdc79" class="outline-2">
<h2 id="org72bdc79"><a id="ID-33ccb99a-6b09-4750-9e71-4cc1e43b49c5"></a>附录 C：ABNF 集合 / Appendix C. Collected ABNF</h2>
<div class="outline-text-2" id="text-org72bdc79">
<blockquote>
<p>
In the collected ABNF below, list rules are expanded as per Section 1.2 of [RFC7230].
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Age = delta-seconds

Cache-Control = *( "," OWS ) cache-directive *( OWS "," [ OWS
 cache-directive ] )

Expires = HTTP-date

HTTP-date = &lt;HTTP-date, see [RFC7231], Section 7.1.1.1&gt;

OWS = &lt;OWS, see [RFC7230], Section 3.2.3&gt;

Pragma = *( "," OWS ) pragma-directive *( OWS "," [ OWS
 pragma-directive ] )

Warning = *( "," OWS ) warning-value *( OWS "," [ OWS warning-value ]
 )

cache-directive = token [ "=" ( token / quoted-string ) ]

delta-seconds = 1*DIGIT

extension-pragma = token [ "=" ( token / quoted-string ) ]

field-name = &lt;field-name, see [RFC7230], Section 3.2&gt;

port = &lt;port, see [RFC7230], Section 2.7&gt;
pragma-directive = "no-cache" / extension-pragma
pseudonym = &lt;pseudonym, see [RFC7230], Section 5.7.1&gt;

quoted-string = &lt;quoted-string, see [RFC7230], Section 3.2.6&gt;

token = &lt;token, see [RFC7230], Section 3.2.6&gt;

uri-host = &lt;uri-host, see [RFC7230], Section 2.7&gt;

warn-agent = ( uri-host [ ":" port ] ) / pseudonym
warn-code = 3DIGIT
warn-date = DQUOTE HTTP-date DQUOTE
warn-text = quoted-string
warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date
 ]
</pre>
</div>
</div>
</div>

<div id="outline-container-org37dfe9c" class="outline-2">
<h2 id="org37dfe9c">索引 / Index</h2>
<div class="outline-text-2" id="text-org37dfe9c">
<ul class="org-ul">
<li>1
<ul class="org-ul">
<li>110 (warn-code)  4.2.4, 5.5.1, 7.2.2</li>
<li>111 (warn-code)  5.5.2, 7.2.2</li>
<li>112 (warn-code)  4.2.4, 5.5.3, 7.2.2</li>
<li>113 (warn-code)  4.2.2, 5.5.4, 7.2.2</li>
<li>199 (warn-code)  5.5.5, 7.2.2</li>
</ul></li>
<li>2
<ul class="org-ul">
<li>214 (warn-code)  5.5.6, 7.2.2</li>
<li>299 (warn-code)  5.5.7, 7.2.2</li>
</ul></li>
<li>A
<ul class="org-ul">
<li>age  4.2</li>
<li>Age header field  4, 4.2.3, 5.1, 7.3</li>
</ul></li>
<li>B
<ul class="org-ul">
<li>BCP90  7.3, 10.2</li>
</ul></li>
<li>C
<ul class="org-ul">
<li>cache  1</li>
<li>cache entry  2</li>
<li>cache key  2, 2</li>
<li>Cache-Control header field  3, 5.2, 7.3, A</li>
</ul></li>
<li>D
<ul class="org-ul">
<li>Disconnected Operation (warn-text)  4.2.4, 5.5.3, 7.2.2</li>
</ul></li>
<li>E
<ul class="org-ul">
<li>Expires header field  3, 4.2, 4.2.1, 5.3, 7.3, A</li>
<li>explicit expiration time  4.2</li>
</ul></li>
<li>F
<ul class="org-ul">
<li>fresh  4.2</li>
<li>freshness lifetime  4.2</li>
</ul></li>
<li>G
<ul class="org-ul">
<li>Grammar  
<ul class="org-ul">
<li>Age  5.1</li>
<li>Cache-Control  5.2</li>
<li>cache-directive  5.2</li>
<li>delta-seconds  1.2.1</li>
<li>Expires  5.3</li>
<li>extension-pragma  5.4</li>
<li>Pragma  5.4</li>
<li>pragma-directive  5.4</li>
<li>warn-agent  5.5</li>
<li>warn-code  5.5</li>
<li>warn-date  5.5</li>
<li>warn-text  5.5</li>
<li>Warning  5.5</li>
<li>warning-value  5.5</li>
</ul></li>
</ul></li>
<li>H
<ul class="org-ul">
<li>Heuristic Expiration (warn-text)  4.2.2, 5.5.4, 7.2.2</li>
<li>heuristic expiration time  4.2</li>
</ul></li>
<li>M
<ul class="org-ul">
<li>max-age (cache directive)  5.2.1.1, 5.2.2.8</li>
<li>max-stale (cache directive)  5.2.1.2</li>
<li>min-fresh (cache directive)  5.2.1.3</li>
<li>Miscellaneous Persistent Warning (warn-text)  5.5.7, 7.2.2</li>
<li>Miscellaneous Warning (warn-text)  5.5.5, 7.2.2</li>
<li>must-revalidate (cache directive)  5.2.2.1</li>
</ul></li>
<li>N
<ul class="org-ul">
<li>no-cache (cache directive)  5.2.1.4, 5.2.2.2</li>
<li>no-store (cache directive)  5.2.1.5, 5.2.2.3</li>
<li>no-transform (cache directive)  5.2.1.6, 5.2.2.4</li>
</ul></li>
<li>O
<ul class="org-ul">
<li>only-if-cached (cache directive)  5.2.1.7</li>
</ul></li>
<li>P
<ul class="org-ul">
<li>Pragma header field  4, 5.4, 7.3, A</li>
<li>private (cache directive)  5.2.2.6</li>
<li>private cache  1</li>
<li>proxy-revalidate (cache directive)  5.2.2.7</li>
<li>public (cache directive)  5.2.2.5</li>
</ul></li>
<li>R
<ul class="org-ul">
<li>Response is Stale (warn-text)  4.2.4, 5.5.1, 7.2.2</li>
<li>Revalidation Failed (warn-text)  5.5.2, 7.2.2</li>
<li>RFC2119  1.1, 10.1</li>
<li>RFC2616  4.2.2, 10.2
<ul class="org-ul">
<li>Section 13.9  4.2.2</li>
</ul></li>
<li>RFC5226  7.1.1, 7.2.1, 10.2
<ul class="org-ul">
<li>Section 4.1  7.1.1, 7.2.1</li>
</ul></li>
<li>RFC5234  1.2, 10.1, B
<ul class="org-ul">
<li>Appendix B.1  B</li>
</ul></li>
<li>RFC5861  7.1.3, 7.1.3, 10.2
<ul class="org-ul">
<li>Section 3  7.1.3</li>
<li>Section 4  7.1.3</li>
</ul></li>
<li>RFC5905  4.2.3, 10.2</li>
<li>RFC6265  8, 10.2</li>
<li>RFC7230  1.1, 1.2, 3.1, 4, 4.1, 4.4, 4.4, 4.4, 5.2.1.6, 5.2.2.4, 8, 8, 9, 10.1, B, B, B, B, B, B, B, B, C
<ul class="org-ul">
<li>Section 1.2  C</li>
<li>Section 2.5  1.1</li>
<li>Section 2.7  B, B</li>
<li>Section 3.2  4.1, B</li>
<li>Section 3.2.3  B</li>
<li>Section 3.2.6  B, B</li>
<li>Section 3.3.3  8</li>
<li>Section 5.5  4, 4.4, 4.4, 4.4</li>
<li>Section 5.7.1  B</li>
<li>Section 5.7.2  5.2.1.6, 5.2.2.4</li>
<li>Section 7  1.2</li>
<li>Section 10  9</li>
</ul></li>
<li>RFC7231  2, 2, 4, 4.1, 4.2.2, 4.2.3, 4.4, 5.3, 8, 10.1, B
<ul class="org-ul">
<li>Section 4.2.1  4, 4.4</li>
<li>Section 4.3.1  2</li>
<li>Section 6.1  4.2.2</li>
<li>Section 7.1.1.1  5.3, B</li>
<li>Section 7.1.1.2  4.2.3</li>
<li>Section 7.1.4  4.1</li>
</ul></li>
<li>RFC7232  4.2.2, 4.3, 4.3.1, 4.3.1, 4.3.2, 4.3.2, 4.3.2, 4.3.4, 10.1
<ul class="org-ul">
<li>Section 2.1  4.3.4</li>
<li>Section 2.2  4.2.2, 4.3.1</li>
<li>Section 2.3  4.3.1</li>
<li>Section 3.2  4.3.2</li>
<li>Section 3.3  4.3.2</li>
<li>Section 6  4.3.2</li>
</ul></li>
<li>RFC7233  3.1, 3.3, 3.3, 4.3.2, 4.3.2, 10.1
<ul class="org-ul">
<li>Section 3.2  4.3.2</li>
<li>Section 4.3  3.3</li>
</ul></li>
<li>RFC7235  3, 3.2, 10.1
<ul class="org-ul">
<li>Section 4.2  3, 3.2</li>
</ul></li>
</ul></li>
<li>S
<ul class="org-ul">
<li>s-maxage (cache directive)  5.2.2.9</li>
<li>shared cache  1</li>
<li>stale  4.2</li>
<li>strong validator  4.3.4</li>
</ul></li>
<li>T
<ul class="org-ul">
<li>Transformation Applied (warn-text)  5.5.6, 7.2.2</li>
</ul></li>
<li>V
<ul class="org-ul">
<li>validator  4.3.1</li>
</ul></li>
<li>W
<ul class="org-ul">
<li>Warning header field  3.3, 4.3.4, 4.3.5, 5.5, 7.3, A</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org79cb7b1" class="outline-2">
<h2 id="org79cb7b1">Authors' Addresses</h2>
<div class="outline-text-2" id="text-org79cb7b1">
<pre class="example">
Roy T. Fielding (editor)
Adobe Systems Incorporated
345 Park Ave
San Jose, CA 95110
USA
Email: fielding@gbiv.com
URI: http://roy.gbiv.com/
</pre>

<pre class="example">
Mark Nottingham (editor)
Akamai
Email: mnot@mnot.net
URI: http://www.mnot.net/
</pre>

<pre class="example">
Julian F. Reschke (editor)
greenbytes GmbH
Hafenweg 16
Muenster, NW 48155
Germany
Email: julian.reschke@greenbytes.de
URI: http://greenbytes.de/tech/webdav/
</pre>
</div>
</div>
</div>
</body>
</html>
