<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-11-15 Thu 19:21 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RFC7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
* {
  box-sizing: border-box;
}

html {
  padding: 0;
}

body {
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 15px;
  line-height: 1.6;
  padding: 0;
  margin: 0;
  color: #24292e;
  word-wrap: break-word;
}

b, strong {
  font-weight: 700;
}

p {
  margin: 0 0 16px;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a:active, a:hover {
  outline-width: 0;
}

.underline{
  text-decoration: underline;
}

del{
  text-decoration: line-through;
}

i {
  font-style: italic;
}

ul, ol {
  padding-left: 1em;
}

ruby {
  border-bottom: 1px solid #d9d9d9;
}

ruby > rt {
  color: #6a737d;
  text-align: center;
}

h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h1.title {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h1 {
  font-size: 2.5em;
}

.outline-2 h2 {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h3 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h4 {
  font-size: 1.25em
}

.outline-2 h5 {
  font-size: 1.1em
}

.outline-2 h6 {
  font-size: 1.1em
}

.outline-2 code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;

  color: #c7254e;
  background-color: #f9f2f4;
  white-space: normal;
  font-family: Consolas,Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,sans-serif;
}

.outline-2 table{
  width: 100%;
}

.outline-2 p,
.outline-2 blockquote,
.outline-2 ul,
.outline-2 ol,
.outline-2 dl,
.outline-2 table,
.outline-2 pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.outline-2 ul,
.outline-2 ol {
  padding-left: 2em;
}

table tbody tr:nth-child(odd){
  background-color: #efefef;
}

pre,
blockquote {
  margin-bottom: 1em;
}

pre {
  margin: 0;
  padding: 1em;
  line-height: 1.45;
  font-size: 95%;
  font-family: Consolas,Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,sans-serif;
  border-radius: 3px;
  overflow: auto;
}

blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
  margin: 0;
}

.org-src-container, .example {
  width: 100%;
  overflow-x: auto;
  border-left: 0.25em solid #dfe2e5;
  border-radius: 0.5rem;
  background-color: #f6f8fa;
  margin-bottom: 16px;
}

.org-src-container pre {
  margin-bottom: 0;
}

.timestamp {
  font-family: Courier New;
  color: #888888;
}

dd {
  text-align: justify;
  margin-bottom: 14pt;
}

dt {
  font-size: 110%;
  font-family: Courier New;
  color: #1c3030;
  padding: 3px;
  margin-bottom: 3px;
}

#table-of-contents {
  font-size: 9pt;
  position: fixed;
  right: 0em;
  top: 0em;
  background: white;
  -webkit-box-shadow: 0 0 1em #777777;
  -moz-box-shadow: 0 0 1em #777777;
  -webkit-border-bottom-left-radius: 5px;
  -moz-border-radius-bottomleft: 5px;
  text-align: right;
  max-height: 80%;
  overflow: auto;
  z-index: 200;
}

#table-of-contents h2 {
  font-size: 14px;
  font-weight: normal;
  padding: 0 .5em;
  margin: 16px 0;
  text-align: left;
}

#table-of-contents ul {
  margin-left: 14pt;
  margin-bottom: 10pt;
  padding: 0
}

#table-of-contents li {
  padding: 0;
  margin: 1px;
  list-style: none;
}

#table-of-contents ul>:first-child {
  color: blue;
}

#table-of-contents #text-table-of-contents {
  display: none;
  text-align: left;
}

#table-of-contents:hover #text-table-of-contents {
  display: block;
  padding: 0.5em;
  margin-top: -1.5em;
}

#content {
  width: 980px;
  padding: 45px 15px 15px 15px;
  margin-right: auto;
  margin-left: auto;
}

@media screen and (max-width: 980px) {
  #content {
    width: 100%;
  }
  #table-of-contents {
    float: right;
    border: 1px solid #CCC;
    max-width: 50%;
    overflow: auto;
  }
}

.footdef {
}
.footdef sup {
  float: left;
  width: 3em;
}
.footdef > .footpara {
  margin-left: 3em;
  overflow-x: hidden;
}
.org-src-container {
  width: 100%;
  overflow-x: auto;
}
.github-repo {
  position: absolute;
  top: 0;
  left: -24px;
  margin-top: 32px;
  padding: 0 20px 0 40px;
  background-color: rgba(0,0,0,.2);
  height: 22px;
  line-height: 22px;
  padding-left: 42px;
  transform: rotate(-45deg);
  transform-origin: 40% 50%;
}
.github-repo:hover,
.github-repo:active {
  text-decoration: none;
}
.github-repo svg {
  position: absolute;
  width: 18px;
  height: 18px;
  left: 20px;
  top: 2px;
}
.github-repo span {
  color: #fff;
}
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">RFC7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc803794">摘要 / Abstract</a></li>
<li><a href="#org6c0726e">备忘录状态 / Status of This Memo</a></li>
<li><a href="#org3428e68">版权声明 / Copyright Notice</a></li>
<li><a href="#orgacdc89e">1. 引言 / Introduction</a>
<ul>
<li><a href="#org6e97771">1.1. 一致性和错误处理 / Conformance and Error Handling</a></li>
<li><a href="#org4435df5">1.2. 句法标记 / Syntax Notation</a></li>
</ul>
</li>
<li><a href="#orgec9ef27">2. 资源 / Resources</a></li>
<li><a href="#org5a29517">3. 资源的表示 / Representations</a>
<ul>
<li><a href="#orgc098448">3.1. 表示元数据 / Representation Metadata</a>
<ul>
<li><a href="#orgfebd6b5">3.1.1. 处理表示数据 / Processing Representation Data</a>
<ul>
<li><a href="#org9cacf10">3.1.1.1. 媒体类型 / Media Type</a></li>
<li><a href="#org22f52a6">3.1.1.2. 字符集 / Charset</a></li>
<li><a href="#orgff3c076">3.1.1.3. 规范化和文本缺省 / Canonicalization and Text Defaults</a></li>
<li><a href="#org9d24f7a">3.1.1.4. Multipart 类型 / Multipart Types</a></li>
<li><a href="#org55c71b5">3.1.1.5. Content-Type</a></li>
</ul>
</li>
<li><a href="#org3e2d9f7">3.1.2. 为压缩或完整性而编码 / Encoding for Compression or Integrity</a>
<ul>
<li><a href="#org72efdb3">3.1.2.1. Content Codings</a></li>
<li><a href="#org17a1ce7">3.1.2.2. Content-Encoding</a></li>
</ul>
</li>
<li><a href="#orgb14a20b">3.1.3. 受众语言 / Audience Language</a>
<ul>
<li><a href="#org2f3fd1f">3.1.3.1. 语言标签 / Language Tags</a></li>
<li><a href="#orgea9b8dd">3.1.3.2. Content-Language</a></li>
</ul>
</li>
<li><a href="#org7d8ba38">3.1.4. 标识 / Identification</a>
<ul>
<li><a href="#orgc47d26b">3.1.4.1. 标识一个 Representation / Identifying a Representation</a></li>
<li><a href="#org6190703">3.1.4.2. Content-Location</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd26c42d">3.2. 表示数据 / Representation Data</a></li>
<li><a href="#orgb3d98f9">3.3. 有效载荷的语义 / Payload Semantics</a></li>
<li><a href="#org7e87af6">3.4. 内容协商 / Content Negotiation</a>
<ul>
<li><a href="#orgcc6adb1">3.4.1. 主动型协商 / Proactive Negotiation</a></li>
<li><a href="#orgb6b9e23">3.4.2. 被动型协商 / Reactive Negotiation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5b4a18e">4. 请求方法 / Request Methods</a>
<ul>
<li><a href="#orgbe6d4a0">4.1. 概况 / Overview</a></li>
<li><a href="#orga71ccac">4.2. 公共方法属性 / Common Method Properties</a>
<ul>
<li><a href="#org9cf22b2">4.2.1. 安全方法 / Safe Methods</a></li>
<li><a href="#orgf6e425a">4.2.2. 幂等方法 / Idempotent Methods</a></li>
<li><a href="#org1aba746">4.2.3. 可缓存方法 / Cacheable Methods</a></li>
</ul>
</li>
<li><a href="#org04053c2">4.3. 方法的定义 / Method Definitions</a>
<ul>
<li><a href="#org479e86d">4.3.1. GET</a></li>
<li><a href="#org607980d">4.3.2. HEAD</a></li>
<li><a href="#org24c5a01">4.3.3. POST</a></li>
<li><a href="#org2e14fb1">4.3.4. PUT</a></li>
<li><a href="#orgf7b2242">4.3.5. DELETE</a></li>
<li><a href="#org3103350">4.3.6. CONNECT</a></li>
<li><a href="#org85c174f">4.3.7. OPTIONS</a></li>
<li><a href="#orgda48f54">4.3.8. TRACE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org478df38">5. 请求报头域 / Request Header Fields</a>
<ul>
<li><a href="#org8542bda">5.1. 控制 / Controls</a>
<ul>
<li><a href="#org83b8384">5.1.1. Expect</a></li>
<li><a href="#org57067e1">5.1.2. Max-Forwards</a></li>
</ul>
</li>
<li><a href="#org8c0da01">5.2. 条件 / Conditionals</a></li>
<li><a href="#org07183ec">5.3. 内容协商 / Content Negotiation</a>
<ul>
<li><a href="#org6e3f7bd">5.3.1. Quality Values</a></li>
<li><a href="#orgd78f0e9">5.3.2. Accept</a></li>
<li><a href="#org5919b30">5.3.3. Accept-Charset</a></li>
<li><a href="#org6451ddf">5.3.4. Accept-Encoding</a></li>
<li><a href="#org39787e1">5.3.5. Accept-Language</a></li>
</ul>
</li>
<li><a href="#orgeec6089">5.4. 身份验证凭证 / Authentication Credentials</a></li>
<li><a href="#org178e82e">5.5. 请求上下文/ Request Context</a>
<ul>
<li><a href="#org0e7c143">5.5.1. Form</a></li>
<li><a href="#orga439d85">5.5.2. Referer</a></li>
<li><a href="#org382027f">5.5.3. User-Agent</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1463c22">6. 响应状态码 / Response Status Codes</a>
<ul>
<li><a href="#org5d42953">6.1. 状态码概况 / Overview of Status Codes</a></li>
<li><a href="#org937cde4">6.2. 信息性 1xx / Informational 1xx</a>
<ul>
<li><a href="#orgb177ae0">6.2.1. 100 Continue</a></li>
<li><a href="#org17170cb">6.2.2. 101 Switching Protocols</a></li>
</ul>
</li>
<li><a href="#orge3be6d7">6.3. 成功 2xx / Successful 2xx</a>
<ul>
<li><a href="#org0038347">6.3.1. 200 OK</a></li>
<li><a href="#org7621bcc">6.3.2. 201 Created</a></li>
<li><a href="#org90994de">6.3.3. 202 Accepted</a></li>
<li><a href="#org3a69f3a">6.3.4. 203 Non-Authoritative Information</a></li>
<li><a href="#org61ddd38">6.3.5. 204 No Content</a></li>
<li><a href="#org9d78f6e">6.3.6. 205 Reset Content</a></li>
</ul>
</li>
<li><a href="#orgdf0960e">6.4. 重定向 3xx / Redirection 3xx</a>
<ul>
<li><a href="#org6a26035">6.4.1. 300 Multiple Choices</a></li>
<li><a href="#orgdd25815">6.4.2. 301 Moved Permanently</a></li>
<li><a href="#org1dd45d0">6.4.3. 302 Found</a></li>
<li><a href="#orga14232d">6.4.4. 303 See Other</a></li>
<li><a href="#orgbea7275">6.4.5. 305 Use Proxy</a></li>
<li><a href="#orgcefeee6">6.4.6. 306 (Unused)</a></li>
<li><a href="#orgd9247a2">6.4.7. 307 Temporary Redirect</a></li>
</ul>
</li>
<li><a href="#org187c176">6.5. 客户端错误 / Client Error 4xx</a>
<ul>
<li><a href="#org6b99dfb">6.5.1. 400 Bad Request</a></li>
<li><a href="#org42c217d">6.5.2. 402 Payment Required</a></li>
<li><a href="#org86089b5">6.5.3. 403 Forbidden</a></li>
<li><a href="#org6ef9040">6.5.4. 404 Not Found</a></li>
<li><a href="#org9297a17">6.5.5. 405 Method Not Allowed</a></li>
<li><a href="#orgdf502e9">6.5.6. 406 Not Acceptable</a></li>
<li><a href="#org2a53d18">6.5.7. 408 Request Timeout</a></li>
<li><a href="#org010d0a2">6.5.8. 409 Conflict</a></li>
<li><a href="#org4072a5f">6.5.9. 410 Gone</a></li>
<li><a href="#org014abbd">6.5.10. 411 Length Required</a></li>
<li><a href="#org7f816ee">6.5.11. 413 Payload Too Large</a></li>
<li><a href="#orgda225c7">6.5.12. 414 URI Too Long</a></li>
<li><a href="#org9aaec2d">6.5.13. 415 Unsupported Media Type</a></li>
<li><a href="#orgcafc9ce">6.5.14. 417 Expectation Failed</a></li>
<li><a href="#org4cc1a60">6.5.15. 426 Upgrade Required</a></li>
</ul>
</li>
<li><a href="#orgbb53da7">6.6 服务器错误 / Server Error 5xx</a>
<ul>
<li><a href="#orge703f96">6.6.1. 500 Internal Server Error</a></li>
<li><a href="#org42220c0">6.6.2. 501 Not Implemented</a></li>
<li><a href="#orgb9f52eb">6.6.3. 502 Bad Gateway</a></li>
<li><a href="#orgda430f7">6.6.4. 503 Service Unavailable</a></li>
<li><a href="#orgb821e4f">6.6.5. 504 Gateway Timeout</a></li>
<li><a href="#org1131bac">6.6.6. 505 HTTP Version Not Supported</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org32d1acf">7. 响应报头域 / Response Header Fields</a>
<ul>
<li><a href="#orge68fb41">7.1. Control Data</a>
<ul>
<li><a href="#org67adfb6">7.1.1. Origination Date</a>
<ul>
<li><a href="#org8c425df">7.1.1.1. Date/Time Formats</a></li>
<li><a href="#org8e5ec45">7.1.1.2. Data</a></li>
</ul>
</li>
<li><a href="#orgad9277e">7.1.2. Location</a></li>
<li><a href="#orgbf05a48">7.1.3. Retry-After</a></li>
<li><a href="#org5ddc30c">7.1.4. Vary</a></li>
</ul>
</li>
<li><a href="#org4d2e5ff">7.2. Validator Header Fields</a></li>
<li><a href="#org847a265">7.3. Authentication Challenges</a></li>
<li><a href="#orgee15c9d">7.4. Response Context</a>
<ul>
<li><a href="#orgbfaeb5b">7.4.1. Allow</a></li>
<li><a href="#orgb253800">7.4.2. Server</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb1bfeaa">8. IANA 注意事项 / IANA Considerations</a>
<ul>
<li><a href="#org04dcb6c">8.1. 方法注册表 / Method Registry</a>
<ul>
<li><a href="#orgbd9a42f">8.1.1. Procedure</a></li>
<li><a href="#orgba5b1d5">8.1.2. Considerations for New Methods</a></li>
<li><a href="#org4689641">8.1.3. Registrations</a></li>
</ul>
</li>
<li><a href="#orgbd7074f">8.2. 状态码注册表 / Status Code Registry</a>
<ul>
<li><a href="#org97fd11b">8.2.1. Procedure</a></li>
<li><a href="#org0c87ec2">8.2.2. Considerations for New Status Codes</a></li>
<li><a href="#org091139b">8.2.3. Registrations</a></li>
</ul>
</li>
<li><a href="#orgc36cdf1">8.3. 报头域注册表 / Header Field Registry</a>
<ul>
<li><a href="#org97979b4">8.3.1. Considerations for New Header Fields</a></li>
<li><a href="#orgc14b9da">8.3.2. Registrations</a></li>
</ul>
</li>
<li><a href="#orgb8f27ff">8.4. 内容编码值注册表 / Content Coding Registry</a>
<ul>
<li><a href="#org1c5ac4f">8.4.1. Procedure</a></li>
<li><a href="#orgbee91f3">8.4.2. Registrations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc08e2c6">9. 安全注意事项 / Security Considerations</a>
<ul>
<li><a href="#org64f3a9f">9.1. 基于文件和路径名称的攻击 / Attacks Based on File and Path Names</a></li>
<li><a href="#org16209ea">9.2. 基于命令、代码、查询注入 / Attacks Based on Command, Code, or Query Injection</a></li>
<li><a href="#org088e6f0">9.3. 个人信息的披露 / Disclosure of Personal Information</a></li>
<li><a href="#org73c0e2a">9.4. URLs 敏感信息的披露 / Disclosure of Sensitive Information in URLs</a></li>
<li><a href="#org25a250a">9.5. Disclosure of Fragment after Redirects</a></li>
<li><a href="#org6f777ff">9.6. Disclosure of Product Information</a></li>
<li><a href="#org588cbb2">9.7. 浏览器指纹识别 / Browser Fingerprinting</a></li>
</ul>
</li>
<li><a href="#org1702724">10. 鸣谢 / Acknowledgements</a></li>
<li><a href="#org1b106b3">11. 参考资料 / References</a>
<ul>
<li><a href="#org1cb72c1">11.1. Normative References</a></li>
<li><a href="#orgb0730d9">11.2. Informative References</a></li>
</ul>
</li>
<li><a href="#orgc9f7ec8">A. HTTP 与 MIME 的区别 / Defferences between HTTP and MIME</a>
<ul>
<li><a href="#org5e69c70">A.1. MIME-VERSION</a></li>
<li><a href="#org6beafbd">A.2. Conversion to Canonical Form</a></li>
<li><a href="#org372beac">A.3. Conversion of Date Formats</a></li>
<li><a href="#org6064441">A.4. Conversion of Content-Encoding</a></li>
<li><a href="#org6eb57d2">A.5. Conversion of Content-Transfer-Encoding</a></li>
<li><a href="#orgbad58ce">A.6. MHTML and Line Length Limitations</a></li>
</ul>
</li>
<li><a href="#org9b37d9f">B. 相对 RFC 2616 的变化 / Changes from RFC 2616</a></li>
<li><a href="#orgc3125d2">C. 引入的 ABNF 规则 / Imported ABNF</a></li>
<li><a href="#org19b465a">D. ABNF 规则集合 Collected ABNF</a></li>
<li><a href="#org91aa32b">Index</a></li>
<li><a href="#org40e7e5d">Author' Addresses</a></li>
</ul>
</div>
</div>
<a class="github-repo" href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <svg height="18" width="18" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
  <span>View Repo</span>
</a>

<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img alt="" src="https://img.shields.io/github/license/duoani/HTTP-RFCs.zh-cn.svg?style=social"/>
</a>
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img src="https://img.shields.io/github/stars/duoani/HTTP-RFCs.zh-cn.svg?style=social&label=Stars"/>
</a>

<div class="org-src-container">
<pre class="src src-text">                                                       PROPOSED STANDARD
                                                            Errata Exist
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7231                                         Adobe
Obsoletes: 2616                                          J. Reschke, Ed.
Updates: 2817                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721
</pre>
</div>

<div id="outline-container-orgc803794" class="outline-2">
<h2 id="orgc803794">摘要 / Abstract</h2>
<div class="outline-text-2" id="text-orgc803794">
<blockquote>
<p>
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.
</p>
</blockquote>

<p>
超文本传输协议（HTTP）是一种<ruby>无状态<rt>stateless</rt></ruby>的应用层协议，适用于分布式、协作式的超文本信息系统。本文档定义了 HTTP/1.1 报文的语义，引申为<ruby>请求方法<rt>request methods</rt></ruby>、<ruby>请求报头域<rt>request header fields</rt></ruby>、<ruby>响应状态码<rt>response status codes</rt></ruby>、<ruby>响应报头域<rt>response header fields</rt></ruby>，连同报文的<ruby>有效载荷<rt>payload</rt></ruby>（元数据以及报文正文内容）以及<ruby>内容协商<rt>content negotiation</rt></ruby>的机制。
</p>
</div>
</div>

<div id="outline-container-org6c0726e" class="outline-2">
<h2 id="org6c0726e">备忘录状态 / Status of This Memo</h2>
<div class="outline-text-2" id="text-org6c0726e">
<p>
This is an Internet Standards Track document.
</p>

<p>
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
</p>

<p>
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at <a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>.
</p>
</div>
</div>

<div id="outline-container-org3428e68" class="outline-2">
<h2 id="org3428e68">版权声明 / Copyright Notice</h2>
<div class="outline-text-2" id="text-org3428e68">
<p>
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p>
This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
</p>

<p>
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
</p>
</div>
</div>

<div id="outline-container-orgacdc89e" class="outline-2">
<h2 id="orgacdc89e">1. 引言 / Introduction</h2>
<div class="outline-text-2" id="text-orgacdc89e">
<blockquote>
<p>
Each Hypertext Transfer Protocol (HTTP) message is either a request or a response. A server listens on a connection for a request, parses each message received, interprets the message semantics in relation to the identified request target, and responds to that request with one or more response messages. A client constructs request messages to communicate specific intentions, examines received responses to see if the intentions were carried out, and determines how to interpret the results. This document defines HTTP/1.1 request and response semantics in terms of the architecture defined in [RFC7230].
</p>
</blockquote>

<p>
每一个超文本传输协议（HTTP）报文不是一个请求就是一个响应。服务器监听某个连接的请求，<ruby>解析<rt>parse</rt></ruby>其接收到的每个报文，<ruby>解释<rt>interpret</rt></ruby>报文内关于请求目标的语义，最后使用一个或多个响应报文来回应该请求。客户端构建请求报文来传达特定的意图，检查接收到的响应来观察其意图是否得到贯彻执行，并确定如何去<ruby>解释<rt>interpret</rt></ruby>该结果。本文档依据<a href="RFC7230.html">【RFC7230】</a>所定义的架构，定义了 HTTP/1.1 请求和响应的语义。
</p>

<blockquote>
<p>
HTTP provides a uniform interface for interacting with a resource (<a href="#orgec9ef27">Section 2</a>), regardless of its type, nature, or implementation, via the manipulation and transfer of representations (<a href="#org5a29517">Section 3</a>).
</p>
</blockquote>

<p>
HTTP 提供了一种统一的接口来对<ruby>资源<rt>resource</rt></ruby>（<a href="#orgec9ef27">章节 2</a>）进行交互，而不必理会资源的类型、性质或者<ruby>实现<rt>implementation</rt></ruby>，具体是经由对<ruby>资源的表示<rt>representations</rt></ruby>（<a href="#org5a29517">章节 3</a>）进行操作和传输来实现的。
</p>

<blockquote>
<p>
HTTP semantics include the intentions defined by each request method (<a href="#org5b4a18e">Section 4</a>), extensions to those semantics that might be described in request header fields (<a href="#org478df38">Section 5</a>), the meaning of status codes to indicate a machine-readable response (<a href="#org1463c22">Section 6</a>), and the meaning of other control data and resource metadata that might be given in response header fields (<a href="#org32d1acf">Section 7</a>).
</p>
</blockquote>

<p>
HTTP 的语义包含了每个<ruby>请求方法<rt>request method</rt></ruby>所定义的意图（<a href="#org5b4a18e">章节 4</a>）、<ruby>请求报头域<rt>request header fields</rt></ruby>对这些语义的扩展（<a href="#org478df38">章节 5</a>）、<ruby>状态码<rt>status codes</rt></ruby>的含义（用于指定一种机器可阅读的响应，<a href="#org1463c22">章节 6</a>）、以及出现在<ruby>响应报头域<rt>response header fields</rt></ruby>里的其他控制数据和资源元数据的含义（<a href="#org32d1acf">章节 7</a>）。
</p>

<blockquote>
<p>
This document also defines representation metadata that describe how a payload is intended to be interpreted by a recipient, the request header fields that might influence content selection, and the various selection algorithms that are collectively referred to as "content negotiation" (<a href="#org7e87af6">Section 3.4</a>).
</p>
</blockquote>

<p>
本文档还定义了以下内容：描述打算让接收端怎样<ruby>解释<rt>interpret</rt></ruby>一个<ruby>有效载荷<rt>payload</rt></ruby>的<ruby>资源的表示元数据<rt>representation metadata</rt></ruby>、可能影响<ruby>内容选择<rt>content selection</rt></ruby>的请求报头域、统称为“<ruby>内容协商<rt>content negotiation</rt></ruby>”的各种选择算法（<a href="#org7e87af6">章节 3.4</a>）。
</p>
</div>

<div id="outline-container-org6e97771" class="outline-3">
<h3 id="org6e97771">1.1. 一致性和错误处理 / Conformance and Error Handling</h3>
<div class="outline-text-3" id="text-org6e97771">
<blockquote>
<p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [<a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>].
</p>
</blockquote>

<p>
关键词 <b><ruby>必须<rt>MUST</rt></ruby></b>、<b><ruby>禁止<rt>MUST NOT</rt></ruby></b>、<b><ruby>要求<rt>REQUIRED</rt></ruby></b>、<b><ruby>必须<rt>SHALL</rt></ruby></b>、<b><ruby>禁止<rt>SHALL NOT</rt></ruby></b>、<b><ruby>应该<rt>SHOULD</rt></ruby></b>、<b><ruby>不应当<rt>SHOULD NOT</rt></ruby></b>、<b><ruby>推荐<rt>RECOMMENDED</rt></ruby></b>、<b><ruby>可以<rt>MAY</rt></ruby></b> 和 <b><ruby>可选<rt>OPTIONAL</rt></ruby></b> 的意义与【<a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>】一致。
</p>

<blockquote>
<p>
Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].
</p>
</blockquote>

<p>
关于错误处理的一致性标准以及注意事项已在<a href="RFC7230.html#ID-A0441F72-9799-4667-9477-1E05885946A1">【RFC7230】章节 2.5</a> 中定义了。
</p>
</div>
</div>

<div id="outline-container-org4435df5" class="outline-3">
<h3 id="org4435df5">1.2. 句法标记 / Syntax Notation</h3>
<div class="outline-text-3" id="text-org4435df5">
<blockquote>
<p>
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [<a href="https://tools.ietf.org/html/rfc5234">RFC5234</a>] with a list extension, defined in <a href="RFC7230.html#ID-b9db011d-fe47-4781-929a-4b1b0aa55aec">Section 7</a> of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix C describes rules imported from other documents. Appendix D shows the collected grammar with all list operators expanded to standard ABNF notation.
</p>
</blockquote>

<p>
本规范使用了扩展巴科斯范式（ABNF）标记法【<a href="https://tools.ietf.org/html/rfc5234">RFC5234</a>】，另外，出于定义的紧凑性的考虑，本规范对 ABNF 规则进行了扩展（见<a href="RFC7230.html#ID-b9db011d-fe47-4781-929a-4b1b0aa55aec">【RFC7230】章节 7</a>），允许使用一个 <code>#</code> 操作符（类似于 <code>*</code> 操作符，指代“重复”）来定义一种以逗号分隔的列表。
</p>

<blockquote>
<p>
This specification uses the terms "character", "character encoding scheme", "charset", and "protocol element" as they are defined in [<a href="https://tools.ietf.org/html/rfc6365">RFC6365</a>].
</p>
</blockquote>

<p>
本规范使用了术语“<ruby>字符<rt>character</rt></ruby>”、“<ruby>字符编码方案<rt>character encoding scheme</rt></ruby>”、“<ruby>字符集<rt>charset</rt></ruby>”、“<ruby>协议元素<rt>protocol element</rt></ruby>”，其定义见<a href="https://tools.ietf.org/html/rfc6365">【RFC6365】</a>。
</p>
</div>
</div>
</div>

<div id="outline-container-orgec9ef27" class="outline-2">
<h2 id="orgec9ef27"><a id="ID-304453f4-a250-4f73-b82c-2825a0bda464"></a>2. 资源 / Resources</h2>
<div class="outline-text-2" id="text-orgec9ef27">
<p>
The target of an HTTP request is called a "resource". HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources. Each resource is identified by a Uniform Resource Identifier (URI), as described in <a href="RFC7230.html#ID-9c45ae18-46b0-4acb-a478-3d3e9a3748ab">Section 2.7</a> of [RFC7230].
</p>

<p>
HTTP 请求的目标，被称为“<ruby>资源<rt>resource</rt></ruby>”。HTTP 并不限制一个资源的性质，它仅仅定义了一个可以用来对资源进行交互的接口。每一个资源都被一个<ruby>统一资源标识符（URI）<rt>Uniform Resource Identifier</rt></ruby>所标识，见<a href="RFC7230.html#ID-9c45ae18-46b0-4acb-a478-3d3e9a3748ab">【RFC7230】章节 2.7</a>。
</p>

<p>
When a client constructs an HTTP/1.1 request message, it sends the target URI in one of various forms, as defined in (<a href="RFC7230.html#ID-16a8fba9-40f8-4b2c-ba5f-2f6522362c3a">Section 5.3</a> of [RFC7230]). When a request is received, the server reconstructs an effective request URI for the target resource (<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">Section 5.5</a> of [RFC7230]).
</p>

<p>
当客户端<ruby>构建<rt>construct</rt></ruby>一个 HTTP/1.1 请求报文的时候，它将某种形式的<ruby>目标 URI<rt>target URI</rt></ruby> 包含在报文中，见<a href="RFC7230.html#ID-16a8fba9-40f8-4b2c-ba5f-2f6522362c3a">【RFC7230】章节 5.3</a>。当服务器接收到一个请求的时候，它将<ruby>重新构建<rt>reconstruct</rt></ruby>出一个<ruby>有效请求 URI<rt>effective request URI</rt></ruby>（见<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">【RFC7230】章节 5.5</a>）来定位<ruby>目标资源<rt>target resource</rt></ruby>。
</p>

<blockquote>
<p>
译注：目标 URI 有四种形式：<ruby>原始形式<rt>origin-form</rt></ruby>、<ruby>绝对形式<rt>absolute-form</rt></ruby>、<ruby>权威形式<rt>authority-form</rt></ruby>、<ruby>星号形式<rt>asterisk-form</rt></ruby>，详情见<a href="RFC7230.html#ID-16a8fba9-40f8-4b2c-ba5f-2f6522362c3a">【RFC7230】章节 5.3</a>。
</p>
</blockquote>

<p>
One design goal of HTTP is to separate resource identification from request semantics, which is made possible by vesting the request semantics in the request method (<a href="#org5b4a18e">Section 4</a>) and a few request-modifying header fields (<a href="#org478df38">Section 5</a>). If there is a conflict between the method semantics and any semantic implied by the URI itself, as described in Section 4.2.1, the method semantics take precedence.
</p>

<p>
HTTP 的设计目标之一是将<ruby>资源识别<rt>resource identification</rt></ruby>与请求语义相分离，使得请求语义全部归属于<ruby>请求方法<rt>request method</rt></ruby>（<a href="#org5b4a18e">章节 4</a>）以及几个<ruby>请求修饰报头域<rt>request-modifying header fields</rt></ruby>（<a href="#org478df38">章节 5</a>）。如果方法语义与 URI 自身所暗含的语义相冲突，正如<a href="#org9cf22b2">章节 4.2.1</a> 所述，优先使用方法语义。
</p>
</div>
</div>

<div id="outline-container-org5a29517" class="outline-2">
<h2 id="org5a29517"><a id="ID-7dd837af-fd6a-4918-9c62-cf12a4c31522"></a>3. 资源的表示 / Representations</h2>
<div class="outline-text-2" id="text-org5a29517">
<blockquote>
<p>
Considering that a resource could be anything, and that the uniform interface provided by HTTP is similar to a window through which one can observe and act upon such a thing only through the communication of messages to some independent actor on the other side, an abstraction is needed to represent ("take the place of") the current or desired state of that thing in our communications. That abstraction is called a representation [REST].
</p>
</blockquote>

<p>
考虑到<ruby>资源<rt>resource</rt></ruby>可以是任何事物，而 HTTP 所提供的统一接口类似于一个窗口，在窗口的一边我们能够对该事物进行观察；而要想对该事物采取行动的话，只能通过消息沟通来让窗口另一边的某个独立的动作执行者来完成。因此，在沟通过程中，我们需要一种“抽象”来<ruby>表示<rt>represent</rt></ruby>（代替）该事物的<ruby>当前状态<rt>current state</rt></ruby>或<ruby>期望状态<rt>desired state</rt></ruby>。而这种“抽象”被称为 <ruby>资源的表示<rt>representation</rt></ruby>【<a href="http://roy.gbiv.com/pubs/dissertation/top.htm">REST</a>】。
</p>

<blockquote>
<p>
译注：术语 "representation" 一词源自一种软件架构风格的术语—— REST（Representational Style Transfer），也就是我们常常听到的 RESTful 风格。<ruby>资源的表示<rt>representation</rt></ruby>是<ruby>资源<rt>resource</rt></ruby>的抽象，资源一般是唯一的，而资源的表示方式可以多种多样，例如，一份银行流水账单可以认为是一种资源，按媒体类型来分，它的表示形式可以有 JSON、XML 或者二进制格式等，按时间来分，它的表示形式可以有昨日收支、今日收支、本用收支等，更详细的介绍可以<a href="http://roy.gbiv.com/pubs/dissertation/rest_arch_style.htm">查看这里</a>。
</p>
</blockquote>

<blockquote>
<p>
For the purposes of HTTP, a "representation" is information that is intended to reflect a past, current, or desired state of a given resource, in a format that can be readily communicated via the protocol, and that consists of a set of representation metadata and a potentially unbounded stream of representation data.
</p>
</blockquote>

<p>
基于 HTTP 的目的，<ruby>资源的表示<rt>representation</rt></ruby>是一种信息，该信息用于反映某个给定资源的过去、现在、或将来期望的状态。它以一种能够轻易地经由协议进行传达的格式，并由一系列 <ruby>元数据<rt>representation metadata</rt></ruby>以及一个可能是无限大的 <ruby>数据<rt>representation data</rt></ruby>（流）组成。
</p>

<blockquote>
<p>
译注：再强调一次，"representation" 是资源的一种抽象，反映的是资源的状态，资源一般有多种状态。引用上面提到的银行流水账单的例子，JSON 形式的表示是它的一种状态，它也可以转变为 XML 形式（状态过渡）。每一种状态由一种 representation 来表示，因此，资源与 representation 是一对多的关系。
</p>

<p>
下文会多次提及到 "current representation"，它反映了资源的<ruby>目前状态<rt>current state</rt></ruby>，怎么理解呢？还是拿账单的例子，假设有两个接口，一个接口 A 用来获取今天的总支出，另一个接口 B 用来提交支出。
</p>

<ul class="org-ul">
<li>第一次调用接口 A，返回总支出为 50 元，50 元反映了该接口所对应的资源的当前状态；</li>
<li>调用接口 B 提交一条支出 5 元的数据，这时数据库新增了一条记录，资源的状态发生改变；</li>
<li>每二次调用接口 A，返回总支出为 55 元，55 元反映了该接口所对应的资源的当前状态；</li>
</ul>

<p>
另外，"current representation" 也可以同时有多个，例如接口 A 默认返回的是文本类型，但它还有一个参数 <code>filetype</code> 可以让接口调用者指定返回的数据类型，例如 JSON，那么，文本类型和 JSON 类型的总支出信息皆为接口 B 所对应的资源的 "current representation"。 
</p>
</blockquote>

<blockquote>
<p>
译注："representation" 由 "representation data" 和 "representation metadata" 组成。"representation data"，即资源本身；而 "representation metadata"，是用来描述 "representation" 的，所以叫作“元数据”。为了表述的准确，以后将不再对 "representation"、"representation data" 以及 "representation metadata" 进行翻译。
</p>
</blockquote>

<blockquote>
<p>
An origin server might be provided with, or be capable of generating, multiple representations that are each intended to reflect the current state of a target resource. In such cases, some algorithm is used by the origin server to select one of those representations as most applicable to a given request, usually based on content negotiation. This "selected representation" is used to provide the data and metadata for evaluating conditional requests [RFC7232] and constructing the payload for 200 (OK) and 304 (Not Modified) responses to GET (<a href="#org479e86d">Section 4.3.1</a>).
</p>
</blockquote>

<p>
<ruby>源服务器<rt>origin server</rt></ruby>可能提供或能够生成多种 representations，每种 representation 旨在反映<ruby>目标资源<rt>target resource</rt></ruby>的当前状态。在这种情况下，源服务器会使用某些算法（通常会基于<ruby>内容协商<rt>content negotiation</rt></ruby>）来选择其中一种对于给定请求来说最适合的 representation。这个“<ruby>已选定的 representation<rt>selected representation</rt></ruby>”是用来为<ruby>评估带条件的请求<rt>evaluating conditional requests</rt></ruby>提供数据和元数据，以及为响应给 GET 请求（<a href="#org479e86d">章节 4.3.1</a>）的 <code>200 (OK)</code> 和 <code>304 (Not Modified)</code> 响应报文构建<ruby>有效载荷<rt>payload</rt></ruby>。
</p>
</div>

<div id="outline-container-orgc098448" class="outline-3">
<h3 id="orgc098448">3.1. 表示元数据 / Representation Metadata</h3>
<div class="outline-text-3" id="text-orgc098448">
<blockquote>
<p>
Representation header fields provide metadata about the representation. When a message includes a payload body, the representation header fields describe how to interpret the representation data enclosed in the payload body. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the payload body if the same request had been a GET.
</p>
</blockquote>

<p>
与 representation 相关的报头域提供了 representation 的元数据。当一个<ruby>报文<rt>message</rt></ruby>包含一个<ruby>有效载荷<rt>payload body</rt></ruby>时，与 representation 相关的报头域描述了如何解释这个封装在有效载荷内的 representation data。在一个回应给 HEAD 请求的响应报文里，与 representation 相关的报头域描述了如果相同的请求是一个 GET 请求的话，将会如何解释这个封装在有效载荷内的 representation data。
</p>

<blockquote>
<p>
The following header fields convey representation metadata:
</p>
</blockquote>

<p>
以下报头域负责传达 representation metadata：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">header Field Name</th>
<th scope="col" class="org-left">Defined in&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Content-Type</td>
<td class="org-left"><a href="#org55c71b5">Section 3.1.1.5</a></td>
</tr>

<tr>
<td class="org-left">Content-Encoding</td>
<td class="org-left"><a href="#org17a1ce7">Section 3.1.2.2</a></td>
</tr>

<tr>
<td class="org-left">Content-Language</td>
<td class="org-left"><a href="#orgea9b8dd">Section 3.1.3.2</a></td>
</tr>

<tr>
<td class="org-left">Content-Location</td>
<td class="org-left"><a href="#org6190703">Section 3.1.4.2</a></td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgfebd6b5" class="outline-4">
<h4 id="orgfebd6b5">3.1.1. 处理表示数据 / Processing Representation Data</h4>
<div class="outline-text-4" id="text-orgfebd6b5">
</div>
<div id="outline-container-org9cacf10" class="outline-5">
<h5 id="org9cacf10"><a id="ID-bc05d462-378f-4743-a1ee-543e01064a09"></a>3.1.1.1. 媒体类型 / Media Type</h5>
<div class="outline-text-5" id="text-org9cacf10">
<blockquote>
<p>
HTTP uses Internet media types [<a href="https://tools.ietf.org/html/rfc2046">RFC2046</a>] in the <code>Content-Type</code> (<a href="#org55c71b5">Section 3.1.1.5</a>) and <code>Accept</code> (<a href="#orgd78f0e9">Section 5.3.2</a>) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with each context in which it is received.
</p>
</blockquote>

<p>
为了提供开放、可扩展的<ruby>数据分类<rt>data typing</rt></ruby>和<ruby>类型协商<rt>type negotiation</rt></ruby>，HTTP 在 <code>Content-Type</code> （<a href="#org55c71b5">章节 3.1.1.5</a>）和 <code>Accept</code> （<a href="#orgd78f0e9">章节 5.3.2</a>）报头域中使用<ruby>互联网媒体类型<rt>Internet media types</rt></ruby><a href="https://tools.ietf.org/html/rfc2046">【RFC2046】</a>。媒体类型定义了数据的格式及其各种处理模型，即如何根据接收数据的各个场景来处理该数据。
</p>

<div class="org-src-container">
<pre class="src src-text">media-type = type "/" subtype *( OWS ";" OWS parameter )
type       = token
subtype    = token
</pre>
</div>

<blockquote>
<p>
The <code>type/subtype</code> <b>MAY</b> be followed by parameters in the form of <code>name=value</code> pairs.
</p>
</blockquote>

<p>
<code>type/subtype</code> 后面 <b>可以</b> 跟着键值对 <code>name=value</code> 形式的多个参数。
</p>

<div class="org-src-container">
<pre class="src src-text">parameter      = token "=" ( token / quoted-string )
</pre>
</div>

<blockquote>
<p>
The <code>type</code>, <code>subtype</code>, and <code>parameter name</code> tokens are case-insensitive. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name. The presence or absence of a parameter might be significant to the processing of a media-type, depending on its definition within the media type registry.
</p>
</blockquote>

<p>
上面 ABNF 列出的规则里，<code>type</code>、<code>subtype</code> 以及 <code>parameter</code> 的 <code>name</code> 这三个 token（标记）是不区分大小写的。<code>parameter</code> 的 <code>value</code> 不一定区分大小写，取决于 <code>parameter</code> 的 <code>name</code> 的语义。一个 <code>parameter</code> 的出现与否可能会对一个媒体类型的处理有重要意义，取决于该 <code>parameter</code> 在<ruby>媒体类型注册表<rt>media type registry</rt></ruby>里的定义。
</p>

<blockquote>
<p>
A parameter value that matches the token production can be transmitted either as a token or within a quoted-string. The quoted and unquoted values are equivalent. For example, the following examples are all equivalent, but the first is preferred for consistency:
</p>
</blockquote>

<p>
如果 <code>parameter</code> 的 <code>value</code> 符合 <a href="RFC7230.html#ID-d0012483-93a3-44cf-b019-29e12725d94a">token</a> 的语法规则的话，那么，它既可以直接作为标记来传输，也可以用在<ruby>双引号字符串<rt>quoted-string</rt></ruby>里。使用双引号包裹与否都是等价的。例如，以下例子都是等价的，但是为了一致性，应优先使用第一种：
</p>

<blockquote>
<p>
译注：token，标记、记号，编程语言中的变量名、常量名就是 token，token 在 ABNF 中有明确的定义，它的命名不能出现某些特殊字符，详情见<a href="RFC7230.html#ID-d0012483-93a3-44cf-b019-29e12725d94a">【RFC7230】章节 3.2.6</a>。
</p>
</blockquote>

<pre class="example">
text/html;charset=utf-8
text/html;charset=UTF-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
</pre>

<blockquote>
<p>
Internet media types ought to be registered with IANA according to the procedures defined in [<a href="https://tools.ietf.org/html/rfc6838">BCP13</a>].
</p>
</blockquote>

<p>
应该按照<a href="https://tools.ietf.org/html/rfc6838">【BCP13】</a>所定义的流程，将<ruby>互联网媒体类型<rt>Internet media types</rt></ruby>注册在 IANA 里。
</p>

<blockquote>
<p>
<b>Note:</b> Unlike some similar constructs in other header fields, media type parameters do not allow whitespace (even "bad" whitespace) around the "=" character.
</p>
</blockquote>

<p>
<b>注意：</b> 不像其他报头域里的某些类似结构，媒体类型的参数不允许在等号（"="）两边带有空格（即使是 <a href="RFC7230.html#ID-f26527b6-d15c-4967-97e3-acc669609481">BWS</a> 也不允许）。
</p>
</div>
</div>

<div id="outline-container-org22f52a6" class="outline-5">
<h5 id="org22f52a6">3.1.1.2. 字符集 / Charset</h5>
<div class="outline-text-5" id="text-org22f52a6">
<blockquote>
<p>
HTTP uses charset names to indicate or negotiate the character encoding scheme of a textual representation [<a href="https://tools.ietf.org/html/rfc2978">RFC6365</a>]. A charset is identified by a case-insensitive token.
</p>
</blockquote>

<p>
HTTP 使用<ruby>字符集名称<rt>charset names</rt></ruby>来指定或协商一个文本类型的 representation 的<ruby>字符编码方案<rt>character encoding scheme</rt></ruby>【<a href="https://tools.ietf.org/html/rfc6365">RFC6365</a>】。字符集由一个不区分大小写的 token 来指定。
</p>

<div class="org-src-container">
<pre class="src src-text">charset = token
</pre>
</div>

<blockquote>
<p>
Charset names ought to be registered in the IANA "Character Sets" registry (<a href="http://www.iana.org/assignments/character-sets">http://www.iana.org/assignments/character-sets</a>) according to the procedures defined in [RFC2978].
</p>
</blockquote>

<p>
应该按照定义在<a href="https://tools.ietf.org/html/rfc2978">【RFC2978】</a>的流程，将<ruby>字符集名称<rt>charset names</rt></ruby>注册在 IANA 的 "Character Sets" 注册表里。
</p>
</div>
</div>

<div id="outline-container-orgff3c076" class="outline-5">
<h5 id="orgff3c076">3.1.1.3. 规范化和文本缺省 / Canonicalization and Text Defaults</h5>
<div class="outline-text-5" id="text-orgff3c076">
<blockquote>
<p>
Internet media types are registered with a canonical form in order to be interoperable among systems with varying native encoding formats. Representations selected or transferred via HTTP ought to be in canonical form, for many of the same reasons described by the Multipurpose Internet Mail Extensions (MIME) [<a href="https://tools.ietf.org/html/rfc2045">RFC2045</a>]. However, the performance characteristics of email deployments (i.e., store and forward messages to peers) are significantly different from those common to HTTP and the Web (server-based information services). Furthermore, MIME's constraints for the sake of compatibility with older mail transfer protocols do not apply to HTTP (see <a href="#orgc9f7ec8">Appendix A</a>).
</p>
</blockquote>

<p>
<ruby>互联网媒体类型<rt>Internet media types</rt></ruby>是使用一种<ruby>规范形式<rt>canonical form</rt></ruby>来注册的，以便于在具有不同本地编码格式的系统之间能够相互操作。经由 HTTP 来选择或传输的 representations 应该使用规范形式，其原因已经在<ruby>多用途互联网邮件扩展<rt>Multipurpose Internet Mail Extensions</rt></ruby>（MIME）【<a href="https://tools.ietf.org/html/rfc2045">RFC2045</a>】里描述过了。然而，电子邮件调度（即存储和转发报文到其他对方）的性能特征跟在 HTTP 和 Web（其于服务器的信息服务）中通用的性能特征有明显的区别。此外，在 MIME 里为了兼容旧的邮件传输协议所设计的约束并不适用于 HTTP（见<a href="#orgc9f7ec8">附录 A</a>）。
</p>

<blockquote>
<p>
译注：canonical form (or normal form, or standard form) 的解释见 <a href="https://en.wikipedia.org/wiki/Canonical_form">wikipedia: Canonical form</a>。
</p>
</blockquote>

<blockquote>
<p>
MIME's canonical form requires that media subtypes of the "text" type use <code>CRLF</code> as the text line break. HTTP allows the transfer of text media with plain <code>CR</code> or <code>LF</code> alone representing a line break, when such line breaks are consistent for an entire representation. An HTTP sender <b>MAY</b> generate, and a recipient <b>MUST</b> be able to parse, line breaks in text media that consist of <code>CRLF</code>, bare <code>CR</code>, or bare <code>LF</code>. In addition, text media in HTTP is not limited to charsets that use octets 13 and 10 for <code>CR</code> and <code>LF</code>, respectively. This flexibility regarding line breaks applies only to text within a representation that has been assigned a "text" media type; it does not apply to "multipart" types or HTTP elements outside the payload body (e.g., header fields).
</p>
</blockquote>

<p>
MIME 的规范形式要求文本（"text"）类型媒体的子类型使用 <code>CRLF</code> 来作为换行符。HTTP 允许文本类型媒体单独使用 <code>CR</code> 或者 <code>LF</code> 来表示一个换行符，只要求所使用的换行符在整个 representation 中是统一的。HTTP 发送端 <b>可以</b> 在文本类型媒体中生成由 <code>CRLF</code>、或者单纯是 <code>CR</code>、或者单纯是为 <code>LF</code> 组成的换行符。HTTP 接收端 <b>必须</b> 能够解析文本类型媒体中的由 <code>CRLF</code>、或者单纯是 <code>CR</code>、或者单纯是 <code>LF</code> 组成的换行符。而且，在 HTTP 里的文本类型媒体并不限于使用 13 作为 <code>CR</code>，10 作为 <code>LF</code> 的字符集。这种对于换行符的灵活性仅适用于一个声明为 "text" 媒体类型的 representation 以内的文本，它并不适用于 "multipart" 类型，也不适用于有效载荷以外的 HTTP 元素（例如，报头域）。
</p>

<blockquote>
<p>
If a representation is encoded with a content-coding, the underlying data ought to be in a form defined above prior to being encoded.
</p>
</blockquote>

<p>
如果一个 representation 使用了一种<ruby>内容编码值<rt>content-coding</rt></ruby>来编码，<ruby>基础数据<rt>underlying data</rt></ruby>应该在编码之前处于上述定义的那种规范形式。
</p>

<blockquote>
<p>
译注："underlying data" 译为基础数据，指的是在编码之前的原始数据。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org9d24f7a" class="outline-5">
<h5 id="org9d24f7a">3.1.1.4. Multipart 类型 / Multipart Types</h5>
<div class="outline-text-5" id="text-org9d24f7a">
<p>
MIME provides for a number of "multipart" types — encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in <a href="https://tools.ietf.org/html/rfc2046#section-5.1.1">Section 5.1.1</a> of [RFC2046], and include a <code>boundary</code> parameter as part of the media type value. The message body is itself a protocol element; a sender <b>MUST</b> generate only <code>CRLF</code> to represent line breaks between body parts.
</p>

<p>
MIME 提供了大量的 "multipart" 类型，即在单独一个<ruby>报文正文<rt>message body</rt></ruby>里封装了一个或多个 representations。所有 multipart 类型共享一个通用的句法（见<a href="https://tools.ietf.org/html/rfc2046#section-5.1.1">【RFC2046】章节 5.1.1</a>），并且包含一个 <code>boundary</code> 参数作为媒体类型的值的一部分。报文正文本身就是一个协议元素，发送端 <b>必须</b> 在报文正文的各个<ruby>分部<rt>parts</rt></ruby>之间仅生成 <code>CRLF</code> 来表示换行符。
</p>

<blockquote>
<p>
译注：multipart 允许在一个报文正文里包含多个 representation，每个 representation 之间使用 <code>boundary</code> 所指定的定界符来分隔，这样就使得报文正文被分割为多个分部，分部与分部之间的内容仍然只能使用 <code>CRLF</code> 作为换行符。multipart 的一个例子可以参考<a href="https://tools.ietf.org/html/rfc2049#page-15">【RFC2049】附录 A</a>。
</p>
</blockquote>

<p>
HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the payload. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in [<a href="https://tools.ietf.org/html/rfc2388">RFC2388</a>], and the "multipart/byteranges" type is defined by this specification for use in some <code>206 (Partial Content)</code> responses [<a href="https://tools.ietf.org/html/rfc7233">RFC7233</a>].
</p>

<p>
HTTP <ruby>报文分帧<rt>message framing</rt></ruby> 并不会使用 multipart 的 <code>boundary</code> 作为报文正文长度的一个标识符，虽然它可能被<ruby>实现<rt>implementations</rt></ruby>用于生成或处理有效载荷。例如，"multipart/form-data" 类型通常用于在一个请求里携带表单数据，如【<a href="https://tools.ietf.org/html/rfc2388">RFC2388</a>】所述。"multipart/byteranges" 类型是由本规范所定义的，用在某些 <code>206 (Partial Content)</code> 响应里【<a href="https://tools.ietf.org/html/rfc7233">RFC7233</a>】。
</p>
</div>
</div>

<div id="outline-container-org55c71b5" class="outline-5">
<h5 id="org55c71b5"><a id="ID-fcfdf1e4-f733-4305-9ad4-761271a3dd69"></a>3.1.1.5. Content-Type</h5>
<div class="outline-text-5" id="text-org55c71b5">
<blockquote>
<p>
The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by <code>Content-Encoding</code> are decoded.
</p>
</blockquote>

<p>
<code>Content-Type</code> 报头域指明了它所关联的 representation 的媒体类型。所述“关联的 representation”，要不是封装在报文有效载荷内的 representation，要不是已选定的 representation，由报文语义所决定。 <code>Content-Type</code> 所指定的媒体类型定义了 representation 的数据格式以及期望该数据被接收端如何处理，在该报文的语义范围之内，在依照 <code>Content-Encoding</code> 里的所有内容编码进行解码之后。
</p>

<div class="org-src-container">
<pre class="src src-text">Content-Type = media-type
</pre>
</div>

<blockquote>
<p>
Media types are defined in <a href="#org9cacf10">Section 3.1.1.1</a>. An example of the field is
</p>
</blockquote>

<p>
媒体类型定义在<a href="#org9cacf10">章节 3.1.1.1</a>。以下是 <code>Content-Type</code> 报头域的一个例子：
</p>

<div class="org-src-container">
<pre class="src src-text">Content-Type: text/html; charset=ISO-8859-4
</pre>
</div>

<blockquote>
<p>
A sender that generates a message containing a payload body <b>SHOULD</b> generate a <code>Content-Type</code> header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a <code>Content-Type</code> header field is not present, the recipient <b>MAY</b> either assume a media type of "application/octet-stream" ([RFC2046], <a href="https://tools.ietf.org/html/rfc2046#section-4.5.1">Section 4.5.1</a>) or examine the data to determine its type.
</p>
</blockquote>

<p>
如果发送端所生成的报文包含有一个有效载荷，那么发送端 <b>应当</b> 在该报文里生成一个 <code>Content-Type</code> 报头域，除非它并不知道应该对封装在有效载荷内的 representation 的指定哪一种媒体类型。如果没有出现 <code>Content-Type</code> 报头域，接收端 <b>可以</b> 要不假定为 "application/octet-stream" 媒体类型（<a href="https://tools.ietf.org/html/rfc2046#section-4.5.1">【RFC2046】章节 4.5.1</a>），要不检查该数据来确定它的媒体类型。
</p>

<blockquote>
<p>
In practice, resource owners do not always properly configure their origin server to provide the correct <code>Content-Type</code> for a given representation, with the result that some clients will examine a payload's content and override the specified type. Clients that do so risk drawing incorrect conclusions, which might expose additional security risks (e.g., "privilege escalation"). Furthermore, it is impossible to determine the sender's intent by examining the data format: many data formats match multiple media types that differ only in processing semantics. Implementers are encouraged to provide a means of disabling such "content sniffing" when it is used.
</p>
</blockquote>

<p>
实际上，<ruby>资源所有者<rt>resource owners</rt></ruby>并不总是能恰当地配置它们的源服务器来为一个给定的 representation 提供正确的 <code>Content-Type</code>，出于这种原因，某些客户端会检查有效载荷的内容然后<ruby>重写<rt>override</rt></ruby>指定的类型。但是，客户端这样做可能会得出错误的论断，从而可能会暴露出额外的安全风险（例如，<ruby>特权提升<rt>privilege escalation</rt></ruby>）。而且，通过检查数据格式是不可能确定发送端的真正意图的，这是由于某些数据格式能够匹配多种媒体类型，而仅在语义处理会有所不同。鼓励实现者提供一种方法，当启用这种方法的时候可以禁用上述这种“<ruby>内容嗅探<rt>content sniffing</rt></ruby>”。
</p>

<blockquote>
<p>
译注：特权提升的详细介绍见 <a href="https://en.wikipedia.org/wiki/Privilege_escalation">Wikipedia: Privilege escalation</a> 或者 <a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E6%9D%83%E6%8F%90%E5%8D%87">维基百科（中文）</a>。
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org3e2d9f7" class="outline-4">
<h4 id="org3e2d9f7">3.1.2. 为压缩或完整性而编码 / Encoding for Compression or Integrity</h4>
<div class="outline-text-4" id="text-org3e2d9f7">
</div>
<div id="outline-container-org72efdb3" class="outline-5">
<h5 id="org72efdb3">3.1.2.1. Content Codings</h5>
<div class="outline-text-5" id="text-org72efdb3">
<blockquote>
<p>
Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.
</p>
</blockquote>

<p>
content coding 的值指明了一种已经或能够应用到一个 representation 的<ruby>编码转换<rt>encoding transformation</rt></ruby>。content coding 主要用来允许在没有丢失 representation 之前的媒体类型的身份以及没有丢失信息的情况下，对该 representation 进行压缩或者进行其他方式的转换。representation 常常被存储为<ruby>编码过的形式<rt>code form</rt></ruby>，然后将其直接进行传输，最后仅到达最终接收端才会进行解码。
</p>

<blockquote>
<p>
译文：本译文将 "encoding" 翻译为“编码”，为了与之区分，不会对 "content coding" 进行翻译（实际上是我不知道怎么翻译才好，意会，意会）。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">content-coding   = token
</pre>
</div>

<blockquote>
<p>
All content-coding values are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as defined in <a href="#orgb8f27ff">Section 8.4</a>. They are used in the <code>Accept-Encoding</code> (<a href="#org6451ddf">Section 5.3.4</a>) and <code>Content-Encoding</code> (<a href="#org17a1ce7">Section 3.1.2.2</a>) header fields.
</p>
</blockquote>

<p>
所有 <code>content-coding</code> 的值都是不区分大小写的，并且应该注册到 "HTTP Content Coding Registry" 注册表里，如<a href="#orgb8f27ff">章节 8.4</a> 所述。它们用在 <code>Accept-Encoding</code> （<a href="#org6451ddf">章节 5.3.4</a>）和 <code>Content-Encoding</code> （<a href="#org17a1ce7">章节 3.1.2.2</a>）报头域里。
</p>

<blockquote>
<p>
The following content-coding values are defined by this specification:
</p>
<ul class="org-ul">
<li>compress (and x-compress): See <a href="RFC7230.html#ID-a785a05f-6fdc-44d8-9343-3a66a49cb655">Section 4.2.1</a> of [RFC7230].</li>
<li>deflate: See <a href="RFC7230.html#ID-fa7b432f-071b-4e26-9d2c-8fc1b95b6b64">Section 4.2.2</a> of [RFC7230].</li>
<li>gzip (and x-gzip): See <a href="RFC7230.html#ID-d1579c8b-312c-414b-b421-960669b0d389">Section 4.2.3</a> of [RFC7230].</li>
</ul>
</blockquote>

<p>
本规范定义了以下 <code>content-coding</code> 值：
</p>
<ul class="org-ul">
<li>compress（以及 x-compress）：见<a href="RFC7230.html#ID-a785a05f-6fdc-44d8-9343-3a66a49cb655">【RFC7230】章节 4.2.1</a>。</li>
<li>deflate：见<a href="RFC7230.html#ID-fa7b432f-071b-4e26-9d2c-8fc1b95b6b64">【RFC7230】章节4.2.2</a>。</li>
<li>gzip（以及 x-gzip）：<a href="RFC7230.html#ID-d1579c8b-312c-414b-b421-960669b0d389">【RFC7230】见章节 4.2.3</a>。</li>
</ul>
</div>
</div>

<div id="outline-container-org17a1ce7" class="outline-5">
<h5 id="org17a1ce7"><a id="ID-a10adb00-e955-42a6-8d28-ed6f942db085"></a>3.1.2.2. Content-Encoding</h5>
<div class="outline-text-5" id="text-org17a1ce7">
<blockquote>
<p>
The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the <code>Content-Type</code> header field. <code>Content-Encoding</code> is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
</p>
</blockquote>

<p>
<code>Content-Encoding</code> 报头域指明了已经对 representation 应用了哪些突破其固有的媒体类型的 content codings，因此得知，为了获得 <code>Content-Type</code> 报头域所提及的那种媒体类型的数据，需要应用哪一种解码机制。<code>Content-Encoding</code> 主要用来允许在没有丢失 representation 之前的媒体类型的身份的情况下，对一个 representation 的数据进行压缩。
</p>

<div class="org-src-container">
<pre class="src src-text">Content-Encoding = 1#content-coding
</pre>
</div>

<blockquote>
<p>
An example of its use is
</p>
</blockquote>

<p>
它的用法见下面这个例子：
</p>

<pre class="example">
Content-Encoding: gzip
</pre>

<blockquote>
<p>
If one or more encodings have been applied to a representation, the sender that applied the encodings <b>MUST</b> generate a <code>Content-Encoding</code> header field that lists the content codings in the order in which they were applied. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
</p>
</blockquote>

<p>
如果对一个 representation 应用了一种或多种编码，应用这些编码的发送端 <b>必须</b> 生成一个 <code>Content-Encoding</code> 报头域，以它们被应用的先后顺序来一一列出对应的 content codings。如果某种编码需要附带额外的参数信息，可以由其他未在本规范上定义过的报头域来提供。
</p>

<blockquote>
<p>
Unlike <code>Transfer-Encoding</code> (<a href="RFC7230.html#ID-1754823B-D0BC-410F-A17B-E7ADA1AA79BC">Section 3.3.1</a> of [RFC7230]), the codings listed in <code>Content-Encoding</code> are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.
</p>
</blockquote>

<p>
不像 <code>Transfer-Encoding</code> （<a href="RFC7230.html#ID-1754823B-D0BC-410F-A17B-E7ADA1AA79BC">【RFC7230】章节 3.3.1</a>），列在 <code>Content-Encoding</code> 报头域上的 codings 是 representation 的特性。representation 是依据其编码过的形式来进行定义的，除非在元数据的定义中另有注明，所有其他关于 representation 的元数据是对该形式进行描述的。通常，representation 仅在渲染呈现或类似的用途之前才会被解码。
</p>

<blockquote>
<p>
If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in <code>Content-Encoding</code> even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of <code>Content-Type</code> or <code>Content-Encoding</code>, since some user agents will behave differently in their handling of each response (e.g., open a "Save as &#x2026;" dialog instead of automatic decompression and rendering of content).
</p>
</blockquote>

<p>
如果媒体类型包含有一种<ruby>固有的编码<rt>inherent encoding</rt></ruby>，例如一种总是以压缩方式来表示的数据格式，那么，这种编码不要在 <code>Content-Encoding</code> 里重申，哪怕它恰巧与其中一个 content codings 的算法一致。这种 content coding 只会在以下这种情况下才需要在 <code>Content-Encoding</code> 列出：出于某些怪异的原因，需要应用该 content coding 两次才能形成正确的 representation。同样，原服务器可能选择将该同样的数据作为<ruby>多种 representations<rt>multiple representations</rt></ruby> 来发布，其区别仅在于 coding 是作为 Content-Type 的一部分还是作为 Content-Encoding 的一部分 ，这是因为某些用户代理处理各个响应的行为会有所不同（例如，打开一个“另存为&#x2026;”对话框，而不是自动解缩并渲染内容）。
</p>

<blockquote>
<p>
An origin server <b>MAY</b> respond with a status code of <code>415 (Unsupported Media Type)</code> if a representation in the request message has a content coding that is not acceptable.
</p>
</blockquote>

<p>
如果请求报文里的某个 representation 应用了服务器不支持的 content coding，源服务器 <b>可以</b> 以 <code>415 (Unsupported Media Type)</code> 作为响应。
</p>
</div>
</div>
</div>

<div id="outline-container-orgb14a20b" class="outline-4">
<h4 id="orgb14a20b">3.1.3. 受众语言 / Audience Language</h4>
<div class="outline-text-4" id="text-orgb14a20b">
</div>
<div id="outline-container-org2f3fd1f" class="outline-5">
<h5 id="org2f3fd1f"><a id="ID-0a52652d-e5e8-40f9-ba1a-f96c45969b85"></a>3.1.3.1. 语言标签 / Language Tags</h5>
<div class="outline-text-5" id="text-org2f3fd1f">
<blockquote>
<p>
A language tag, as defined in [<a href="https://tools.ietf.org/html/rfc5646">RFC5646</a>], identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.
</p>
</blockquote>

<p>
正如【<a href="https://tools.ietf.org/html/rfc5646">RFC5646</a>】所定义，<ruby>语言标签<rt>language tag</rt></ruby>标识了一种人类出于交流信息的目的而通过说、写或其他方式来传达的自然语言。计算机语言被明确排除在外。
</p>

<blockquote>
<p>
HTTP uses language tags within the <code>Accept-Language</code> and <code>Content-Language</code> header fields. <code>Accept-Language</code> uses the broader <code>language-range</code> production defined in Section 5.3.5, whereas <code>Content-Language</code> uses the <code>language-tag</code> production defined below.
</p>
</blockquote>

<p>
HTTP 在 <code>Accept-Language</code> 和 <code>Content-Language</code> 报头域里使用语言标签。<code>Accept-Language</code> 使用了更广义的 <code>language-range</code> 规则（定义在章节 5.3.5），而 <code>Content-Language</code> 使用了 <code>language-tag</code> 规则，其定义如下：
</p>

<div class="org-src-container">
<pre class="src src-text">language-tag = &lt;Language-Tag, see [RFC5646], Section 2.1&gt;
</pre>
</div>

<blockquote>
<p>
A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada). Whitespace is not allowed within a language tag. Example tags include:
</p>
</blockquote>

<p>
一个<ruby>语言标签<rt>language tag</rt></ruby>是由一个或多个不区分大小写的子标签组成的，每个子标签之间使用连接符（"-"，"%x2D"）分隔。大多数情况下，一个语言标签包含一个标识了某种关联语系的<ruby>主要语言子标签<rt>primary language subtag</rt></ruby>（例如，"en" 代表<ruby>英语<rt>English</rt></ruby>），另外还可以选择性地在其后面附加一连串的子标签来优化或缩小语言范围（例如，"en-CA" 代表一种<ruby>加拿大<rt>Canada</rt></ruby>英语）。语言标签里不允许存在空格。语言标签的几个例子如下：
</p>

<pre class="example">
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</pre>

<blockquote>
<p>
See [<a href="https://tools.ietf.org/html/rfc5646">RFC5646</a>] for further information.
</p>
</blockquote>

<p>
更多信息见【<a href="https://tools.ietf.org/html/rfc5646">RFC5616</a>】。
</p>
</div>
</div>

<div id="outline-container-orgea9b8dd" class="outline-5">
<h5 id="orgea9b8dd"><a id="ID-80f3e8e8-dabb-49b8-b7e6-45f83648a732"></a>3.1.3.2. Content-Language</h5>
<div class="outline-text-5" id="text-orgea9b8dd">
<blockquote>
<p>
The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.
</p>
</blockquote>

<p>
<code>Content-Language</code> 报头域描述了 representation 的目标受众的（一种或多种）自然语言。需要注意的是，它可能并不等价于用在 representation 里的所有语言。
</p>

<div class="org-src-container">
<pre class="src src-text">Content-Language = 1#language-tag
</pre>
</div>

<blockquote>
<p>
Language tags are defined in <a href="#org2f3fd1f">Section 3.1.3.1</a>. The primary purpose of <code>Content-Language</code> is to allow a user to identify and differentiate representations according to the users' own preferred language. Thus, if the content is intended only for a Danish-literate audience, the appropriate field is
</p>
</blockquote>

<p>
<ruby>语言标签<rt>language tag</rt></ruby>定义在<a href="#org2f3fd1f">章节 3.1.3.1</a> 里。<code>Content-Language</code> 的主要目的是让用户能够依据自身的首选语言来标识和区分 representations。所以，如果只想将<ruby>懂丹麦语<rt>Danish-literate</rt></ruby>的人作为内容的目标受众，那么报头域可以这样设置：
</p>

<pre class="example">
Content-Language: da
</pre>

<blockquote>
<p>
If no <code>Content-Language</code> is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
</p>
</blockquote>

<p>
如果没有指定 <code>Content-Language</code> 报头域，那么就默认内容是面向所有语言受众的。这可能意味着发送端并不认为它自已是面向具体任一种自然语言的，或者发送端并不知道它自己打算使用哪一种语言。
</p>

<blockquote>
<p>
Multiple languages <b>MAY</b> be listed for content that is intended for multiple audiences. For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for
</p>
</blockquote>

<p>
对于面向多种受众的内容，<b>可以</b> 在 <code>Content-Language</code> 列出多种语言，多种语言，例如，一份“<ruby>怀唐伊条约<rt>Treaty of Waitangi</rt></ruby>”的译文，会同时出现<ruby>毛利语原文<rt>original Maori</rt></ruby>以及英文版本，那么可以这样设置：
</p>

<pre class="example">
Content-Language: mi, en
</pre>

<blockquote>
<p>
However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the <code>Content-Language</code> would properly only include "en".
</p>
</blockquote>

<p>
然而，只因为在一个 representation 里出现了多种语言就认为它是打算面向认识多种语言的受众，这是错误的。举个例子，一本面向新手的语言入门读物，就称为《第一堂拉丁语课》吧，是明确打算面向懂英语的读者的，那么，最恰当的做法是 <code>Content-Language</code> 只包含 "en"。
</p>

<blockquote>
<p>
<code>Content-Language</code> <b>MAY</b> be applied to any media type — it is not limited to textual documents.
</p>
</blockquote>

<p>
<code>Content-Language</code> 可以应用于任意<ruby>媒体类型<rt>media type</rt></ruby> 的 representation 里，也就是说，它并不仅限于<ruby>文本类的文档<rt>textual documents</rt></ruby>。
</p>
</div>
</div>
</div>

<div id="outline-container-org7d8ba38" class="outline-4">
<h4 id="org7d8ba38">3.1.4. 标识 / Identification</h4>
<div class="outline-text-4" id="text-org7d8ba38">
</div>
<div id="outline-container-orgc47d26b" class="outline-5">
<h5 id="orgc47d26b">3.1.4.1. 标识一个 Representation / Identifying a Representation</h5>
<div class="outline-text-5" id="text-orgc47d26b">
<blockquote>
<p>
When a complete or partial representation is transferred in a message payload, it is often desirable for the sender to supply, or the recipient to determine, an identifier for a resource corresponding to that representation.
</p>
</blockquote>

<p>
当一个完整的或部分的 representation 被传入到一个<ruby>报文的有效载荷<rt>message payload</rt></ruby>里，该 representation 所对应的资源标识符通常交由发送端去提供，或者交由接收端去决定会更好一些。
</p>

<blockquote>
<p>
For a request message:
</p>
<ul class="org-ul">
<li>If the request has a <code>Content-Location</code> header field, then the sender asserts that the payload is a representation of the resource identified by the <code>Content-Location</code> field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification). The information might still be useful for revision history links.</li>
<li>Otherwise, the payload is unidentified.</li>
</ul>
</blockquote>

<p>
对于一个请求报文来说：
</p>
<ul class="org-ul">
<li><b>如果</b> 该请求有一个 <code>Content-Location</code> 报头域，意味着发送端<ruby>断言<rt>assert</rt></ruby>请求报文的有效载荷是某个资源的一个 representation，而该资源是由 <code>Content-Location</code> 的值所标识的。但是，除非这种<ruby>断言<rt>assertion</rt></ruby>能够通过其他途径（本规则并没有定义有什么途径）来验证，否则不能相信该断言。对于修正历史链接，该信息还是有用的。</li>
<li><b>否则</b>，该请求报文的有效载荷是<ruby>未标识<rt>unidentified</rt></ruby>的。</li>
</ul>

<blockquote>
<p>
For a response message, the following rules are applied in order until a match is found:
</p>
<ol class="org-ol">
<li>If the request method is GET or HEAD and the response status code is <code>200 (OK)</code>, <code>204 (No Content)</code>, <code>206 (Partial Content)</code>, or <code>304 (Not Modified)</code>, the payload is a representation of the resource identified by the effective request URI (<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">Section 5.5</a> of [RFC7230]).</li>
<li>If the request method is GET or HEAD and the response status code is <code>203 (Non-Authoritative Information)</code>, the payload is a potentially modified or enhanced representation of the target resource as provided by an intermediary.</li>
<li>If the response has a <code>Content-Location</code> header field and its field-value is a reference to the same URI as the effective request URI, the payload is a representation of the resource identified by the effective request URI.</li>
<li>If the response has a <code>Content-Location</code> header field and its field-value is a reference to a URI different from the effective request URI, then the sender asserts that the payload is a representation of the resource identified by the <code>Content-Location</code> field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification).</li>
<li>Otherwise, the payload is unidentified.</li>
</ol>
</blockquote>

<p>
对于一个响应报文来说，以下规则会被按顺序应用，直到匹配其中之一：
</p>
<ol class="org-ol">
<li><b>如果</b> 请求方法是 GET 或者 HEAD，且响应状态码是 <code>200 (OK)</code>、<code>204 (No Content)</code>、<code>206 (Partial Content)</code> 或者 <code>304 (Not Modified)</code>，那么，响应报文的有效载荷是某个资源的 representation，而该资源是由<ruby>有效请求 URI<rt>effective request URI</rt></ruby> 所标识的（<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">【RFC7230】章节 5.5</a>）。</li>
<li><b>如果</b> 请求方法是 GET 或者 HEAD，且响应状态码是 <code>203 (Non-Authoritative Information)</code>，那么，响应报文的有效载荷是某个资源的 可能已被修改过或增强过的 representation，该 representation 由某个中间人提供。</li>
<li><b>如果</b> 响应带有一个 <code>Content-Location</code> 报头域并且它的域值是一个跟<ruby>有效请求 URI<rt>effective request URI</rt></ruby> 相同的 URI 引用，那么，响应报文的有效载荷是某个资源的 representation，而该资源是由有效请求 URI 所标识的。</li>
<li><b>如果</b> 响应带有一个 <code>Content-Location</code> 报头域并且它的域值是一个跟<ruby>有效请求 URI<rt>effective request URI</rt></ruby> 不相同的 URI 引用，那么，发送端断言该有效载荷是某个资源的 representation，而该资源是由 <code>Content-Location</code> 的域值所标识的。但是，除非这种<ruby>断言<rt>assertion</rt></ruby>能够通过其他途径（本规则并没有定义有什么途径）来验证，否则不能相信该断言。</li>
<li><b>否则</b>，该响应报文的有效载荷是未标识的。</li>
</ol>
</div>
</div>

<div id="outline-container-org6190703" class="outline-5">
<h5 id="org6190703"><a id="ID-91650144-4bfc-4362-b628-f96578a5c756"></a>3.1.4.2. Content-Location</h5>
<div class="outline-text-5" id="text-org6190703">
<blockquote>
<p>
The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a 200 (OK) response would contain the same representation that is enclosed as payload in this message.
</p>
</blockquote>

<p>
<code>Content-Location</code> 报头域是一个 URI，该 URI 能够用于作为一个与封装在报文有效载荷内的 representation 所对应的具体资源的标识符。换句话说，如果某个用户代理对这个 URI 执行了 GET 请求，那么会回应一个 <code>200 (OK)</code> 响应报文，该响应报文的有效载荷会封装相同的 representation。
</p>

<div class="org-src-container">
<pre class="src src-text">Content-Location = absolute-URI / partial-URI
</pre>
</div>

<blockquote>
<p>
The <code>Content-Location</code> value is not a replacement for the effective Request URI (<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">Section 5.5</a> of [RFC7230]). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in <a href="https://tools.ietf.org/html/rfc2557#section-4">Section 4</a> of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.
</p>
</blockquote>

<p>
<code>Content-Location</code> 的值并不是用来替换<ruby>有效请求 URI<rt>effective request URI</rt></ruby>（<a href="RFC7230.html#ID-3265c21d-0d3b-4776-8e28-38278d168779">【RFC7230】章节 5.5</a>）的。它是一个 representation metadata。它具有与定义在 MIME 的同名报头域（<a href="https://tools.ietf.org/html/rfc2557#section-4">【RFC2557】章节 4</a>）相同的句法和语义。但是，这个报头域出现在一个 HTTP 报头里是具有特殊含义的。
</p>

<blockquote>
<p>
If <code>Content-Location</code> is included in a <code>2xx (Successful)</code> response message and its value refers (after conversion to absolute form) to a URI that is the same as the effective request URI, then the recipient <b>MAY</b> consider the payload to be a current representation of that resource at the time indicated by the message origination date. For a GET (<a href="#org479e86d">Section 4.3.1</a>) or HEAD (<a href="#org607980d">Section 4.3.2</a>) request, this is the same as the default semantics when no <code>Content-Location</code> is provided by the server. For a state-changing request like PUT (<a href="#org2e14fb1">Section 4.3.4</a>) or POST (<a href="#org24c5a01">Section 4.3.3</a>), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.
</p>
</blockquote>

<p>
如果 <code>Content-Location</code> 被包含在一个 <code>2xx (Successful)</code> 响应报文里，且它的值指向于（在转换为<ruby>绝对形式<rt>absolute form</rt></ruby>之后）一个与有效请求 URI 相同的 URI，那么，接收端 <b>可以</b> 将该有效载荷认为是一个在特定时间里的资源的 current representation，所述特定时间是由<ruby>报文始发日期<rt>message origination date</rt></ruby>所指定的时间。对于 GET（<a href="#org479e86d">章节 4.3.1</a>）或者 HEAD（<a href="#org607980d">章节 4.3.2</a>）请求来说，这与在服务器没有提供 <code>Content-Location</code> 报头域的情况下的默认语义相一致。对于类似 PUT（<a href="#org2e14fb1">章节 4.3.4</a>）或者 POST（<a href="#org24c5a01">章节 4.3.3</a>）这些会<ruby>改变状态<rt>state-changing</rt></ruby>的请求来说，这意味着服务器的响应包含了该资源的新的 representation，由此与那些只报告动作方面的信息（例如，“<ruby>它生效了！<rt>It worked!</rt></ruby>”）的 representations 作区分。让编辑程序能够在不需要再次发起 GET 请求就可以更新它们的本地副本。
</p>

<blockquote>
<p>
If <code>Content-Location</code> is included in a <code>2xx (Successful)</code> response message and its field-value refers to a URI that differs from the effective request URI, then the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.
</p>
<ul class="org-ul">
<li>For a response to a GET or HEAD request, this is an indication that the effective request URI refers to a resource that is subject to content negotiation and the <code>Content-Location</code> field-value is a more specific identifier for the selected representation.</li>
<li>For a <code>201 (Created)</code> response to a state-changing method, a <code>Content-Location</code> field-value that is identical to the <code>Location</code> field-value indicates that this payload is a current representation of the newly created resource.</li>
<li>Otherwise, such a <code>Content-Location</code> indicates that this payload is a representation reporting on the requested action's status and that the same report is available (for future access with GET) at the given URI. For example, a purchase transaction made via a POST request might include a receipt document as the payload of the <code>200 (OK)</code> response; the <code>Content-Location</code> field-value provides an identifier for retrieving a copy of that same receipt in the future.</li>
</ul>
</blockquote>

<p>
如果 <code>Content-Location</code> 被包含在一个 <code>2xx (Successful)</code> 响应报文里，且它的域值指向于一个与有效请求 URI 不相同的 URI，那么，源服务器<ruby>声称<rt>claim</rt></ruby>该 URI 是一个与封装在该有效载荷内的 representation 相对应的不同资源的标识符。这种声称只能在这两个标识符具有相同的资源所有者，且该资源所有者不能经由 HTTP 以编程方式来确定的情况下才能被相信。
</p>
<ul class="org-ul">
<li>对于回应给 GET 或 HEAD 请求的一个响应，它表明了<ruby>有效请求 URI<rt>effective request URI</rt></ruby> 指向到一个服从<ruby>内容协商<rt>content negotiation</rt></ruby>的资源，并且针对<ruby>已选定的 representation<rt>selective representation</rt></ruby>  来说，<code>Content-Location</code> 的域值是一个更加具体的标识符。</li>
<li>对于回应给<ruby>会改变资源状态的请求方法<rt>state-changing method</rt></ruby>的一个 <code>201 (Created)</code> 响应，如果 <code>Content-Location</code> 的域值与 <code>Location</code> 的域值相同，那么，这表明这个有效载荷是新近被创建的资源的<ruby>当前 representation<rt>current representation</rt></ruby>。</li>
<li>否则，这个 <code>Content-Location</code> 表明了这个有效载荷是一个对所请求的动作的状态方面进行报告的 representation，且对于给定的 URI ，同样的报告是可供使用的（用于将来 GET 请求对 representation 进行访问）。例如，一个经由 POST 请求而产生的购买交易可能包含一个以一份收款凭据作为 <code>200 (OK)</code> 响应的有效载荷，<code>Content-Location</code> 的域值提供了一个标识符，用于将来重新获取这份收款凭据的一个备份。</li>
</ul>

<blockquote>
<p>
A user agent that sends <code>Content-Location</code> in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.
</p>
</blockquote>

<p>
用户代理在其发送的请求报文里带有 <code>Content-Location</code> 是想表达它的域值里的 URI 指的是用户代理最开始是在哪里获得这个封装在有效载荷内的 representation 的内容的（在该用户代理对这个 representation 所作的任何更改之前）。也就是说，该用户代理提供了一种对于原始 representation 的<ruby>来源<rt>source</rt></ruby>的<ruby>反向链接<rt>back link</rt></ruby><sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>。
</p>

<blockquote>
<p>
An origin server that receives a <code>Content-Location</code> field in a request message <b>MUST</b> treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server <b>MAY</b> use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server <b>MUST NOT</b> use such context information to alter the request semantics.
</p>
</blockquote>

<p>
源服务器在一个请求报文中接收到 <code>Content-Location</code> 报头域的时候，<b>必须</b> 将该报头域的信息作为<ruby>暂时的请求上下文<rt>transitory request context</rt></ruby>来对待，而不是作为 representation metadata 来逐字保存。源服务器 <b>可以</b> 使用该上下文来指导请求的处理，或者将其保存起来留作其他用途，例如，用于<ruby>来源链接<rt>source links</rt></ruby>或<ruby>元数据的版本管理<rt>versioning metadata</rt></ruby>。但是，源服务器 <b>禁止</b> 使用这种上下文信息来改变该请求的语义。
</p>

<blockquote>
<p>
For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the <code>Content-Location</code> cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the <code>Content-Location</code> URI.
</p>
</blockquote>

<p>
例如，如果一个客户端对一个<ruby>协商过的资源<rt>negotiated resource</rt></ruby>发起一个 PUT 请求，并且源服务器接受了这个 PUT（没有经过<ruby>重定向<rt>redirection</rt></ruby>），那么，资源的新状态预期将与提供自该 PUT 请求的 representation 相一致；PUT 请求里的 <code>Content-Location</code> 报头域不能当作是一种<ruby>反向内容选择标识符<rt>reverse content selection identifier</rt></ruby>来仅对协商的 representations 中的其中一种进行更新。如果客户端想要后者这种语义，它可以直接对 <code>Content-Location</code> 的 URI 应用 PUT 请求。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd26c42d" class="outline-3">
<h3 id="orgd26c42d">3.2. 表示数据 / Representation Data</h3>
<div class="outline-text-3" id="text-orgd26c42d">
<blockquote>
<p>
The representation data associated with an HTTP message is either provided as the payload body of the message or referred to by the message semantics and the effective request URI. The representation data is in a format and encoding defined by the representation metadata header fields.
</p>
</blockquote>

<p>
一个 HTTP 报文相关联的 representation data 或者提供作为报文有效载荷，或者通过报文的语义和有效请求 URI 来引用它。representation data 是处于某种格式和编码中，这种格式和编码由 representation metadata 相关的报头域来定义。
</p>

<blockquote>
<p>
The data type of the representation data is determined via the header fields <code>Content-Type</code> and <code>Content-Encoding</code>. These define a two-layer, ordered encoding model:
</p>
</blockquote>

<p>
representation data 的数据类型是经由 <code>Content-Type</code> 和 <code>Content-Encoding</code> 报头域决定的。它们共同定义了一种<ruby>双层的、顺序编码的模型<rt>two-layer, ordered encoding model</rt></ruby>：
</p>

<div class="org-src-container">
<pre class="src src-text">representation-data := Content-Encoding( Content-Type( bits ) )
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3d98f9" class="outline-3">
<h3 id="orgb3d98f9"><a id="ID-4c395bab-baa6-4895-b677-5daa1584da6e"></a>3.3. 有效载荷的语义 / Payload Semantics</h3>
<div class="outline-text-3" id="text-orgb3d98f9">
<blockquote>
<p>
Some HTTP messages transfer a complete or partial representation as the message "payload". In some cases, a payload might contain only the associated representation's header fields (e.g., responses to HEAD) or only some part(s) of the representation data (e.g., the <code>206 (Partial Content)</code> status code).
</p>
</blockquote>

<p>
某些 HTTP 报文传输一个完整或部分的 representation 作为报文的“<ruby>有效载荷<rt>payload</rt></ruby>”。在某些情况下，一个有效载荷可能只包含 representation 相关的报头域（例如，回应给 HEAD 的响应报文），或者只有 representation 的某（几）部分（例如，<code>206 (Partial Content)</code> 状态码）。
</p>

<blockquote>
<p>
The purpose of a payload in a request is defined by the method semantics. For example, a representation in the payload of a PUT request (<a href="#org2e14fb1">Section 4.3.4</a>) represents the desired state of the target resource if the request is successfully applied, whereas a representation in the payload of a POST request (<a href="#org24c5a01">Section 4.3.3</a>) represents information to be processed by the target resource.
</p>
</blockquote>

<p>
对于请求报文里的有效载荷，其目的是由<ruby>请求方法的语义<rt>request method semantics</rt></ruby>来定义的。例如，在一个 PUT 请求（<a href="#org2e14fb1">章节 4.3.4</a>）的有效载荷内的 representation 表示如果成功应用该请求以后，<ruby>目标资源<rt>target resource</rt></ruby>的预期的状态。而一个 POST 请求（<a href="#org24c5a01">章节 4.3.3</a>）的有效载荷内的 representation 表示交由目标资源来处理的信息。
</p>

<blockquote>
<p>
In a response, the payload's purpose is defined by both the request method and the response status code. For example, the payload of a <code>200 (OK)</code> response to GET (<a href="#org479e86d">Section 4.3.1</a>) represents the current state of the target resource, as observed at the time of the message origination date (<a href="#org8e5ec45">Section 7.1.1.2</a>), whereas the payload of the same status code in a response to POST might represent either the processing result or the new state of the target resource after applying the processing. Response messages with an error status code usually contain a payload that represents the error condition, such that it describes the error state and what next steps are suggested for resolving it.
</p>
</blockquote>

<p>
在一个响应报文里，有效载荷的目标是由<ruby>请求方法<rt>request method</rt></ruby>和<ruby>响应状态码<rt>reponse status code</rt></ruby>两者共同来定义的。例如，一个回应给 GET 请求（<a href="#org479e86d">章节 4.3.1</a>）的 <code>200 (OK)</code> 响应报文表示在<ruby>报文发起日期<rt>message origination date</rt></ruby>（<a href="#org8e5ec45">章节 7.1.1.2</a>）所观察到的<ruby>目标资源<rt>target resource</rt></ruby>的目前状态。而一个回应给 POST 请求的 <code>200 (OK)</code> 响应报文可能表示：或者是在应用该请求以后的处理结果，或者是在应用该请求以后目标资源的新状态。带有一个错误状态码的响应报文通常会包含一个表示该错误条件的有效载荷，以描述错误状态以及如何解决错误的下一步建议。
</p>

<blockquote>
<p>
Header fields that specifically describe the payload, rather than the associated representation, are referred to as "payload header fields". Payload header fields are defined in other parts of this specification, due to their impact on message parsing.
</p>
</blockquote>

<p>
特定用于描述有效载荷而不是描述相关的 representation 的报头域，被称为“<ruby>有效载荷报头域<rt>payload header fields</rt></ruby>”。有效载荷报头域被定义在本规范的其他部分中，由它们对<ruby>报文解析<rt>message parsing</rt></ruby>的影响来决定。
</p>

<blockquote>
<p>
译注：有效载荷报头域并不是说这些报头域在有效载荷里，它们依然被放置在<ruby>报头块<rt>header section</rt></ruby>里。
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Defined in&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Content-Length</td>
<td class="org-left"><a href="RFC7230.html#ID-7b3e90b9-3ae5-402b-922c-2342d361c79f">Section 3.3.2</a> of [RFC7230]</td>
</tr>

<tr>
<td class="org-left">Content-Range</td>
<td class="org-left"><a href="https://tools.ietf.org/html/rfc7233">Section 4.2</a> of [RFC7233]</td>
</tr>

<tr>
<td class="org-left">Trailer</td>
<td class="org-left"><a href="RFC7230.html#ID-5ecf5800-1004-4acb-ba25-8772abdecd5a">Section 4.4</a> of [RFC7230]</td>
</tr>

<tr>
<td class="org-left">Transfer-Encoding</td>
<td class="org-left"><a href="RFC7230.html#ID-1754823B-D0BC-410F-A17B-E7ADA1AA79BC">Section 3.3.1</a> of [RFC7230]</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org7e87af6" class="outline-3">
<h3 id="org7e87af6"><a id="ID-c45cb9ca-1e51-4738-8c43-231e7316ea86"></a>3.4. 内容协商 / Content Negotiation</h3>
<div class="outline-text-3" id="text-org7e87af6">
<blockquote>
<p>
When responses convey payload information, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings. Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver. For this reason, HTTP provides mechanisms for content negotiation.
</p>
</blockquote>

<p>
响应在传达有效载荷信息的时候，无论是表达成功还是失败，源服务器通常会有多种不同的方式来表示该信息，例如，以不同的格式、语言或编码来表示。同样，不同的用户或用户代理可能有不同的能力、特性或者偏好，会影响到源服务器——在所有可用的 representations 中，究竟响应哪一个 representation 才是最合适的。出于上述原因，HTTP 提供了<ruby>内容协商<rt>content negotiation</rt></ruby>的机制。
</p>

<blockquote>
<p>
This specification defines two patterns of content negotiation that can be made visible within the protocol: "proactive", where the server selects the representation based upon the user agent's stated preferences, and "reactive" negotiation, where the server provides a list of representations for the user agent to choose from. Other patterns of content negotiation include "conditional content", where the representation consists of multiple parts that are selectively rendered based on user agent parameters, "active content", where the representation contains a script that makes additional (more specific) requests based on the user agent characteristics, and "Transparent Content Negotiation" ([<a href="https://tools.ietf.org/html/rfc2295">RFC2295</a>]), where content selection is performed by an intermediary. These patterns are not mutually exclusive, and each has trade-offs in applicability and practicality.
</p>
</blockquote>

<p>
本规范定义了两种内容协商的模式，使之能够在协议里可见：“<ruby>主动型<rt>proactive</rt></ruby>”和“<ruby>被动型<rt>reactive</rt></ruby>”。对于主动型内容协商，服务器会依据用户代理申明的偏好来选择 representation。对于被动型内容协商，服务会提供一系列的 representations 供用户代理选择。其他的内容协商的模式包括：“<ruby>条件内容<rt>conditional content</rt></ruby>”，representation 由多个部分组成，源服务器基于用户代理的参数来选择性地渲染各个部分；“<ruby>活动内容<rt>active content</rt></ruby>”，representation 包含有一个脚本，该脚本可以基于用户代理的特性来生成额外的（更加具体的）请求；“<ruby>透明内容协商<rt>Transparent Content Negotiation</rt></ruby>”（【<a href="https://tools.ietf.org/html/rfc2295">RFC2295</a>】），由一个中间人来执行内容选择。这些模式不是<ruby>互斥的<rt>mutually exclusive</rt></ruby>，每种都有其<ruby>适应性<rt>applicability</rt></ruby>和<ruby>实用性<rt>practicality</rt></ruby>。
</p>

<blockquote>
<p>
Note that, in all cases, HTTP is not aware of the resource semantics. The consistency with which an origin server responds to requests, over time and over the varying dimensions of content negotiation, and thus the "sameness" of a resource's observed representations over time, is determined entirely by whatever entity or algorithm selects or generates those responses. HTTP pays no attention to the man behind the curtain.
</p>
</blockquote>

<p>
需要注意的是，不管什么情况下，HTTP 都不知道资源的语义。源服务器响应给请求所遵循的一致性，随着时间和内容协商的不同维度的变化，因然一个资源的观察到的 representations 随着时间所表现出的“相同性”，是完全取决于实体还是算法，选择还是生成了什么响应。HTTP 并不在意幕后的人物。
</p>
</div>

<div id="outline-container-orgcc6adb1" class="outline-4">
<h4 id="orgcc6adb1"><a id="ID-c1d92ed4-69d5-4575-88c2-090534949ccf"></a>3.4.1. 主动型协商 / Proactive Negotiation</h4>
<div class="outline-text-4" id="text-orgcc6adb1">
<blockquote>
<p>
When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called proactive negotiation (a.k.a., server-driven negotiation). Selection is based on the available representations for a response (the dimensions over which it might vary, such as language, content-coding, etc.) compared to various information supplied in the request, including both the explicit negotiation fields of Section 5.3 and implicit characteristics, such as the client's network address or parts of the <code>User-Agent</code> field.
</p>
</blockquote>

<p>
用户代理发送包含内容协商的偏好信息的请求到服务器，让服务器的某个算法来选择偏好 representation，称之为<ruby>主动型协商<rt>proactive negotiation</rt></ruby>（也称<ruby>服务器驱动型协商<rt>server-driven negotiation</rt></ruby>）。这种选择是基于供响应使用的 representations （维度有很多，例如语言、内容编码等），对比多种由请求提供的信息，包括显式协商报头域（章节 5.3）和隐式特性两者，例如客户端的网络地址或者 <code>User-Agent</code> 报头域的部分信息。
</p>

<blockquote>
<p>
Proactive negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to a user agent, or when the server desires to send its "best guess" to the user agent along with the first response (hoping to avoid the round trip delay of a subsequent request if the "best guess" is good enough for the user). In order to improve the server's guess, a user agent <b>MAY</b> send request header fields that describe its preferences.
</p>
</blockquote>

<p>
主动型协商适用于以下情况：当难以向用户代理描述清楚服务器的选择算法（如何从<ruby>可使用的 representations<rt>available representations</rt></ruby> 之中选择最佳的一个）；或者当服务器倾向于在发送第一个响应到用户代理的时候就附带上它的“<ruby>最佳猜测<rt>best guess</rt></ruby>”（希望如果该“最佳猜测”对于该用户来说已经足够好的话，就能够避免后续请求的<ruby>往返延时<rt>round trip delay</rt></ruby>）。为了提升服务器猜测的准确性，用户代理 <b>可以</b> 在其发送的请求报文中包含某些报头域来描述自身的<ruby>偏好<rt>preferences</rt></ruby>。
</p>

<blockquote>
<p>
Proactive negotiation has serious disadvantages:
</p>
<ul class="org-ul">
<li>It is impossible for the server to accurately determine what might be "best" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?);</li>
<li>Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy;</li>
<li>It complicates the implementation of an origin server and the algorithms for generating responses to a request; and,</li>
<li>It limits the reusability of responses for shared caching.</li>
</ul>
</blockquote>

<p>
主动型协商有以下严重的弊端：
</p>
<ul class="org-ul">
<li>对于任何给定的用户，要让服务器精准确定什么才是“最佳的 representation”是不可能的，这是因为这需要全面了解用户代理的<ruby>能力<rt>capabilities</rt></ruby>及其对响应的<ruby>使用意图<rt>intended use</rt></ruby>（例如，用户是否想在屏幕上浏览或者将其打印成纸质的？）；</li>
<li>让用户代理在每次请求里都要描述自身的能力是非常<ruby>低效的<rt>inefficient</rt></ruby>（假定只有一小部分响应带有<ruby>多个 representations<rt>multiple representations</rt></ruby>），而且对用户的隐私有潜在风险；</li>
<li>复杂化了源服务器的实现和生成响应给到请求的算法；</li>
<li>限制了<ruby>共享缓存<rt>shared caching</rt></ruby>的<ruby>复用性<rt>reusability</rt></ruby>。</li>
</ul>

<blockquote>
<p>
A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a <code>406 (Not Acceptable)</code> response.
</p>
</blockquote>

<p>
用户代理不能信赖主动型协商的<ruby>预设<rt>preferences</rt></ruby>会一直被遵循，这是因为源服务器可能没有对所请求的资源实现主动型协商，或者认为发送一个并不符合用户代理的偏好的响应比发送一个 <code>406 (Not Acceptable)</code> 响应要好。
</p>

<blockquote>
<p>
A <code>Vary</code> header field (<a href="#org5ddc30c">Section 7.1.4</a>) is often sent in a response subject to proactive negotiation to indicate what parts of the request information were used in the selection algorithm.
</p>
</blockquote>

<p>
<code>Vary</code> 报头域（<a href="#org5ddc30c">章节 7.1.4</a>）通常用来指明主动型协商的选择算法会用到请求信息的哪些部分。
</p>
</div>
</div>

<div id="outline-container-orgb6b9e23" class="outline-4">
<h4 id="orgb6b9e23">3.4.2. 被动型协商 / Reactive Negotiation</h4>
<div class="outline-text-4" id="text-orgb6b9e23">
<blockquote>
<p>
With reactive negotiation (a.k.a., agent-driven negotiation), selection of the best response representation (regardless of the status code) is performed by the user agent after receiving an initial response from the origin server that contains a list of resources for alternative representations. If the user agent is not satisfied by the initial response representation, it can perform a GET request on one or more of the alternative resources, selected based on metadata included in the list, to obtain a different form of representation for that response. Selection of alternatives might be performed automatically by the user agent or manually by the user selecting from a generated (possibly hypertext) menu.
</p>
</blockquote>

<p>
使用<ruby>被动型协商<rt>reactive negotiation</rt></ruby>（也称<ruby>代理驱动型协商<rt>agent-driven negotiation</rt></ruby>），选择哪一个作为响应的最佳 representation（且不论<ruby>响应状态码<rt>response status code</rt></ruby>）是由用户代理在接收到一个来自源服务器的<ruby>初始响应<rt>initial response</rt></ruby>之后执行的。该初始响应包含一个<ruby>备选 representations<rt>alternative representations</rt></ruby> 列表。如果用户代理不满意初始响应的 representation，它可以（基于包含在上述列表中的元数据来）选择向一个或多个备选 representations 发起 GET 请求来获得不同形式的 representation。选择哪一种备选 representation 可能由用户代理自动执行，也可能由用户从一个生成好的菜单（也许是超文本）里手动选择。
</p>

<blockquote>
<p>
Note that the above refers to representations of the response, in general, not representations of the resource. The alternative representations are only considered representations of the target resource if the response in which those alternatives are provided has the semantics of being a representation of the target resource (e.g., a <code>200 (OK)</code> response to a GET request) or has the semantics of providing links to alternative representations for the target resource (e.g., a <code>300 (Multiple Choices)</code> response to a GET request).
</p>
</blockquote>

<p>
需要注意的是，上述所指的是响应的 representations，通常来说，并不是指资源的 representations。如果提供那些<ruby>备选 representation<rt>alternative representations</rt></ruby> 的响应带有如下语义：成为目标资源的一种 representation（例如，一个回应给 GET 请求的 <code>200 (OK)</code> 响应）；或者提供链接到该目标资源的备选 representations（例如，一个回应给 GET 请求的 <code>300 (Multiple Choices)</code> 响应），那么，备选 representations 仅考虑目标资源的 representations。
</p>

<blockquote>
<p>
A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred. For example, the alternatives listed in responses with the <code>300 (Multiple Choices)</code> and <code>406 (Not Acceptable)</code> status codes include information about the available representations so that the user or user agent can react by making a selection.
</p>
</blockquote>

<p>
服务器可能选择不发送一个初始 representation，而只发送<ruby>备选列表<rt>list of alternatives</rt></ruby>，从而表明它首选由用户代理来执行的被动型协商。例如，列在带有 <code>300 (Multiple Choices)</code> 和 <code>406 (Not Acceptable)</code> 状态码的响应里的<ruby>备选物<rt>alternatives</rt></ruby>，包含了关于<ruby>可用 representations<rt>available representations</rt></ruby> 的信息以便用户或用户代理作出选择。
</p>

<blockquote>
<p>
Reactive negotiation is advantageous when the response would vary over commonly used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage.
</p>
</blockquote>

<p>
被动型协商适用于以下情况：当响应会随常用维度（例如类型、语言、编码等）而变化；当源服务器无法通过检测请求而确定用户代理的能力；当使用<ruby>公共缓存<rt>public caches</rt></ruby>来分发服务器的负载和降低网络使用。
</p>

<blockquote>
<p>
Reactive negotiation suffers from the disadvantages of transmitting a list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation. Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed as an extension.
</p>
</blockquote>

<p>
被动型协商存在以下缺点：需要传递备选列表到用户代理，并且需要另一个请求来获得一种备选 representation。
在报头块里传递备选列表势必会导致<ruby>用户观感延时的降级<rt>degrades user-perceived latency</rt></ruby>。而且，本规范并没有定义用于支持自动选择的机制，但它也没有阻止这样一种机制发展成为扩展。
</p>

<blockquote>
<p>
译注：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">MDN web docs</a> 里对内容协商有更详细的描述。
</p>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-org5b4a18e" class="outline-2">
<h2 id="org5b4a18e"><a id="ID-e6ec0aa0-3e4d-4367-bffd-423e028210b0"></a>4. 请求方法 / Request Methods</h2>
<div class="outline-text-2" id="text-org5b4a18e">
</div>
<div id="outline-container-orgbe6d4a0" class="outline-3">
<h3 id="orgbe6d4a0">4.1. 概况 / Overview</h3>
<div class="outline-text-3" id="text-orgbe6d4a0">
<blockquote>
<p>
The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.
</p>
</blockquote>

<p>
请求方法的<ruby>标记<rt>token</rt></ruby>是请求语义的主要来源，它指明了客户端发起这次请求的目的以及它期望什么作为成功结果。
</p>

<blockquote>
<p>
The request method's semantics might be further specialized by the semantics of some header fields when present in a request (<a href="#org478df38">Section 5</a>) if those additional semantics do not conflict with the method. For example, a client can send conditional request header fields (<a href="#org8c0da01">Section 5.2</a>) to make the requested action conditional on the current state of the target resource ([<a href="https://tools.ietf.org/html/rfc7232">RFC7232</a>]).
</p>
</blockquote>

<p>
请求方法的语义可能由于某些请求报头域（<a href="#org478df38">章节 5</a>）的出现而被<ruby>进一步深化<rt>further specialized</rt></ruby>，如果这些报头域的语义与方法的语义并不冲突的话。例如，客户端能够发送<ruby>条件请求报头域<rt>conditional request header fields</rt></ruby>（<a href="#org8c0da01">章节 5.2</a>）以使对目标资源的当前状态的请求动作<ruby>条件化<rt>conditional</rt></ruby>（【<a href="https://tools.ietf.org/html/rfc7232">RFC7232</a>】）。
</p>

<div class="org-src-container">
<pre class="src src-text">method = token
</pre>
</div>

<blockquote>
<p>
HTTP was originally designed to be usable as an interface to distributed object systems. The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics. The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names.
</p>
</blockquote>

<p>
HTTP 最初是被设计为用来作为<ruby>分布式对象系统<rt>distributed object systems</rt></ruby>的一种接口。请求方法被设想为向某个目标资源应用语义，这就跟在某个被标识的对象上执行某个已定义的方法会应用相应的语义一样。<ruby>方法标记<rt>method tokens</rt></ruby>是区分大小写的，这是因为它可能用作一种区分方法名称大小写的网关，来对<ruby>基于对象的系统<rt>object-based systems</rt></ruby>进行访问。
</p>

<blockquote>
<p>
Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST]. Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.
</p>
</blockquote>

<p>
不同于分布式对象，在 HTTP 里，<ruby>标准请求方法<rt>standardized request methods</rt></ruby>不是<ruby>资源特定的<rt>resource-specific</rt></ruby>，这是因为提供统一接口是为了在基于网络的系统中有更好的可见性和复用（【<a href="http://roy.gbiv.com/pubs/dissertation/top.htm">REST</a>】）。一旦定义了标准化的方法，那么，当它被应用到任意资源的时候，它都应该具有同等的语义，虽然每种资源会自己决定是否实现或者允许这些语义。
</p>

<blockquote>
<p>
This specification defines a number of standardized methods that are commonly used in HTTP, as outlined by the following table. By convention, standardized methods are defined in all-uppercase US-ASCII letters.
</p>
</blockquote>

<p>
本规范定义了若干常用在 HTTP 里的标准方法，见下表的概括。按照惯例，标准方法是定义为纯大写的 US-ASCII 字母。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">章节</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GET</td>
<td class="org-left">传输目标资源的一种 current representation</td>
<td class="org-left"><a href="#org479e86d">4.3.1</a></td>
</tr>

<tr>
<td class="org-left">HEAD</td>
<td class="org-left">与 GET 相同，除了仅传输状态行和报头块</td>
<td class="org-left"><a href="#org607980d">4.3.2</a></td>
</tr>

<tr>
<td class="org-left">POST</td>
<td class="org-left">对请求有效载荷执行特定资源的处理</td>
<td class="org-left"><a href="#org24c5a01">4.3.3</a></td>
</tr>

<tr>
<td class="org-left">PUT</td>
<td class="org-left">使用请求有效载荷来替换目标资源的所有 current representations</td>
<td class="org-left"><a href="#org2e14fb1">4.3.4</a></td>
</tr>

<tr>
<td class="org-left">DELETE</td>
<td class="org-left">删除目标资源的所有 current representations</td>
<td class="org-left"><a href="#orgf7b2242">4.3.5</a></td>
</tr>

<tr>
<td class="org-left">CONNECT</td>
<td class="org-left">与目标资源所标识的服务器建立隧道</td>
<td class="org-left"><a href="#org3103350">4.3.6</a></td>
</tr>

<tr>
<td class="org-left">OPTIONS</td>
<td class="org-left">描述关于目标资源的通信选项</td>
<td class="org-left"><a href="#org85c174f">4.3.7</a></td>
</tr>

<tr>
<td class="org-left">TRACE</td>
<td class="org-left">执行一种沿着目标资源的路径的报文（消息）loop-back 测试</td>
<td class="org-left"><a href="#orgda48f54">4.3.8</a></td>
</tr>
</tbody>
</table>

<blockquote>
<p>
All general-purpose servers <b>MUST</b> support the methods GET and HEAD. All other methods are OPTIONAL.
</p>
</blockquote>

<p>
所有通用服务器 <b>必须</b> 支持 GET 和 HEAD 方法。所有其他方法都是 <b>可选的</b>。
</p>

<blockquote>
<p>
Additional methods, outside the scope of this specification, have been standardized for use in HTTP. All such methods ought to be registered within the "Hypertext Transfer Protocol (HTTP) Method Registry" maintained by IANA, as defined in <a href="#org04dcb6c">Section 8.1</a>.
</p>
</blockquote>

<p>
超出本规范所定义的额外方法，它们在 HTTP 的使用方式已经被标准化。应该把所有这些方法注册在由 IANA 维护的 "Hypertext Transfer Protocol (HTTP) Method Registry" 注册表中，其定义见<a href="#org04dcb6c">章节 8.1</a>。
</p>

<blockquote>
<p>
The set of methods allowed by a target resource can be listed in an <code>Allow</code> header field (<a href="#orgbfaeb5b">Section 7.4.1</a>). However, the set of allowed methods can change dynamically. When a request method is received that is unrecognized or not implemented by an origin server, the origin server <b>SHOULD</b> respond with the <code>501 (Not Implemented)</code> status code. When a request method is received that is known by an origin server but not allowed for the target resource, the origin server <b>SHOULD</b> respond with the <code>405 (Method Not Allowed)</code> status code.
</p>
</blockquote>

<p>
被<ruby>目标资源<rt>target resource</rt></ruby>所允许的方法集可以列在 <code>Allow</code> 报头域内（<a href="#orgbfaeb5b">章节 7.4.1</a>）。然而，目标资源可以动态改变其允许哪些方法。当源服务器接收到一个<ruby>不能识别<rt>unrecognized</rt></ruby>或自身<ruby>未实现的<rt>not implemented</rt></ruby>请求方法时，源服务器 <b>应当</b> 以 <code>501 (Not Implemented)</code> 作为响应。当服务器接收到一个能够识别但目标资源不允许的请求方法时，源服务器 <b>应当</b> 以 <code>405 (Method Not Allowed)</code> 作为响应。
</p>
</div>
</div>

<div id="outline-container-orga71ccac" class="outline-3">
<h3 id="orga71ccac">4.2. 公共方法属性 / Common Method Properties</h3>
<div class="outline-text-3" id="text-orga71ccac">
</div>
<div id="outline-container-org9cf22b2" class="outline-4">
<h4 id="org9cf22b2"><a id="ID-2f967e3d-8694-430b-ad06-e748fd39b281"></a>4.2.1. 安全方法 / Safe Methods</h4>
<div class="outline-text-4" id="text-org9cf22b2">
<blockquote>
<p>
Request methods are considered "safe" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.
</p>
</blockquote>

<p>
如果请求方法所定义的语义本质上是<ruby>只读<rt>read-only</rt></ruby>的，那么，这种请求方法可以认为是“<ruby>安全的<rt>safe</rt></ruby>”。例如，在向源服务器的某个目标资源应用某个<ruby>安全方法<rt>safe method</rt></ruby>以后，客户端既<ruby>没有请求（要求）<rt>not request</rt></ruby>也<ruby>没有期望<rt>not expect</rt></ruby>源服务器有任何状态的变化。同样，安全方法的合理使用并不希望对源服务器造成任何损害、财产损失、或者异常负担。
</p>

<blockquote>
<p>
This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server. Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account.
</p>
</blockquote>

<p>
安全方法的这种定义并不妨碍将其<ruby>实现<rt>implement</rt></ruby>为一种可能包含有害行为的方法，表现为不完全只读，或者当执行某个安全方法时会引起<ruby>副作用<rt>side effects</rt></ruby>。然而，重要的是，客户端并没有请求（要求）服务器执行额外的行为，并且不能因此而追究客户端的责任。例如，大多数服务器在完成每个响应的时候，会附加上请求信息到访问日志文件里面，而不管这是什么请求方法，这就被认为是安全的，哪怕日志存储可能变满导致服务器崩溃。同样，在网站上发起一个安全的请求来进行广告甄选，通常会有广告账号记账的副作用（即产生广告费用的消耗）。
</p>

<blockquote>
<p>
Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
</p>
</blockquote>

<p>
本规范所定义的请求方法中，定义为安全的方法有：GET、HEAD、OPTIONS 和 TRACE。
</p>

<blockquote>
<p>
The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm. In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content.
</p>
</blockquote>

<p>
之所有要区分方法是否安全，是为了可以放心地开启<ruby>自动检索程序<rt>automated retrieval processes</rt></ruby>（<ruby>爬虫<rt>spider</rt></ruby>）和<ruby>缓存性能优化<rt>cache performance optimization</rt></ruby>（<ruby>预取<rt>pre-fetching</rt></ruby>）而不需要担心引起问题。再者，它让用户代理在处理可能不受信任的内容的时候，能够对非安全方法的自动使用实施适当的约束。
</p>

<blockquote>
<p>
A user agent <b>SHOULD</b> distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.
</p>
</blockquote>

<p>
当呈现潜在的请求动作给用户的时候，用户代理 <b>应当</b> 区分好安全与非安全的方法，以便在这种请求动作被执行之前，用户能够意识到这是一种不安全的动作。
</p>

<blockquote>
<p>
When a resource is constructed such that parameters within the effective request URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as "page?do=delete". If the purpose of such a resource is to perform an unsafe action, then the resource owner <b>MUST</b> disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.
</p>
</blockquote>

<p>
构建一个资源，使在<ruby>有效请求 URI<rt>effective request URI</rt></ruby> 里的参数会影响到的请求动作选择，那么，确保该动作是否符合请求方法的语义是资源所有者的责任。例如，<ruby>基于网站的内容编辑软件<rt>Web-based content editing software</rt></ruby>常常会在<ruby>查询参数<rt>query parameters</rt></ruby>里使用某些动作，如 "page?do=delete"。如果这种资源的目的是为执行一个<ruby>非安全的动作<rt>unsafe action</rt></ruby>，那么，当使用一个<ruby>安全的请求方法<rt>safe request method</rt></ruby>来访问该资源的时候，资源所有者 <b>必须</b> 禁用或者拒绝该动作。否则的话，当<ruby>自动程序<rt>automated processes</rt></ruby>出于某种目的（为了链接维护，预取，生成搜索索引等）来对每个 URI 执行一个 GET 的时候，会导致不好的副作用。
</p>

<blockquote>
<p>
译注：请求方法是否是安全的，其关注点在于该方法是否有改变资源的状态，而不是平常我们认为的安全性或保密性的概念。只要执行该请求方法后，资源的状态没有被改变，那么这个请求方法就是安全的（哪怕可能会导致数据泄漏、黑客入侵、硬件爆炸等），否则就是不安全的。换句话说，安全的请求方法都是“只读”的，并不会对资源造成任何“写入”，类似于编程语言中 Getter 的概念。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgf6e425a" class="outline-4">
<h4 id="orgf6e425a">4.2.2. 幂等方法 / Idempotent Methods</h4>
<div class="outline-text-4" id="text-orgf6e425a">
<blockquote>
<p>
A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.
</p>
</blockquote>

<p>
当执行多次相同的请求，与单次这样的请求，对服务器的预期效果是一样的，那么，该请求方法被认为是“<ruby>幂等的<rt>idempotent</rt></ruby>”。本规范所定义的请求方法中，幂等方法有：PUT、DELETE 以及所有<a href="#org9cf22b2">安全请求方法</a>。
</p>

<blockquote>
<p>
译注：也就是说，幂等的方法共有GET、HEAD、PUT、DELETE、OPTIONS 和 TRACE。
</p>
</blockquote>

<blockquote>
<p>
Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request.
</p>
</blockquote>

<p>
跟安全的定义类似，请求方法的幂等性只适用于用户究竟请求到了什么，而服务器可以自由地单独记录每个请求的日志，保持一份版本管理历史，或者为每个幂等请求实现其他非幂等的副作用等等。
</p>

<blockquote>
<p>
Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response. For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request. It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.
</p>
</blockquote>

<p>
之所以要区分请求方法的幂等与否，是因为如果在客户端能够读取服务器的响应之前发生了通信失败，请求可以被自动重复发送（见<a href="RFC7230.html#ID-0ca97f51-efc7-43d2-ab52-d998a92423e5">【RFC7230】6.3.1</a>）。例如，如果客户端发送一个 PUT 请求，同时，之前建立好的连接在客户端接收到任何响应之前就被关闭了，那么，客户端可以建立一个新的连接并重试该幂等请求。客户端知道重复该请求会有相同的预期效果，即使原来的请求已经成功了。
</p>
</div>
</div>

<div id="outline-container-org1aba746" class="outline-4">
<h4 id="org1aba746">4.2.3. 可缓存方法 / Cacheable Methods</h4>
<div class="outline-text-4" id="text-org1aba746">
<blockquote>
<p>
Request methods can be defined as "cacheable" to indicate that responses to them are allowed to be stored for future reuse; for specific requirements see [<a href="https://tools.ietf.org/html/rfc7234">RFC7234</a>]. In general, safe methods that do not depend on a current or authoritative response are defined as cacheable; this specification defines GET, HEAD, and POST as cacheable, although the overwhelming majority of cache implementations only support GET and HEAD.
</p>
</blockquote>

<p>
请求方法可以被定义为“<ruby>可缓存的<rt>cacheable</rt></ruby>”来指明：回应给它们的响应能够被保存起来，用于将来的复用，更具体的要求见【<a href="https://tools.ietf.org/html/rfc7234">RFC7234</a>】。通常，不依赖某个<ruby>当前响应<rt>current response</rt></ruby>或<ruby>权威响应<rt>authoritative response</rt></ruby>的安全方法，就是<ruby>可缓存的<rt>cacheable</rt></ruby>方法。本规范定义了 GET、HEAD 和 POST 作为可缓存的方法，虽然绝大多数的<ruby>缓存实现<rt>cache implementations</rt></ruby>仅仅支持 GET 和 HEAD。
</p>
</div>
</div>
</div>

<div id="outline-container-org04053c2" class="outline-3">
<h3 id="org04053c2">4.3. 方法的定义 / Method Definitions</h3>
<div class="outline-text-3" id="text-org04053c2">
</div>
<div id="outline-container-org479e86d" class="outline-4">
<h4 id="org479e86d"><a id="ID-698bab73-07b1-4349-8a03-5a4a89d966d8"></a>4.3.1. GET</h4>
<div class="outline-text-4" id="text-org479e86d">
<blockquote>
<p>
The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.
</p>
</blockquote>

<p>
GET 方法请求获得目标资源的一种<ruby>当前选定的 representation<rt>current selected representation</rt></ruby>。GET 是信息获取的主要途径，同时，它也是几乎所有<ruby>性能优化<rt>performance optimizations</rt></ruby>的重点。因此，当人们谈及经由 HTTP 来获取某些可标识的信息的时候，他们一般指的是发起一个 GET 请求。
</p>

<blockquote>
<p>
It is tempting to think of resource identifiers as remote file system pathnames and of representations as being a copy of the contents of such files. In fact, that is how many resources are implemented (see <a href="#org64f3a9f">Section 9.1</a> for related security considerations). However, there are no such limitations in practice. The HTTP interface for a resource is just as likely to be implemented as a tree of content objects, a programmatic view on various database records, or a gateway to other information systems. Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly. Regardless, only the origin server needs to know how each of its resource identifiers corresponds to an implementation and how each implementation manages to select and send a current representation of the target resource in a response to GET.
</p>
</blockquote>

<p>
我们很容易想到将<ruby>资源标识<rt>resource identifiers</rt></ruby>符作为远程文件系统的路径名称，以及将 representations 作为这些远程文件的内容的一种拷贝。事件上，这也是许多资源的实现方式（安全相关注意事项见<a href="#org64f3a9f">章节 9.1</a>）。然而，实际上资源并没有被限制为只有这一种实现方式。资源的 HTTP 接口也有可能被实现为一种<ruby>内容对象树<rt>content object tree</rt></ruby><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>、一种基于各种数据库记录的可编程视图、一种到其他信息系统的网关等等。甚至当 URI 的映射机制被捆绑到一种文件系统上，也可以将源服务器配置为将文件连同请求一起作为执行的输入，而输出结果则作为 representation 并发送给请求，而不是直接传输文件本身。无论如何，只有源服务器需要了解它的每个资源标识符如何对应到某种实现，以及每种实现如何在回应到 GET 的响应里达成选择和发送目标资源的某种 current representation。
</p>

<blockquote>
<p>
A client can alter the semantics of GET to be a "range request", requesting transfer of only some part(s) of the selected representation, by sending a <code>Range</code> header field in the request ([<a href="https://tools.ietf.org/html/rfc7233">RFC7233</a>]).
</p>
</blockquote>

<p>
客户端能够将 GET 的语义改变为一种“<ruby>范围请求<rt>range request</rt></ruby>”，通过在其发送的请求报文中带有一个 <code>Range</code> 报头域，来实现只对已选择的 representation 中的某（几）部分进行请求传输（【<a href="https://tools.ietf.org/html/rfc7233">RFC7233</a>】）。
</p>

<blockquote>
<p>
A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.
</p>
</blockquote>

<p>
在 GET 请求报文里的有效载荷是没有定义任何语义的，如果在 GET 请求里带有一个有效载荷可能会导致某些现有的<ruby>实现<rt>implementations</rt></ruby>拒绝该请求。
</p>

<blockquote>
<p>
The response to a GET request is cacheable; a cache <b>MAY</b> use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the <code>Cache-Control</code> header field (<a href="https://tools.ietf.org/html/rfc7234#section-5.2">Section 5.2</a> of [RFC7234]).
</p>
</blockquote>

<p>
回应给 GET 请求的响应是<ruby>可缓存的<rt>cacheable</rt></ruby>，<ruby>缓存<rt>cache</rt></ruby> <b>可以</b> 使用它来满足随后的 GET 和 HEAD 请求，除非 <code>Cache-Control</code> 报头域另有指定（<a href="https://tools.ietf.org/html/rfc7234#section-5.2">【RFC7234】章节 5.2</a>）。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET">MDN</a> 的总结：
The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
</p>
<dl class="org-dl">
<dt>Request has body</dt><dd>No</dd>
<dt>Successful response has body</dt><dd>Yes</dd>
<dt>Safe</dt><dd>Yes</dd>
<dt>Idempotent</dt><dd>Yes</dd>
<dt>Cacheable</dt><dd>Yes</dd>
<dt>Allowed in HTML forms</dt><dd>Yes</dd>
</dl>
</blockquote>
</div>
</div>

<div id="outline-container-org607980d" class="outline-4">
<h4 id="org607980d"><a id="ID-d00f1692-2d40-4b09-a634-9c87fce07bc4"></a>4.3.2. HEAD</h4>
<div class="outline-text-4" id="text-org607980d">
<p>
The HEAD method is identical to GET except that the server <b>MUST NOT</b> send a message body in the response (i.e., the response terminates at the end of the header section). The server <b>SHOULD</b> send the same header fields in response to a HEAD request as it would have sent if the request had been a GET, except that the payload header fields (<a href="#orgb3d98f9">Section 3.3</a>) <b>MAY</b> be omitted. This method can be used for obtaining metadata about the selected representation without transferring the representation data and is often used for testing hypertext links for validity, accessibility, and recent modification.
</p>

<p>
HEAD 方法几乎与 GET 方法等价，除了服务器 <b>禁止</b> 在回应 HEAD 请求的响应报文里带有<ruby>报文正文<rt>message body</rt></ruby>（也就是说，响应报文在<ruby>报头块<rt>header section</rt></ruby>之后就结束了）。服务器回应给 GET 请求的响应报文里带有什么报头域，回应给 HEAD 请求的响应报文里就 <b>应当</b> 带有什么报头域，除了<ruby>有效载荷报头域<rt>payload header fields</rt></ruby>（<a href="#orgb3d98f9">章节 3.3</a>） <b>可以</b> 被忽略以外。HEAD 方法能够用于在不需要传输 representation data 的情况下获取关于<ruby>已选定的 representation<rt>selected representation</rt></ruby>（<a href="#org5a29517">章节 3</a>） 的元数据。同时，它也常用于测试<ruby>超链接<rt>hypertext links</rt></ruby>的正确性、可访问性和最近是否有修改。
</p>

<p>
A payload within a HEAD request message has no defined semantics; sending a payload body on a HEAD request might cause some existing implementations to reject the request.
</p>

<p>
在 HEAD 请求报文里的有效载荷是没有定义任何语义的，如果在 HEAD 请求里带有一个有效载荷可能会导致某些现有的<ruby>实现<rt>implementations</rt></ruby>拒绝该请求。
</p>

<p>
The response to a HEAD request is cacheable; a cache <b>MAY</b> use it to satisfy subsequent HEAD requests unless otherwise indicated by the <code>Cache-Control</code> header field (<a href="https://tools.ietf.org/html/rfc7234#section-5.2">Section 5.2</a> of [RFC7234]). A HEAD response might also have an effect on previously cached responses to GET; see <a href="https://tools.ietf.org/html/rfc7234#section-4.3.5">Section 4.3.5</a> of [RFC7234].
</p>

<p>
回应给 HEAD 请求的响应是<ruby>可缓存的<rt>cacheable</rt></ruby>，<ruby>缓存<rt>cache</rt></ruby> <b>可以</b> 使用它来满足随后的 HEAD 请求，除非 <code>Cache-Control</code> 报头域另有指定（<a href="https://tools.ietf.org/html/rfc7234#section-5.2">【RFC7234】章节 5.2</a>）。HEAD 响应还可能影响到之前已缓存的 GET 响应，见<a href="https://tools.ietf.org/html/rfc7234#section-4.3.5">【RFC7234】章节 4.3.5</a>。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD">MDN</a> 的总结：
</p>

<dl class="org-dl">
<dt>Request has body</dt><dd>No</dd>
<dt>Successful response has body</dt><dd>No</dd>
<dt>Safe</dt><dd>Yes</dd>
<dt>Idempotent</dt><dd>Yes</dd>
<dt>Cacheable</dt><dd>Yes</dd>
<dt>Allowed in HTML forms</dt><dd>No</dd>
</dl>
</blockquote>
</div>
</div>

<div id="outline-container-org24c5a01" class="outline-4">
<h4 id="org24c5a01"><a id="ID-d672d01b-615b-416a-a750-0442a6901ed0"></a>4.3.3. POST</h4>
<div class="outline-text-4" id="text-org24c5a01">
<blockquote>
<p>
The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others):
</p>

<ul class="org-ul">
<li>Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;</li>
<li>Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;</li>
<li>Creating a new resource that has yet to be identified by the origin server; and</li>
<li>Appending data to a resource's existing representation(s).</li>
</ul>
</blockquote>

<p>
POST 方法请求目标资源按照资源自身的具体语义来处理封装在请求报文里的 representation。例如，POST 是用于以下（或其他）功能。
</p>

<ul class="org-ul">
<li>为某个数据处理进程提供<ruby>数据块<rt>a block of data</rt></ruby>，例如某个 HTML 表单的域；</li>
<li>发表一份报文到某个电子公告栏、新闻组、邮件列表、博客或者类似的文章组里；</li>
<li>创建一种还没有被源服务器所标识的新的资源；以及</li>
<li>附加数据到某个资源的现有 representation(s) 中。</li>
</ul>

<blockquote>
<p>
An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification might be received in a response to POST (the exceptions being <code>206 (Partial Content)</code>, <code>304 (Not Modified)</code>, and <code>416 (Range Not Satisfiable)</code>).
</p>
</blockquote>

<p>
源服务器根据 POST 请求的处理结果来选择一种恰当的状态码来指明响应的语义，几乎所有本规范定义的状态码都可以用在回应给 POST 的响应里，除了 <code>206 (Partial Content)</code>、<code>304 (Not Modified)</code> 以及 <code>416 (Range Not Satisfiable)</code> 是例外。
</p>

<blockquote>
<p>
If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server <b>SHOULD</b> send a <code>201 (Created)</code> response containing a <code>Location</code> header field that provides an identifier for the primary resource created (<a href="#orgad9277e">Section 7.1.2</a>) and a representation that describes the status of the request while referring to the new resource(s).
</p>
</blockquote>

<p>
如果一个或多个资源在源服务器上被创建，来作为对成功处理某个 POST 请求的结果，那么，源服务器 <b>应当</b> 发送一个 <code>201 (Created)</code> 响应，且该响应需带有一个 <code>Location</code> 报头域来提供一种标识符，来对应被创建的主要资源（<a href="#orgad9277e">章节 7.1.2</a>）；以及需要包含一种 representation，来描述当引用新资源的时候请求的状态。
</p>

<blockquote>
<p>
Responses to POST requests are only cacheable when they include explicit freshness information (see <a href="https://tools.ietf.org/html/rfc7234#section-4.2.1">Section 4.2.1</a> of [RFC7234]). However, POST caching is not widely implemented. For cases where an origin server wishes the client to be able to cache the result of a POST in a way that can be reused by a later GET, the origin server <b>MAY</b> send a <code>200 (OK)</code> response containing the result and a <code>Content-Location</code> header field that has the same value as the POST's effective request URI (<a href="#org6190703">Section 3.1.4.2</a>).
</p>
</blockquote>

<p>
回应给 POST 请求的响应，仅当它们包含明确的<ruby>新鲜信息<rt>freshness information</rt></ruby>时，才是<ruby>可缓存的<rt>cacheable</rt></ruby>（见<a href="https://tools.ietf.org/html/rfc7234#section-4.2.1">【RFC7234】章节 4.2.1</a>）。然而，对 POST 响应的缓存并没有被广泛实现。如果源服务器希望客户端以一种之后的 GET 能够复用的方式使客户端能够缓存 POST 的结果，面对这种情况，源服务器 <b>可以</b> 发送一个 <code>200 (OK)</code> 响应来包含该结果，并且，该响应还需带有与该 POST 的有效请求 URI 相同的值的一个 <code>Content-Location</code> 报头域（<a href="#org6190703">章节 3.1.4.2</a>）。
</p>

<blockquote>
<p>
If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server <b>MAY</b> redirect the user agent to that resource by sending a <code>303 (See Other)</code> response with the existing resource's identifier in the <code>Location</code> field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.
</p>
</blockquote>

<p>
如果处理某个 POST 请求的结果等价于某个现有资源的某种 representation 的话，源服务器 <b>可以</b> 发送一个 <code>303 (See Other)</code> 响应到用户代理，同时，响应里带有 <code>Location</code> 报头域，其值为该现有资源的标识符，让用户代理进行重定向。这样做的好处是可以向用户代理提供一种资源标识符，以及可以通过一种更适合缓存共享的方法来传输 representation，但坏处是可能需要一个额外的请求，如果用户代理还没有缓存过该 representation 的话。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST">MDN</a> 的总结：
</p>

<p>
The HTTP POST method sends data to the server. The type of the body of the request is indicated by the Content-Type header.
</p>

<dl class="org-dl">
<dt>Request has body</dt><dd>Yes</dd>
<dt>Successful response has body</dt><dd>Yes</dd>
<dt>Safe</dt><dd>No</dd>
<dt>Idempotent</dt><dd>No</dd>
<dt>Cacheable</dt><dd>Only if freshness information is included</dd>
<dt>Allowed in HTML forms</dt><dd>Yes</dd>
</dl>
</blockquote>
</div>
</div>

<div id="outline-container-org2e14fb1" class="outline-4">
<h4 id="org2e14fb1"><a id="ID-28f69be8-26e9-4dd7-930e-7c683d7bcf8a"></a>4.3.4. PUT</h4>
<div class="outline-text-4" id="text-org2e14fb1">
<blockquote>
<p>
The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload. A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.
</p>
</blockquote>

<p>
PUT 方法请求源服务器使用封装在请求报文有效载荷内的 representation 所定义的状态，来<ruby>新建<rt>create</rt></ruby>或<ruby>替换<rt>replace</rt></ruby>目标资源的状态。如果向目标资源<ruby>成功 PUT<rt>successful PUT request</rt></ruby> 了一个给定的 representation，那么我们可以认为，对相同目标资源的后续 GET 请求将会被回应一个 <code>200 (OK)</code> 响应，同时响应会携带一个（与之前 PUT 的 representation）等价的 representation。然而，不能保证这种状态的改变能够被客户端所观察到，这是因为在源服务器接收到任何来自该客户端的后续的 GET 请求之前，目标资源就可能被按照其他用户代理并行地执行动作，也有可能受到源服务器的动态处理。对 PUT 请求的<ruby>成功响应<rt>successful response</rt></ruby>，仅仅意味着在源服务器处理该请求的时候，用户代理达成了它的意图。
</p>

<blockquote>
<p>
If the target resource does not have a current representation and the PUT successfully creates one, then the origin server <b>MUST</b> inform the user agent by sending a <code>201 (Created)</code> response. If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server <b>MUST</b> send either a <code>200 (OK)</code> or a <code>204 (No Content)</code> response to indicate successful completion of the request.
</p>
</blockquote>

<p>
如果目标资源并没有 current representation，并且 PUT 成功地创建了一种 representation，那么，源服务器 <b>必须</b> 回应一个 <code>201 (Created)</code> 响应来告知用户代理。如果目标资源已有 current representation 并且该 representation 的状态被封装在 PUT 请求内的 representation 成功地更改了，那么，源服务器 <b>必须</b> 回应一个 <code>200 (OK)</code> 或者一个 <code>204 (No Content)</code> 来指明请求已经成功完成了。
</p>

<blockquote>
<p>
译注：由此可见，PUT 会改变 representation 的状态，因此，它不是一个<ruby>安全方法<rt>safe method</rt></ruby>。而 PUT 是一个<ruby>幂等方法<rt>idempotent method</rt></ruby>，由上述可知，多次相同的 PUT 请求与一次 PUT 请求对 representation 的影响是一样的。试想一下，一个 PUT 请求，试图将用户 A 的年龄值更新为 18，无论发送一次还是多次这样的请求，用户 A 的年龄值最终依然是 18。
</p>
</blockquote>

<blockquote>
<p>
An origin server <b>SHOULD</b> ignore unrecognized header fields received in a PUT request (i.e., do not save them as part of the resource state).
</p>
</blockquote>

<p>
源服务器 <b>应当</b> 忽略掉接收自某个 PUT 请求的<ruby>未识别的报头域<rt>unrecognized header fields</rt></ruby>（也就是说，不要保存它们作为资源状态的一部分）。
</p>

<blockquote>
<p>
An origin server <b>SHOULD</b> verify that the PUT representation is consistent with any constraints the server has for the target resource that cannot or will not be changed by the PUT. This is particularly important when the origin server uses internal configuration information related to the URI in order to set the values for representation metadata on GET responses. When a PUT representation is inconsistent with the target resource, the origin server <b>SHOULD</b> either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The <code>409 (Conflict)</code> or <code>415 (Unsupported Media Type)</code> status codes are suggested, with the latter being specific to constraints on <code>Content-Type</code> values.
</p>
</blockquote>

<p>
源服务器 <b>应当</b> 校验 PUT 的 representation 是否符合服务器对目标资源的任何<ruby>约束<rt>constraints</rt></ruby>，确保它们不能或不会被 PUT 所改变。当源服务器使用与 URI 相关联的内部配置信息来对回应给 GET 的响应的 representation 的元数据设置值的时候，这种校验是非常重要的。当一个 PUT 请求内的 representation 不符合<ruby>目标资源<rt>target resource</rt></ruby>的约束时，源服务器 <b>应当</b> 要不<ruby>转换<rt>transform</rt></ruby>这个 representation 或者改变资源的配置以使其符合约束条件；要不回应一种恰当的错误报文，包含足够的信息来解释为什么该 representation 并不适合。建议使用 <code>409 (Conflict)</code> 或者 <code>415 (Unsupported Media Type)</code> 状态码，而对于后者（<code>415 (Unsupported Media Type)</code>），带有 <code>Content-Type</code> 报头域以指定具体的约束类型。
</p>

<blockquote>
<p>
For example, if the target resource is configured to always have a <code>Content-Type</code> of "text/html" and the representation being PUT has a <code>Content-Type</code> of "image/jpeg", the origin server ought to do one of:
</p>

<ul class="org-ul">
<li>reconfigure the target resource to reflect the new media type;</li>
<li>transform the PUT representation to a format consistent with that of the resource before saving it as the new resource state; or,</li>
<li>reject the request with a <code>415 (Unsupported Media Type)</code> response indicating that the target resource is limited to "text/html", perhaps including a link to a different resource that would be a suitable target for the new representation.</li>
</ul>
</blockquote>

<p>
例如，如果目标资源被配置为总是带有一个 "text/html" 的 <code>Content-Type</code>，并且 PUT 请求内的 representation 带有一个 "image/jpeg" 的 <code>Content-Type</code>，那么，源服务器的行为应该是以下其中之一：
</p>

<ul class="org-ul">
<li>将目标资源重新配置以体现该种新的媒体类型；</li>
<li>在保存 PUT 请求的 representation 作为目标资源的新状态之前，先将其<ruby>转换<rt>transform</rt></ruby>为一种符合资源约束的格式；或者</li>
<li>回应一个 <code>415 (Unsupported Media Type)</code> 响应来拒绝该请求并指明目标资源被限定为 "text/html"，响应内可能还包含一条<ruby>链接<rt>link</rt></ruby>，该链接指向到其他可能适用于该请求目标的资源。</li>
</ul>

<blockquote>
<p>
HTTP does not define exactly how a PUT method affects the state of an origin server beyond what can be expressed by the intent of the user agent request and the semantics of the origin server response. It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP. It does not define how resource state is "stored", nor how such storage might change as a result of a change in resource state, nor how the origin server translates resource state into representations. Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server.
</p>
</blockquote>

<p>
HTTP 并没有定义 PUT 方法究竟是如何影响源服务器的状态的，是因为这超出了用户代理的请求意图以及源服务器的响应语义所能表达的。HTTP 并没有定义<ruby>资源<rt>resource</rt></ruby>究竟是什么，在任何意义上，这超出了由 HTTP 所提供的接口所能表达的。HTTP 并没有定义<ruby>资源的状态<rt>resource state</rt></ruby>是被如何“<ruby>存储<rt>stored</rt></ruby>”的，也没有定义资源状态上的改变会导致这种存储如何改变，也没有定义源服务器是如何将资源的状态<ruby>翻译<rt>translate</rt></ruby>成<ruby>资源的表示<rt>representations</rt></ruby>的。一般而言，在资源接口后面的所有实现细节都被服务器有意地隐藏起来。
</p>

<blockquote>
<p>
An origin server <b>MUST NOT</b> send a validator header field (<a href="#org4d2e5ff">Section 7.2</a>), such as an <code>ETag</code> or <code>Last-Modified</code> field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the body (i.e., the resource's new representation data is identical to the representation data received in the PUT request) and the validator field value reflects the new representation. This requirement allows a user agent to know when the representation body it has in memory remains current as a result of the PUT, thus not in need of being retrieved again from the origin server, and that the new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 5.2).
</p>
</blockquote>

<p>
源服务器 <b>禁止</b> 在回应给 PUT 的<ruby>成功响应<rt>successful response</rt></ruby>里带有任何<ruby>验证器报头域<rt>validator header field</rt></ruby>（<a href="#org4d2e5ff">章节 7.2</a>），例如 <code>ETag</code> 或者 <code>Last-Modified</code> 报头域，除非请求的 representation data 是保存在没有经过任何<ruby>编码转换<rt>transformation</rt></ruby>的报文正文（有效载荷）里（也就是说，响应内的新 representation data 是等价于接收自 PUT 请求内的 representation data），并且该验证器报头域反映的是新是 representation。上述这种要求让用户代理能够知道这个在自己内存中的 representation 在什么时间内可以<ruby>保持最新（保持为 current 状态）<rt>remain current</rt></ruby>，由此知道其是否仍然可以继续作为 PUT 请求的结果而不需要从源服务器上再次获取，以及在响应内接收到的新验证器能够被用于将来的<ruby>条件请求<rt>conditional requests</rt></ruby>以避免新<ruby>意外覆盖<rt>accidental overwrite</rt></ruby>（章节 5.2）。
</p>

<blockquote>
<p>
译注：未经过任何编码转换的<ruby>报文正文<rt>message body</rt></ruby>等价于<ruby>有效载荷体<rt>payload body</rt></ruby>，见<a href="RFC7230.html#ID-1754823B-D0BC-410F-A17B-E7ADA1AA79BC">【RFC7230】章节 3.3.1</a>。
</p>
</blockquote>

<blockquote>
<p>
The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation. The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the target resource. Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.
</p>
</blockquote>

<p>
POST 与 PUT 两者的根本区别在于它们对封装的 representation 的不同意图。POST 所请求目标资源是意图依据该资源自身的语义来<ruby>处置<rt>handle</rt></ruby>请求内的 representation。而在 PUT 请求内的 representation 是定义为替换目标资源的状态的。因此，PUT 的意图是<ruby>幂等的<rt>idempotent</rt></ruby>且对<ruby>中间人<rt>intermediaries</rt></ruby>是<ruby>可见的<rt>visible</rt></ruby>，虽然只有源服务器了解其确切的作用。
</p>

<blockquote>
<p>
Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, <b>SHOULD</b> be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server <b>MUST</b> send an appropriate <code>3xx (Redirection)</code> response; the user agent <b>MAY</b> then make its own decision regarding whether or not to redirect the request.
</p>
</blockquote>

<p>
PUT 请求的<ruby>合理解释<rt>proper interpretation</rt></ruby>是相信用户代理是知道哪个目标才是它所期望的。一种为客户端选择恰当的 URI 的服务，在接收到一种<ruby>会引起状态变化的请求<rt>state-changing request</rt></ruby>以后，<b>应当</b> 被实现为使用 POST 方法而不是 PUT 方法。如果源服务器不将 PUT 所请求的状态改变到目标资源上，而是希望将其应用到另外一个不同的资源上，例如当资源被迁移到另一个不同的 URI 上了，那么，源服务器 <b>必须</b> 回应一个恰当的 <code>3xx (Redirection)</code> 响应给用户代理，然后，用户代理 <b>可以</b> 自行决定是否对请求进行<ruby>重定向<rt>redirect</rt></ruby>。
</p>

<blockquote>
<p>
A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying "the current version" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on "the current version" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.
</p>
</blockquote>

<p>
应用到<ruby>目标资源<rt>target resource</rt></ruby>的 PUT 请求可能会对其他资源带来<ruby>副作用<rt>side effects</rt></ruby>。例如，一篇文章可能会有一个用于标识“<ruby>当前版本<rt>the current version</rt></ruby>”（是一种资源）的 URI，独立于其他每一个标识特定版本的 URIs，不同的资源在某处共享同一种状态来作为“当前版本”所对应的资源。成功地向“当前版本”这个 URI 发起了一个 PUT 请求以后，可能除了改变目标资源的状态之外，还会创建额外一个“新版本”的资源，而且还有可能需要添加链接到关联的资源之中。 
</p>

<blockquote>
<p>
An origin server that allows PUT on a given target resource <b>MUST</b> send a <code>400 (Bad Request)</code> response to a PUT request that contains a <code>Content-Range</code> header field (<a href="https://tools.ietf.org/html/rfc7233#section-4.2">Section 4.2</a> of [RFC7233]), since the payload is likely to be partial content that has been mistakenly PUT as a full representation. Partial content updates are possible by targeting a separately identified resource with state that overlaps a portion of the larger resource, or by using a different method that has been specifically defined for partial updates (for example, the PATCH method defined in [<a href="https://tools.ietf.org/html/rfc5789">RFC5789</a>]).
</p>
</blockquote>

<p>
对于允许向给定目标资源发送 PUT 请求的源服务器来说，如果某个 PUT 请求包含有一个 <code>Content-Range</code> 报头域（<a href="https://tools.ietf.org/html/rfc7233#section-4.2">【RFC7233】章节 4.2</a>），源服务器 <b>必须</b> 向该请求回应一个 <code>400 (Bad Request)</code> 响应，这是因为该请求的<ruby>有效载荷<rt>payload</rt></ruby>很有可能只是<ruby>部分内容<rt>partial content</rt></ruby>而被错误地当作一个完整的 representation。<ruby>部分内容的更新<rt>partial content updates</rt></ruby>很可能是通过使用<ruby>大型资源<rt>larger resource</rt></ruby>的一部分相重叠的状态来定位一个单独标识的资源，或者通过使用另外一种被定义为专门用于<ruby>部分更新<rt>partial updates</rt></ruby>的方法（例如，定义于【<a href="https://tools.ietf.org/html/rfc5789">RFC5789</a>】里的 PATCH 方法）。
</p>

<blockquote>
<p>
Responses to the PUT method are not cacheable. If a successful PUT request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see Section 4.4 of [RFC7234]).
</p>
</blockquote>

<p>
回应给 PUT 方法的响应是<ruby>不可缓存的<rt>not cacheable</rt></ruby>。如果一个<ruby>成功的 PUT 请求<rt>successful PUT request</rt></ruby>穿过一个<ruby>缓存<rt>cache</rt></ruby>，而该缓存已经存储（缓存）了该 PUT 请求的有效请求 URI 所对应的一个或多个响应（也就是说，缓存命中了这个 PUT 请求），那么这些已存储的（已缓存的）响应将会<ruby>被失效<rt>be invalidated</rt></ruby>（见【RFC7234】章节 4.4）。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT">MDN</a> 的总结：
</p>

<p>
The HTTP PUT request method creates a new resource or replaces a representation of the target resource with the request payload.
</p>

<p>
The difference between PUT and POST is that PUT is idempotent: calling it once or several times successively has the same effect (that is no side effect), where successive identical POST may have additional effects, like passing an order several times.
</p>

<dl class="org-dl">
<dt>Request has body</dt><dd>Yes</dd>
<dt>Successful response has body</dt><dd>No</dd>
<dt>Safe</dt><dd>No</dd>
<dt>Idempotent</dt><dd>Yes</dd>
<dt>Cacheable</dt><dd>No</dd>
<dt>Allowed in HTML forms</dt><dd>No</dd>
</dl>
</blockquote>
</div>
</div>

<div id="outline-container-orgf7b2242" class="outline-4">
<h4 id="orgf7b2242"><a id="ID-9e649fa9-0f7f-40d0-adef-8af6a6f62e80"></a>4.3.5. DELETE</h4>
<div class="outline-text-4" id="text-orgf7b2242">
<blockquote>
<p>
The DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the <code>rm</code> command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.
</p>
</blockquote>

<p>
DELETE 方法请求源服务器移除<ruby>目标资源<rt>target resource</rt></ruby>与它<ruby>当前的功能<rt>current functionality</rt></ruby>之间的关联。实际上，该方法与 UNIX 中的 <code>rm</code> 命令非常类似，DELETE 表达了一种作用在映射到源服务器的 URI 之上的删除操作，而不是表达一种删除之前相关联的信息的期望。
</p>

<blockquote>
<p>
If the target resource has one or more current representations, they might or might not be destroyed by the origin server, and the associated storage might or might not be reclaimed, depending entirely on the nature of the resource and its implementation by the origin server (which are beyond the scope of this specification). Likewise, other implementation aspects of a resource might need to be deactivated or archived as a result of a DELETE, such as database or gateway connections. In general, it is assumed that the origin server will only allow DELETE on resources for which it has a prescribed mechanism for accomplishing the deletion.
</p>
</blockquote>

<p>
如果目标资源有一个或多个 current representations，它们可能会也可能不会被源服务器所销毁，另外，它们所关联的存储可能会也可能不会被回收，这完全取决于资源的性质以及服务器对资源的<ruby>实现<rt>implementation</rt></ruby>（已经超出了本规范的范畴）。同样，还可能需要去<ruby>失效<rt>deactivate</rt></ruby>或<ruby>归档<rt>archive</rt></ruby>资源实现的其他方面，来作为一个 DELETE 操作的结果，比如数据库或者网关连接。总之，我们假设源服务器只会允许对这些资源进行 DELETE：具有某种规定机制来完成删除操作的资源。
</p>

<blockquote>
<p>
Relatively few resources allow the DELETE method — its primary use is for remote authoring environments, where the user has some direction regarding its effect. For example, a resource that was previously created using a PUT request, or identified via the <code>Location</code> header field after a <code>201 (Created)</code> response to a POST request, might allow a corresponding DELETE request to undo those actions. Similarly, custom user agent implementations that implement an authoring function, such as revision control clients using HTTP for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository.
</p>
</blockquote>

<p>
相对较少的资源会允许 DELETE 方法，它主要应用在用户会有某些关于它的影响效果的指导的<ruby>远程编辑环境<rt>remote authoring environments</rt></ruby>中。例如，在以前使用一个 PUT 请求来创建好的某个资源，或者是在回应给 POST 请求的一个 <code>201 (Created)</code> 响应以后，该响应里的 <code>Location</code> 报头域所标识的某个资源，可能会允许使用一个对应的 DELETE 请求来<ruby>撤消<rt>undo</rt></ruby>这些动作。类似的，实现某种<ruby>编辑方法<rt>authoring function</rt></ruby>的<ruby>定制的用户代理实现<rt>custom user agent implementations</rt></ruby>，比如使用 HTTP 来进行远程操作的<ruby>版本管理客户端<rt>revision control clients</rt></ruby>，可能会基于“服务器的 <ruby>URI 空间<rt>URI space</rt></ruby>是经过精心设计来对应某个版本仓库”的这种假设来使用 DELETE。
</p>

<blockquote>
<p>
译注：URI space 参考【<a href="https://tools.ietf.org/html/rfc5785">RFC5785</a>】Defining Well-Known Uniform Resource Identifiers (URIs)
</p>
</blockquote>

<blockquote>
<p>
If a DELETE method is successfully applied, the origin server <b>SHOULD</b> send a <code>202 (Accepted)</code> status code if the action will likely succeed but has not yet been enacted, a <code>204 (No Content)</code> status code if the action has been enacted and no further information is to be supplied, or a <code>200 (OK)</code> status code if the action has been enacted and the response message includes a representation describing the status.
</p>
</blockquote>

<p>
如果成功执行了一次 DELETE 方法，如果该动作可能会成功但确定的结果还未<ruby>出现<rt>enacted</rt></ruby>，源服务器 <b>应当</b> 回应一个 <code>202 (Accepted)</code> 响应；如果该动作的结果已经出现了并且服务器不会再提供更多的信息，<b>应当</b> 回应一个 <code>204 (No Content)</code> 响应；或者如果该动作的结果已经出现了并且响应会包含一个 representation 来描述资源的状态，该响应的状态码 <b>应当</b> 是 <code>200 (OK)</code> 。
</p>

<blockquote>
<p>
A payload within a DELETE request message has no defined semantics; sending a payload body on a DELETE request might cause some existing implementations to reject the request.
</p>
</blockquote>

<p>
在 DELETE 请求里的<ruby>有效载荷<rt>payload</rt></ruby>并没有定义任何的语义，如果在 DELETE 请求里带有一个有效载荷可能会导致某些现有的<ruby>实现<rt>implementations</rt></ruby>拒绝该请求。
</p>

<blockquote>
<p>
Responses to the DELETE method are not cacheable. If a DELETE request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see <a href="https://tools.ietf.org/html/rfc7234#section-4.4">Section 4.4</a> of [RFC7234]).
</p>
</blockquote>

<p>
回应给 DELETE 方法的响应是<ruby>不可缓存的<rt>not cacheable</rt></ruby>。如果一个 DELETE 请求穿过一个<ruby>缓存<rt>cache</rt></ruby>，而该缓存已经存储（缓存）了该 DELETE 请求的有效请求 URI 所对应的一个或多个响应（也就是说，缓存命中了这个 DELETE 请求），那么这些已存储的（已缓存的）响应将会<ruby>被失效<rt>be invalidated</rt></ruby>（见<a href="https://tools.ietf.org/html/rfc7234#section-4.4">【RFC7234】章节 4.4</a>）。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE">MDN</a> 的总结：
</p>

<p>
The HTTP DELETE request method deletes the specified resource.
</p>

<dl class="org-dl">
<dt>Request has body</dt><dd>May</dd>
<dt>Successful response has body</dt><dd>May</dd>
<dt>Safe</dt><dd>No</dd>
<dt>Idempotent</dt><dd>Yes</dd>
<dt>Cacheable</dt><dd>No</dd>
<dt>Allowed in HTML forms</dt><dd>No</dd>
</dl>
</blockquote>
</div>
</div>

<div id="outline-container-org3103350" class="outline-4">
<h4 id="org3103350"><a id="ID-630ab908-5d8e-400b-bed4-f6973b8c1549"></a>4.3.6. CONNECT</h4>
<div class="outline-text-4" id="text-org3103350">
<blockquote>
<p>
The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed. Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security, [<a href="https://tools.ietf.org/html/rfc5246">RFC5246</a>]).
</p>
</blockquote>

<p>
CONNECT 方法请求让对方（接收端）与<ruby>请求目标<rt>request-target</rt></ruby>所标识的源服务器<ruby>建立<rt>establish</rt></ruby>一个<ruby>隧道<rt>tunnel</rt></ruby>，并且如果建立成功以后，将接收端的行为限制为双向<ruby>盲目转发<rt>blind forwarding</rt></ruby>数据包，直到隧道被关闭为止。隧道常常用于创建一种穿越一个或多个<ruby>代理<rt>proxies</rt></ruby>的<ruby>端到端<rt>end-to-end</rt></ruby>的<ruby>虚拟连接<rt>virtual connection</rt></ruby>，然后能够安全使用 TLS（Transport Layer Security，【<a href="https://tools.ietf.org/html/rfc5246">RFC5246</a>】）。
</p>

<blockquote>
<p>
译注：需要注意的是，并不是 CONNECT 请求的发送端与源服务器建立隧道，而是 CONNECT 接收端与源服务器建立隧道，这个要清楚。
</p>
</blockquote>

<blockquote>
<p>
CONNECT is intended only for use in requests to a proxy. An origin server that receives a CONNECT request for itself <b>MAY</b> respond with a <code>2xx (Successful)</code> status code to indicate that a connection is established. However, most origin servers do not implement CONNECT.
</p>
</blockquote>

<p>
CONNECT 只能用在向代理发送的请求里。源服务器接收到一个发送给它自己的 CONNECT 请求时，<b>可以</b> 回应一个 <code>2xx (Successful)</code> 状态码来表明连接已被建立好。但是，大多数源服务器并没有<ruby>实现<rt>implement</rt></ruby> CONNECT。
</p>

<blockquote>
<p>
A client sending a CONNECT request <b>MUST</b> send the authority form of request-target (<a href="RFC7230.html#ID-16a8fba9-40f8-4b2c-ba5f-2f6522362c3a">Section 5.3</a> of [RFC7230]); i.e., the request-target consists of only the host name and port number of the tunnel destination, separated by a colon. For example,
</p>
</blockquote>

<p>
发送 CONNECT 请求的客户端 <b>必须</b> 以 authority-form（权威形式）的形式来发送<ruby>请求目标<rt>request-target</rt></ruby>（<a href="RFC7230.html#ID-16a8fba9-40f8-4b2c-ba5f-2f6522362c3a">【RFC7230】章节 5.3</a>），也就是说，请求目标仅由隧道终点的<ruby>主机名称<rt>host name</rt></ruby>以及<ruby>端口号<rt>port number</rt></ruby>组成，以冒号分隔。例如：
</p>

<pre class="example">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80

</pre>

<blockquote>
<p>
译注：上例是有一个<ruby>空行<rt>blank line</rt></ruby>的，表示<ruby>报头块<rt>header section</rt></ruby>结束，报文结构的更多详情见<a href="RFC7230.html#ID-6e9516fa-cde2-4693-b1e1-e763776d3186">【RFC7230】章节 3</a>。
</p>
</blockquote>

<blockquote>
<p>
The recipient proxy can establish a tunnel either by directly connecting to the request-target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy. Any <code>2xx (Successful)</code> response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the blank line that concludes the successful response's header section; data received after that blank line is from the server identified by the request-target. Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.
</p>
</blockquote>

<p>
作为接收端的<ruby>代理<rt>proxy</rt></ruby>能够通过以下方式建立一个隧道：直接连接到请求目标；或者，如果该代理被配置为使用另一个代理的话，转发该 CONNECT 请求到下一个<ruby>入站代理<rt>inbound proxy</rt></ruby>。任何 <code>2xx (Successful)</code> 响应都表明发送端（以及所有入站代理）将会在成功响应的<ruby>报头块<rt>header section</rt></ruby>末尾的空行（该空行表示报头块结束）以后，马上切换为<ruby>隧道模式<rt>tunnel mode</rt></ruby>，而在这个空行之后所接收到的数据，是来自由<ruby>请求目标<rt>request target</rt></ruby>所标识的源服务器的。其他任何不是表示成功的响应则表明这个隧道还没有形成，该连接仍然受到 HTTP 支配（而不是由隧道所扩展的协议来支配，例如 TLS）。
</p>

<blockquote>
<p>
这里涉及到 HTTP 的报文结构和参与的多种角色，如果对这些概念还不够熟悉的话，请先浏览【<a href="RFC7230.html">RFC7230</a>】里的章节 2 和 3。
</p>
</blockquote>

<blockquote>
<p>
A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary <b>MUST</b> attempt to send any outstanding data that came from the closed side to the other side, close both connections, and then discard any remaining data left undelivered.
</p>
</blockquote>

<p>
当<ruby>隧道中间人<rt>tunnel intermediary</rt></ruby>检测到隧道两端都已关闭了连接的时候，隧道被关闭。中间人 <b>必须</b> 尝试发送所有<ruby>未偿付的数据<rt>outstanding data</rt></ruby>，从被关闭的一端发送到另一端，然后关闭两端的连接，最后丢弃掉任何还<ruby>未投递出去<rt>undelivered</rt></ruby>的数据。
</p>

<blockquote>
<p>
Proxy authentication might be used to establish the authority to create a tunnel. For example,
</p>
</blockquote>

<p>
<ruby>代理认证<rt>proxy authentication</rt></ruby>可能被用来<ruby>确立权威<rt>establish authority</rt></ruby>来创建一个隧道，例如：
</p>

<pre class="example">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=

</pre>

<blockquote>
<p>
There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic. For example, a CONNECT to a request-target of "example.com:25" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support CONNECT <b>SHOULD</b> restrict its use to a limited set of known ports or a configurable whitelist of safe request targets.
</p>
</blockquote>

<p>
向任意的服务器建立隧道会有严重的风险，特别是当隧道的终点是一个不作为<ruby>网站流量<rt>Web traffic</rt></ruby>的 TCP <ruby>知名端口<rt>well-known port</rt></ruby>或者<ruby>保留端口<rt>reserved port</rt></ruby>的时候。例如，请求目标为 "example.com:25" 的 CONNECT 请求会建议代理连接到用于 SMTP 流量的保留端口上，如果允许这样做，就会欺骗代理去<ruby>中转<rt>relaying</rt></ruby>垃圾邮件。因此，支持 CONNECT 的代理 <b>应当</b> 将 CONNECT 的使用限制到一个已知的有限的端口集合上，或者一个安全的可配置的请求目标白名单上。
</p>

<blockquote>
<p>
A server <b>MUST NOT</b> send any <code>Transfer-Encoding</code> or <code>Content-Length</code> header fields in a <code>2xx (Successful)</code> response to CONNECT. A client <b>MUST</b> ignore any <code>Content-Length</code> or <code>Transfer-Encoding</code> header fields received in a successful response to CONNECT.
</p>
</blockquote>

<p>
服务器 <b>禁止</b> 在一个回应给 CONNECT 的 <code>2xx (Successful)</code> 响应中带有任何 <code>Transfer-Encoding</code> 或者 <code>Content-Length</code> 报头域。客户端 <b>必须</b> 在其接收到的回应给 CONNECT 的成功响应里，忽略掉任何 <code>Content-Length</code> 或者 <code>Transfer-Encoding</code> 报头域。
</p>

<blockquote>
<p>
A payload within a CONNECT request message has no defined semantics; sending a payload body on a CONNECT request might cause some existing implementations to reject the request.
</p>
</blockquote>

<p>
在 CONNECT 请求报文里的有效载荷是没有定义任何语义的，如果在 CONNECT 请求里带有一个有效载荷可能会导致某些现有的<ruby>实现<rt>implementations</rt></ruby>拒绝该请求。
</p>

<blockquote>
<p>
Responses to the CONNECT method are not cacheable.
</p>
</blockquote>

<p>
回应给 CONNECT 方法的响应是<ruby>不可缓存的<rt>not cacheable</rt></ruby>。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT">MDN</a> 的总结：
</p>

<p>
The HTTP CONNECT method method starts two-way communications with the requested resource. It can be used to open a tunnel.
</p>

<p>
For example, the CONNECT method can be used to access websites that use SSL (HTTPS). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.
</p>

<p>
CONNECT is a hop-by-hop method.
</p>

<dl class="org-dl">
<dt>Request has body</dt><dd>No</dd>
<dt>Successful response has body</dt><dd>Yes</dd>
<dt>Safe</dt><dd>No</dd>
<dt>Idempotent</dt><dd>No</dd>
<dt>Cacheable</dt><dd>No</dd>
<dt>Allowed in HTML forms</dt><dd>No</dd>
</dl>
</blockquote>
</div>
</div>

<div id="outline-container-org85c174f" class="outline-4">
<h4 id="org85c174f"><a id="ID-f659b35f-7510-4961-ad3a-3ab1b312a681"></a>4.3.7. OPTIONS</h4>
<div class="outline-text-4" id="text-org85c174f">
<blockquote>
<p>
The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action.
</p>
</blockquote>

<p>
OPTIONS 方法请求获得可用于目标资源的<ruby>通信选项<rt>communication options</rt></ruby>的有关信息，这些信息是在源服务器或者介于客户端和源服务器之间的中间人上的。本方法让客户端在没有对资源执行相关动作的情况下，就可以确定与资源有关的选项和（或者）要求，或者服务器的功能。
</p>

<blockquote>
<p>
An OPTIONS request with an asterisk ("*") as the request-target (<a href="RFC7230.html#ID-16a8fba9-40f8-4b2c-ba5f-2f6522362c3a">Section 5.3</a> of [RFC7230]) applies to the server in general rather than to a specific resource. Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof).
</p>
</blockquote>

<p>
如果要向服务器执行 OPTIONS 请求，一般是使用一个星号（"*"），而不是一个具体的资源，来作为请求目标（<a href="RFC7230.html#ID-16a8fba9-40f8-4b2c-ba5f-2f6522362c3a">【RFC7230】章节 5.3</a>）。这是因为服务器的通信选项一般依赖于资源，"*" 请求仅作为方法的一种 "ping" 或者“空操作” 时才有用处，除了让客户端可以去测试服务器的功能以外，它并没有做任何其他事情。例如，用它来测试一个代理是否遵循 HTTP/1.1 规范。
</p>

<blockquote>
<p>
If the request-target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.
</p>
</blockquote>

<p>
如果请求目标不是使用<ruby>星号形式<rt>asterisk-form</rt></ruby>，那么，OPTIONS 请求所应用到的选项是可用在与目标资源通信的。
</p>

<blockquote>
<p>
A server generating a successful response to OPTIONS <b>SHOULD</b> send any header fields that might indicate optional features implemented by the server and applicable to the target resource (e.g., <code>Allow</code>), including potential extensions not defined by this specification. The response payload, if any, might also describe the communication options in a machine or human-readable representation. A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP. A server <b>MUST</b> generate a <code>Content-Length</code> field with a value of "0" if no payload body is to be sent in the response.
</p>
</blockquote>

<p>
服务器在向 OPTIONS 生成一个成功响应的时候，<b>应当</b> 带有所有可能指明以下信息的报头域：由服务器所实现的可选功能，并且这些可选功能是可作用于目标资源的（例如，<code>Allow</code>）。这些报头域还应当包括那些未定义在本规范里的扩展报头域，如果有的话。如果响应里包含有效载荷，那么还可能描述了机器的通信选项，或者供人类阅读的 representation 的通信选项。对于这样一种 representation，本规范并没有定义一种标准格式，但可能会在将来的 HTTP 扩展中进行定义。服务器 <b>禁止</b> 生成带有一个 "0" 值的 <code>Content-Length</code> 报头域，如果该响应没有包含有效载荷的话。
</p>

<blockquote>
<p>
A client <b>MAY</b> send a <code>Max-Forwards</code> header field in an OPTIONS request to target a specific recipient in the request chain (see <a href="#org57067e1">Section 5.1.2</a>). A proxy <b>MUST NOT</b> generate a <code>Max-Forwards</code> header field while forwarding a request unless that request was received with a <code>Max-Forwards</code> field.
</p>
</blockquote>

<p>
客户端 <b>可以</b> 在一个 OPTIONS 请求中带有一个 <code>Max-Forwards</code> 报头域，以便在请求链路中对一个具体的接收端进行定位（见<a href="#org57067e1">章节 5.1.2</a>）。代理 <b>禁止</b> 在转发请求的时候生成一个 <code>Max-Forwards</code> 报头域，除非该请求本身已带有一个 <code>Max-Forwards</code> 报头域。
</p>

<blockquote>
<p>
A client that generates an OPTIONS request containing a payload body <b>MUST</b> send a valid <code>Content-Type</code> header field describing the representation media type. Although this specification does not define any use for such a payload, future extensions to HTTP might use the OPTIONS body to make more detailed queries about the target resource.
</p>
</blockquote>

<p>
客户端生成一个 OPTIONS 请求的时候，如果该请求包含一个有效载荷，那么，该请求 <b>必须</b> 带有一个有效的 <code>Content-Type</code> 报头域来描述 representation 的媒体类型。虽然本规范并没有对这样一种有效载荷的用途进行过任何定义，但将来的 HTTP 扩展中可能会使用 OPTIONS 请求的报文正文来携带目标资源有关的更细致的查询信息。
</p>

<blockquote>
<p>
Responses to the OPTIONS method are not cacheable.
</p>
</blockquote>

<p>
回应给 OPTIONS 方法的响应是<ruby>不可缓存的<rt>not cacheable</rt></ruby>。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS">MDN</a> 的总结：
</p>

<p>
The HTTP OPTIONS method is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.
</p>

<dl class="org-dl">
<dt>Request has body</dt><dd>No</dd>
<dt>Successful response has body</dt><dd>Yes</dd>
<dt>Safe</dt><dd>Yes</dd>
<dt>Idempotent</dt><dd>Yes</dd>
<dt>Cacheable</dt><dd>No</dd>
<dt>Allowed in HTML forms</dt><dd>No</dd>
</dl>
</blockquote>
</div>
</div>

<div id="outline-container-orgda48f54" class="outline-4">
<h4 id="orgda48f54"><a id="ID-bdc9e3b4-bac3-46c5-9319-31f7f4d6469d"></a>4.3.8. TRACE</h4>
<div class="outline-text-4" id="text-orgda48f54">
<blockquote>
<p>
The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request <b>SHOULD</b> reflect the message received, excluding some fields described below, back to the client as the message body of a <code>200 (OK)</code> response with a <code>Content-Type</code> of "message/http" (<a href="RFC7230.html#ID-44492A0E-8B7F-46EC-890D-317BC32E2228">Section 8.3.1</a> of [RFC7230]). The final recipient is either the origin server or the first server to receive a <code>Max-Forwards</code> value of zero (0) in the request (<a href="#org57067e1">Section 5.1.2</a>).
</p>
</blockquote>

<p>
TRACE 方法请求一个远程的、应用层的请求报文<ruby>回路<rt>loop-back</rt></ruby>。请求链路中的<ruby>最终接收端<rt>final recipient</rt></ruby> <b>应当</b> 原样<ruby>反映<rt>reflect</rt></ruby>它所接收到的报文，排除掉下文所述的那些报头域，作为一个带有值为 "message/http"（<a href="RFC7230.html#ID-44492A0E-8B7F-46EC-890D-317BC32E2228">【RFC7230】章节 8.3.1</a>）的 <code>Content-Type</code> 的 <code>200 (OK)</code> 响应的报文正文，最后返回给客户端。最终接收端指的是源服务器，或者是在请求链路中第一个接收到 Max-Forwards 值为 0 的请求报文的服务器（<a href="#org57067e1">章节 5.1.2</a>）。
</p>

<blockquote>
<p>
A client <b>MUST NOT</b> generate header fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials [<a href="RFC7235.html">RFC7235</a>] or cookies [<a href="https://tools.ietf.org/html/rfc6265">RFC6265</a>] in a TRACE request. The final recipient of the request <b>SHOULD</b> exclude any request header fields that are likely to contain sensitive data when that recipient generates the response body.
</p>
</blockquote>

<p>
客户端 <b>禁止</b> 在一个 TRACE 请求里生成以下这种报头域：包含有<ruby>敏感数据<rt>sensitive data</rt></ruby>的，并且这些敏感数据有可能会被响应<ruby>曝露<rt>disclosed</rt></ruby>出来的。例如，用户代理在一个 TRACE 请求里包含有存放在本地的<ruby>用户证书<rt>user credentials</rt></ruby>【<a href="RFC7235.html">RFC7235</a>】或者 cookies【<a href="https://tools.ietf.org/html/rfc6265">RFC6265</a>】，这种做法是非常愚蠢的。请求的<ruby>最终接收端<rt>final recipient</rt></ruby>在生成响应正文的时候，<b>应当</b> 排除掉任何有可能包含敏感数据的请求报头域。
</p>

<blockquote>
<p>
TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the <code>Via</code> header field (<a href="RFC7230.html#ID-4a38d632-e412-4122-8ae5-0d58ab8f3d6a">Section 5.7.1</a> of [RFC7230]) is of particular interest, since it acts as a trace of the request chain. Use of the <code>Max-Forwards</code> header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
</p>
</blockquote>

<p>
TRACE 让客户端能够观察到请求链路的另一端将会接收到什么数据，并且让客户端可以使用这些数据来测试或者诊断信息。在这些数据之中，<code>Via</code> 报头域（<a href="RFC7230.html#ID-4a38d632-e412-4122-8ae5-0d58ab8f3d6a">【RFC7230】章节 5.7.1</a>）的值是特别让人感兴趣的数据之一，这是因为它记录了请求链路的轨迹。使用 <code>Max-Forwards</code> 报头域可以让客户端对请求链路的长度进行限制，这对测试一条代理链路是否在无限循环转发报文是非常有用的。
</p>

<blockquote>
<p>
A client <b>MUST NOT</b> send a message body in a TRACE request.
</p>
</blockquote>

<p>
客户端 <b>禁止</b> 在一个 TRACE 请求里带有一个报文正文。
</p>

<blockquote>
<p>
Responses to the TRACE method are not cacheable.
</p>
</blockquote>

<p>
回应给 TRACE 方法的响应是<ruby>不可缓存的<rt>not cacheable</rt></ruby>。
</p>

<blockquote>
<p>
译注：来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE">MDN</a> 的总结：
</p>

<p>
The HTTP TRACE method performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.
</p>

<p>
The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a Content-Type of message/http. The final recipient is either the origin server or the first server to receive a Max-Forwards value of 0 in the request.
</p>

<dl class="org-dl">
<dt>Request has body</dt><dd>No</dd>
<dt>Successful response has body</dt><dd>No</dd>
<dt>Safe</dt><dd>No</dd>
<dt>Idempotent</dt><dd>Yes</dd>
<dt>Cacheable</dt><dd>No</dd>
<dt>Allowed in HTML forms</dt><dd>No</dd>
</dl>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-org478df38" class="outline-2">
<h2 id="org478df38"><a id="ID-f8e7b063-496f-473e-95e8-88ec76f21582"></a>5. 请求报头域 / Request Header Fields</h2>
<div class="outline-text-2" id="text-org478df38">
<blockquote>
<p>
A client sends request header fields to provide more information about the request context, make the request conditional based on the target resource state, suggest preferred formats for the response, supply authentication credentials, or modify the expected request processing. These fields act as request modifiers, similar to the parameters on a programming language method invocation.
</p>
</blockquote>

<p>
客户端发送<ruby>请求报头域<rt>request header fields</rt></ruby>来提供更多请求上下文的相关信息，基于目标资源的状态来使请求<ruby>条件化<rt>conditional</rt></ruby>，提议响应的<ruby>首选格式<rt>preferred formats</rt></ruby>，提供身份凭证，或者更改预期的请求处理。这些报头域充当请求的<ruby>修饰符<rt>modifiers</rt></ruby>，类似于一门编程语言里用于函数调用的参数一样。
</p>
</div>

<div id="outline-container-org8542bda" class="outline-3">
<h3 id="org8542bda">5.1. 控制 / Controls</h3>
<div class="outline-text-3" id="text-org8542bda">
<blockquote>
<p>
Controls are request header fields that direct specific handling of the request.
</p>
</blockquote>

<p>
控制相关的请求报头域的作用是指导请求的具体处理。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Defined in&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Cache-Control</td>
<td class="org-left"><a href="RFC7234.html#ID-03c2dad4-a6d2-4d3c-b087-d08717bf09ec">Section 5.2</a> of [RFC7234]</td>
</tr>

<tr>
<td class="org-left">Expect</td>
<td class="org-left"><a href="#org83b8384">Section 5.1.1</a></td>
</tr>

<tr>
<td class="org-left">Host</td>
<td class="org-left"><a href="RFC7230.html#ID-f6cd08fd-597f-4b1d-98ad-a1730125abdc">Section 5.4</a> of [RFC7230]</td>
</tr>

<tr>
<td class="org-left">Max-Forwards</td>
<td class="org-left"><a href="#org57067e1">Section 5.1.2</a></td>
</tr>

<tr>
<td class="org-left">Pragma</td>
<td class="org-left"><a href="RFC7234.html#ID-8414ec2d-e5b5-4f9c-8160-c354c12b7504">Section 5.4</a> of [RFC7234]</td>
</tr>

<tr>
<td class="org-left">Range</td>
<td class="org-left"><a href="RFC7233.html#ID-a70b4aaa-f776-4d5b-a31d-60d1ad16d85e">Section 3.1</a> of [RFC7233]</td>
</tr>

<tr>
<td class="org-left">TE</td>
<td class="org-left"><a href="RFC7230.html#ID-2BA944C9-6215-4B88-8F5F-D5CACA865191">Section 4.3</a> of [RFC7230]</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org83b8384" class="outline-4">
<h4 id="org83b8384"><a id="ID-0b0cea12-0af7-47f1-8908-2afc48ce3fb2"></a>5.1.1. Expect</h4>
<div class="outline-text-4" id="text-org83b8384">
<p>
The "Expect" header field in a request indicates a certain set of behaviors (expectations) that need to be supported by the server in order to properly handle this request. The only such expectation defined by this specification is 100-continue.
</p>

<p>
请求报文里的 <code>Expect</code> 报头域指明了一个确定的<ruby>行为<rt>behaviors</rt></ruby>（<ruby>期望<rt>expectations</rt></ruby>）集合，这些期望需要通过服务器的支持来实现，以使得这个请求得以妥善处理。<code>100-continue</code> 是仅有的由本规范所定义的期望。
</p>

<div class="org-src-container">
<pre class="src src-text">Expect  = "100-continue"
</pre>
</div>

<blockquote>
<p>
The <code>Expect</code> field-value is case-insensitive.
</p>
</blockquote>

<p>
<code>Expect</code> 的值是不区分大小写的。
</p>

<blockquote>
<p>
A server that receives an <code>Expect</code> field-value other than <code>100-continue</code> <b>MAY</b> respond with a <code>417 (Expectation Failed)</code> status code to indicate that the unexpected expectation cannot be met.
</p>
</blockquote>

<p>
如果服务器接收到一个带有 <code>Expect</code> 报头域的请求，但其域值并不是 <code>100-continue</code>，那么，服务器 <b>可以</b> 回应一个 <code>417 (Expectation Failed)</code> 状态的响应来指明不能遇到<ruby>意料之外的期望<rt>unexpected expectation</rt></ruby>（也就是说，服务器仅能处理 <code>100-continue</code> 这种期望）。
</p>

<blockquote>
<p>
A <code>100-continue</code> expectation informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a <code>100 (Continue)</code> interim response if the request-line and header fields are not sufficient to cause an immediate success, redirect, or error response. This allows the client to wait for an indication that it is worthwhile to send the message body before actually doing so, which can improve efficiency when the message body is huge or when the client anticipates that an error is likely (e.g., when sending a state-changing method, for the first time, without previously verified authentication credentials).
</p>
</blockquote>

<p>
<code>100-continue</code> 这个期望向接收端告知了这样一个信息：客户端即将在本次请求中发送一个（假定是很大的）报文正文，如果之前所发送的请求行以及报头域不足以引起一个立即成功、重定向或者错误响应的时候，它希望能够从接收端那里接收到一个 <code>100 (Continue)</code> 的过渡响应，让客户端在真正要发送这个报文正文之前，可以等待服务器的指示来确认是否有必要发送这个报文正文。这样做在报文正文的体积巨大，或者客户端预见到可能出现错误（例如，当首次发送一个<ruby>会改变资源状态的请求方法<rt>state-changing method</rt></ruby>的时候没有预先校验身份凭证）的情况下，可以提高效率。
</p>

<blockquote>
<p>
译注：<ruby>过渡响应<rt>interim response</rt></ruby>是相对于<ruby>最终响应<rt>final response</rt></ruby>来说的。过渡响应即所有 <code>1xx</code> 状态码的响应，所有非 <code>1xx</code> 状态码的响应都是最终响应。
</p>
</blockquote>

<blockquote>
<p>
For example, a request that begins with
</p>
</blockquote>

<p>
例如，请求报文的起始内容如下：
</p>

<pre class="example">
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue

</pre>

<blockquote>
<p>
allows the origin server to immediately respond with an error message, such as <code>401 (Unauthorized)</code> or <code>405 (Method Not Allowed)</code>, before the client starts filling the pipes with an unnecessary data transfer.
</p>
</blockquote>

<p>
这个请求让源服务器可以在客户端向管道连接里填充不必要的数据流之前，立即响应一个错误报文，比如 <code>401 (Unauthorized)</code> 或者 <code>405 (Method Not Allowed)</code>。
</p>

<blockquote>
<p>
Requirements for clients:
</p>

<ul class="org-ul">
<li>A client <b>MUST NOT</b> generate a <code>100-continue</code> expectation in a request that does not include a message body.</li>
<li>A client that will wait for a <code>100 (Continue)</code> response before sending the request message body <b>MUST</b> send an <code>Expect</code> header field containing a <code>100-continue</code> expectation.</li>
<li>A client that sends a <code>100-continue</code> expectation is not required to wait for any specific length of time; such a client <b>MAY</b> proceed to send the message body even if it has not yet received a response. Furthermore, since <code>100 (Continue)</code> responses cannot be sent through an HTTP/1.0 intermediary, such a client <b>SHOULD NOT</b> wait for an indefinite period before sending the message body.</li>
<li>A client that receives a <code>417 (Expectation Failed)</code> status code in response to a request containing a <code>100-continue</code> expectation <b>SHOULD</b> repeat that request without a <code>100-continue</code> expectation, since the <code>417</code> response merely indicates that the response chain does not support expectations (e.g., it passes through an HTTP/1.0 server).</li>
</ul>
</blockquote>

<p>
对于客户端的要求：
</p>
<ul class="org-ul">
<li>客户端 <b>禁止</b> 在一个没有<ruby>报文正文<rt>message body</rt></ruby>的请求里生成一个 <code>100-continue</code> 期望。</li>
<li>客户端在发送请求的报文正文之前，如果打算等待服务器的 <code>100 (Continue)</code>，<b>必须</b> 发送一个包含 <code>100-continue</code> 期望的 <code>Expect</code> 报头域。</li>
<li>客户端在发送了一个 <code>100-continue</code> 期望以后，并不要求去等待任意具体的时长。这时候客户端甚至 <b>可以</b> 在未接收到任何响应的情况下就开始发送报文正文。再者，由于 <code>100 (Continue)</code> 响应不能经由一个 HTTP/1.0 中间人来发送，因此，客户端 <b>不应当</b> 在发送报文正文之前无限期地等待。</li>
<li>客户端接收到一个 <code>417 (Expectation Failed)</code> 状态码的响应，该响应是回应给一个包含 <code>100-continue</code> 期望的请求的，这时候，客户端 <b>应当</b> 在不再带有 <code>100-continue</code> 期望的情况下再次发起这个请求，这是因为该 417 响应只不过是表明该<ruby>响应链路<rt>response chain</rt></ruby>并不支持期望（比如，它经过一个 HTTP/1.0 服务器）。</li>
</ul>

<blockquote>
<p>
译注：HTTP/1.0 并没有定义任何 1xx 的状态码，所以不支持在 HTTP/1.0 上使用 <code>100-continue</code>。
</p>
</blockquote>

<blockquote>
<p>
Requirements for servers:
</p>

<ul class="org-ul">
<li>A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.</li>
<li>A server MAY omit sending a 100 (Continue) response if it has already received some or all of the message body for the corresponding request, or if the framing indicates that there is no message body.</li>
<li>A server that sends a 100 (Continue) response MUST ultimately send a final status code, once the message body is received and processed, unless the connection is closed prematurely.</li>
<li>A server that responds with a final status code before reading the entire message body SHOULD indicate in that response whether it intends to close the connection or continue reading and discarding the request message (see Section 6.6 of [RFC7230]).</li>
</ul>
</blockquote>

<blockquote>
<p>
An origin server <b>MUST</b>, upon receiving an HTTP/1.1 (or later) request-line and a complete header section that contains a 100-continue expectation and indicates a request message body will follow, either send an immediate response with a final status code, if that status can be determined by examining just the request-line and header fields, or send an immediate 100 (Continue) response to encourage the client to send the request's message body. The origin server MUST NOT wait for the message body before sending the 100 (Continue) response.
</p>
</blockquote>

<blockquote>
<p>
A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and a complete header section that contains a 100-continue expectation and indicates a request message body will follow, either send an immediate response with a final status code, if that status can be determined by examining just the request-line and header fields, or begin forwarding the request toward the origin server by sending a corresponding request-line and header section to the next inbound server. If the proxy believes (from configuration or past interaction) that the next inbound server only supports HTTP/1.0, the proxy MAY generate an immediate 100 (Continue) response to encourage the client to begin sending the message body.
</p>
</blockquote>

<blockquote>
<p>
<b>Note:</b> The Expect header field was added after the original publication of HTTP/1.1 [RFC2068] as both the means to request an interim 100 (Continue) response and the general mechanism for indicating must-understand extensions. However, the extension mechanism has not been used by clients and the must-understand requirements have not been implemented by many servers, rendering the extension mechanism useless. This specification has removed the extension mechanism in order to simplify the definition and processing of 100-continue.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org57067e1" class="outline-4">
<h4 id="org57067e1"><a id="ID-4c0e6435-a276-48fb-8cb8-32b8ef5a2780"></a>5.1.2. Max-Forwards</h4>
<div class="outline-text-4" id="text-org57067e1">
<blockquote>
<p>
The "Max-Forwards" header field provides a mechanism with the TRACE (Section 4.3.8) and OPTIONS (Section 4.3.7) request methods to limit the number of times that the request is forwarded by proxies. This can be useful when the client is attempting to trace a request that appears to be failing or looping mid-chain.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Max-Forwards = 1*DIGIT
</pre>
</div>

<blockquote>
<p>
The Max-Forwards value is a decimal integer indicating the remaining number of times this request message can be forwarded.
</p>
</blockquote>

<blockquote>
<p>
Each intermediary that receives a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request. If the received value is zero (0), the intermediary MUST NOT forward the request; instead, the intermediary MUST respond as the final recipient. If the received Max-Forwards value is greater than zero, the intermediary MUST generate an updated Max-Forwards field in the forwarded message with a field-value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for Max-Forwards.
</p>
</blockquote>

<blockquote>
<p>
A recipient MAY ignore a Max-Forwards header field received with any other request methods.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org8c0da01" class="outline-3">
<h3 id="org8c0da01"><a id="ID-b21923d5-a8f9-4560-8592-92fd9a098bf4"></a>5.2. 条件 / Conditionals</h3>
<div class="outline-text-3" id="text-org8c0da01">
<p>
The HTTP conditional request header fields [RFC7232] allow a client to place a precondition on the state of the target resource, so that the action corresponding to the method semantics will not be applied if the precondition evaluates to false. Each precondition defined by this specification consists of a comparison between a set of validators obtained from prior representations of the target resource to the current state of validators for the selected representation (Section 7.2). Hence, these preconditions evaluate whether the state of the target resource has changed since a given state known by the client. The effect of such an evaluation depends on the method semantics and choice of conditional, as defined in Section 5 of [RFC7232].
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Defined in&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">If-Match</td>
<td class="org-left">Section 3.1 of [RFC7232]</td>
</tr>

<tr>
<td class="org-left">If-None-Match</td>
<td class="org-left">Section 3.2 of [RFC7232]</td>
</tr>

<tr>
<td class="org-left">If-Modified-Since</td>
<td class="org-left">Section 3.3 of [RFC7232]</td>
</tr>

<tr>
<td class="org-left">If-Unmodified-Since</td>
<td class="org-left">Section 3.4 of [RFC7232]</td>
</tr>

<tr>
<td class="org-left">If-Range</td>
<td class="org-left">Section 3.2 of [RFC7233]</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org07183ec" class="outline-3">
<h3 id="org07183ec">5.3. 内容协商 / Content Negotiation</h3>
<div class="outline-text-3" id="text-org07183ec">
<p>
The following request header fields are sent by a user agent to engage in proactive negotiation of the response content, as defined in Section 3.4.1. The preferences sent in these fields apply to any content in the response, including representations of the target resource, representations of error or processing status, and potentially even the miscellaneous text strings that might appear within the protocol.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Defined in&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Accept</td>
<td class="org-left">Section 5.3.2</td>
</tr>

<tr>
<td class="org-left">Accept-Charset</td>
<td class="org-left">Section 5.3.3</td>
</tr>

<tr>
<td class="org-left">Accept-Encoding</td>
<td class="org-left">Section 5.3.4</td>
</tr>

<tr>
<td class="org-left">Accept-Language</td>
<td class="org-left">Section 5.3.5</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org6e3f7bd" class="outline-4">
<h4 id="org6e3f7bd">5.3.1. Quality Values</h4>
<div class="outline-text-4" id="text-org6e3f7bd">
<blockquote>
<p>
Many of the request header fields for proactive negotiation use a common parameter, named "q" (case-insensitive), to assign a relative "weight" to the preference for that associated kind of content. This weight is referred to as a "quality value" (or "qvalue") because the same parameter name is often used within server configurations to assign a weight to the relative quality of the various representations that can be selected for a resource.
</p>
</blockquote>

<blockquote>
<p>
The weight is normalized to a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means "not acceptable". If no "q" parameter is present, the default weight is 1.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">weight = OWS ";" OWS "q=" qvalue
qvalue = ( "0" [ "." 0*3DIGIT ] )
       / ( "1" [ "." 0*3("0") ] )
</pre>
</div>

<blockquote>
<p>
A sender of qvalue <b>MUST NOT</b> generate more than three digits after the decimal point. User configuration of these values ought to be limited in the same fashion.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgd78f0e9" class="outline-4">
<h4 id="orgd78f0e9"><a id="ID-95575604-c3d4-48d6-a061-325bd7798970"></a>5.3.2. Accept</h4>
<div class="outline-text-4" id="text-orgd78f0e9">
<blockquote>
<p>
The "Accept" header field can be used by user agents to specify response media types that are acceptable. Accept header fields can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept = #( media-range [ accept-params ] )

media-range    = ( "*/*"
                 / ( type "/" "*" )
                 / ( type "/" subtype )
                 ) *( OWS ";" OWS parameter )
accept-params  = weight *( accept-ext )
accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
</pre>
</div>

<blockquote>
<p>
The asterisk "*" character is used to group media types into ranges, with "<b>/</b>" indicating all media types and "type/*" indicating all subtypes of that type. The media-range can include media type parameters that are applicable to that range.
</p>
</blockquote>

<blockquote>
<p>
Each media-range might be followed by zero or more applicable media type parameters (e.g., charset), an optional "q" parameter for indicating a relative weight (Section 5.3.1), and then zero or more extension parameters. The "q" parameter is necessary if any extensions (accept-ext) are present, since it acts as a separator between the two parameter sets.
</p>
</blockquote>

<blockquote>
<p>
<b>Note:</b> Use of the "q" parameter name to separate media type parameters from Accept extension parameters is due to historical practice. Although this prevents any media type parameter named "q" from being used with a media range, such an event is believed to be unlikely given the lack of any "q" parameters in the IANA media type registry and the rare usage of any media type parameters in Accept. Future media types are discouraged from registering any parameter named "q".
</p>
</blockquote>

<blockquote>
<p>
The example
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept: audio/*; q=0.2, audio/basic
</pre>
</div>

<blockquote>
<p>
is interpreted as "I prefer audio/basic, but send me any audio type if it is the best available after an 80% markdown in quality".
</p>
</blockquote>

<blockquote>
<p>
A request without any Accept header field implies that the user agent will accept any media type in response. If the header field is present in a request and none of the available representations for the response have a media type that is listed as acceptable, the origin server can either honor the header field by sending a 406 (Not Acceptable) response or disregard the header field by treating the response as if it is not subject to content negotiation.
</p>
</blockquote>

<blockquote>
<p>
A more elaborate example is
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept: text/plain; q=0.5, text/html,
        text/x-dvi; q=0.8, text/x-c
</pre>
</div>

<blockquote>
<p>
Verbally, this would be interpreted as "text/html and text/x-c are the equally preferred media types, but if they do not exist, then send the text/x-dvi representation, and if that does not exist, send the text/plain representation".
</p>
</blockquote>

<blockquote>
<p>
Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence. For example,
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept: text/*, text/plain, text/plain;format=flowed, */*
</pre>
</div>

<blockquote>
<p>
have the following precedence:
</p>

<ol class="org-ol">
<li>text/plain;format=flowed</li>
<li>text/plain</li>
<li>text/*</li>
<li><b>/</b></li>
</ol>
</blockquote>

<blockquote>
<p>
The media type quality factor associated with a given type is determined by finding the media range with the highest precedence that matches the type. For example,
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
        text/html;level=2;q=0.4, */*;q=0.5
</pre>
</div>

<blockquote>
<p>
would cause the following values to be associated:
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Media Type</th>
<th scope="col" class="org-right">Quality Valut</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">text/html;level=1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">text/html</td>
<td class="org-right">0.7</td>
</tr>

<tr>
<td class="org-left">text/plain</td>
<td class="org-right">0.3</td>
</tr>

<tr>
<td class="org-left">image/jpeg</td>
<td class="org-right">0.5</td>
</tr>

<tr>
<td class="org-left">text/html;level=2</td>
<td class="org-right">0.4</td>
</tr>

<tr>
<td class="org-left">text/html;level=3</td>
<td class="org-right">0.7</td>
</tr>
</tbody>
</table>

<blockquote>
<p>
<b>Note:</b> A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent is a closed system that cannot interact with other rendering agents, this default set ought to be configurable by the user.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org5919b30" class="outline-4">
<h4 id="org5919b30">5.3.3. Accept-Charset</h4>
<div class="outline-text-4" id="text-org5919b30">
<blockquote>
<p>
The "Accept-Charset" header field can be sent by a user agent to indicate what charsets are acceptable in textual response content. This field allows user agents capable of understanding more comprehensive or special-purpose charsets to signal that capability to an origin server that is capable of representing information in those charsets.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept-Charset = 1#( ( charset / "*" ) [ weight ] )
</pre>
</div>

<blockquote>
<p>
Charset names are defined in Section 3.1.1.2. A user agent MAY associate a quality value with each charset to indicate the user's relative preference for that charset, as defined in Section 5.3.1. An example is
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</pre>
</div>

<blockquote>
<p>
The special value "*", if present in the Accept-Charset field, matches every charset that is not mentioned elsewhere in the Accept-Charset field. If no "*" is present in an Accept-Charset field, then any charsets not explicitly mentioned in the field are considered "not acceptable" to the client.
</p>
</blockquote>

<blockquote>
<p>
A request without any Accept-Charset header field implies that the user agent will accept any charset in response. Most general-purpose user agents do not send Accept-Charset, unless specifically configured to do so, because a detailed list of supported charsets makes it easier for a server to identify an individual by virtue of the user agent's request characteristics (Section 9.7).
</p>
</blockquote>

<blockquote>
<p>
If an Accept-Charset header field is present in a request and none of the available representations for the response has a charset that is listed as acceptable, the origin server can either honor the header field, by sending a 406 (Not Acceptable) response, or disregard the header field by treating the resource as if it is not subject to content negotiation.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org6451ddf" class="outline-4">
<h4 id="org6451ddf"><a id="ID-a8fcc101-3782-4ed0-aec0-561b933e6a5f"></a>5.3.4. Accept-Encoding</h4>
<div class="outline-text-4" id="text-org6451ddf">
<blockquote>
<p>
The "Accept-Encoding" header field can be used by user agents to indicate what response content-codings (Section 3.1.2.1) are acceptable in the response. An "identity" token is used as a synonym for "no encoding" in order to communicate when no encoding is preferred.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept-Encoding  = #( codings [ weight ] )
codings          = content-coding / "identity" / "*"
</pre>
</div>

<blockquote>
<p>
Each codings value MAY be given an associated quality value representing the preference for that encoding, as defined in Section 5.3.1. The asterisk "*" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field.
</p>
</blockquote>

<blockquote>
<p>
For example,
</p>
</blockquote>

<pre class="example">
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</pre>

<blockquote>
<p>
A request without an Accept-Encoding header field implies that the user agent has no preferences regarding content-codings. Although this allows the server to use any content-coding in a response, it does not imply that the user agent will be able to correctly process all encodings.
</p>
</blockquote>

<blockquote>
<p>
A server tests whether a content-coding for a given representation is acceptable using these rules:
</p>

<ol class="org-ol">
<li>If no Accept-Encoding field is in the request, any content-coding is considered acceptable by the user agent.</li>
<li>If the representation has no content-coding, then it is acceptable by default unless specifically excluded by the Accept-Encoding field stating either "identity;q=0" or "*;q=0" without a more specific entry for "identity".</li>
<li>If the representation's content-coding is one of the content-codings listed in the Accept-Encoding field, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in Section 5.3.1, a qvalue of 0 means "not acceptable".)</li>
<li>If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.</li>
</ol>
</blockquote>

<blockquote>
<p>
An <code>Accept-Encoding</code> header field with a combined field-value that is empty implies that the user agent does not want any content-coding in response. If an Accept-Encoding header field is present in a request and none of the available representations for the response have a content-coding that is listed as acceptable, the origin server SHOULD send a response without any content-coding.
</p>
</blockquote>

<blockquote>
<p>
<b>Note:</b> Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings. This means that qvalues might not work and are not permitted with x-gzip or x-compress.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org39787e1" class="outline-4">
<h4 id="org39787e1">5.3.5. Accept-Language</h4>
<div class="outline-text-4" id="text-org39787e1">
<blockquote>
<p>
The "Accept-Language" header field can be used by user agents to indicate the set of natural languages that are preferred in the response. Language tags are defined in Section 3.1.3.1.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Accept-Language = 1#( language-range [ weight ] )
language-range  = 
          &lt;language-range, see [RFC4647], Section 2.1&gt;
</pre>
</div>

<blockquote>
<p>
Each language-range can be given an associated quality value representing an estimate of the user's preference for the languages specified by that range, as defined in Section 5.3.1. For example,
</p>
</blockquote>

<pre class="example">
Accept-Language: da, en-gb;q=0.8, en;q=0.7
</pre>

<blockquote>
<p>
would mean: "I prefer Danish, but will accept British English and other types of English".
</p>
</blockquote>

<blockquote>
<p>
A request without any Accept-Language header field implies that the user agent will accept any language in response. If the header field is present in a request and none of the available representations for the response have a matching language tag, the origin server can either disregard the header field by treating the response as if it is not subject to content negotiation or honor the header field by sending a 406 (Not Acceptable) response. However, the latter is not encouraged, as doing so can prevent users from accessing content that they might be able to use (with translation software, for example).
</p>
</blockquote>

<blockquote>
<p>
Note that some recipients treat the order in which language tags are listed as an indication of descending priority, particularly for tags that are assigned equal quality values (no value is the same as q=1). However, this behavior cannot be relied upon. For consistency and to maximize interoperability, many user agents assign each language tag a unique quality value while also listing them in order of decreasing quality. Additional discussion of language priority lists can be found in Section 2.3 of [RFC4647].
</p>
</blockquote>

<blockquote>
<p>
For matching, Section 3 of [RFC4647] defines several matching schemes. Implementations can offer the most appropriate matching scheme for their requirements. The "Basic Filtering" scheme ([RFC4647], Section 3.3.1) is identical to the matching scheme that was previously defined for HTTP in Section 14.4 of [RFC2616].
</p>
</blockquote>

<blockquote>
<p>
It might be contrary to the privacy expectations of the user to send an Accept-Language header field with the complete linguistic preferences of the user in every request (Section 9.7).
</p>
</blockquote>

<blockquote>
<p>
Since intelligibility is highly dependent on the individual user, user agents need to allow user control over the linguistic preference (either through configuration of the user agent itself or by defaulting to a user controllable system setting). A user agent that does not provide such control to the user MUST NOT send an Accept-Language header field.
</p>
</blockquote>

<blockquote>
<p>
<b>Note:</b> User agents ought to provide guidance to users when setting a preference, since users are rarely familiar with the details of language matching as described above. For example, users might assume that on selecting "en-gb", they will be served any kind of English document if British English is not available. A user agent might suggest, in such a case, to add "en" to the list for better matching behavior.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgeec6089" class="outline-3">
<h3 id="orgeec6089">5.4. 身份验证凭证 / Authentication Credentials</h3>
<div class="outline-text-3" id="text-orgeec6089">
<blockquote>
<p>
Two header fields are used for carrying authentication credentials, as defined in [RFC7235]. Note that various custom mechanisms for user authentication use the Cookie header field for this purpose, as defined in [RFC6265].
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Defined in&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Authorization</td>
<td class="org-left">Section 4.2 of [RFC7235]</td>
</tr>

<tr>
<td class="org-left">Proxy-Authorization</td>
<td class="org-left">Section 4.4 of [RFC7235]</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org178e82e" class="outline-3">
<h3 id="org178e82e">5.5. 请求上下文/ Request Context</h3>
<div class="outline-text-3" id="text-org178e82e">
<blockquote>
<p>
The following request header fields provide additional information about the request context, including information about the user, user agent, and resource behind the request.
</p>
</blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Defined in&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Form</td>
<td class="org-left">Section 5.5.1</td>
</tr>

<tr>
<td class="org-left">Referer</td>
<td class="org-left">Section 5.5.2</td>
</tr>

<tr>
<td class="org-left">User-Agent</td>
<td class="org-left">Section 5.5.3</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org0e7c143" class="outline-4">
<h4 id="org0e7c143">5.5.1. Form</h4>
<div class="outline-text-4" id="text-org0e7c143">
<blockquote>
<p>
The "From" header field contains an Internet email address for a human user who controls the requesting user agent. The address ought to be machine-usable, as defined by "mailbox" in Section 3.4 of [RFC5322]:
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">From    = mailbox

mailbox = &lt;mailbox, see [RFC5322], Section 3.4&gt;
</pre>
</div>

<blockquote>
<p>
An example is:
</p>
</blockquote>

<pre class="example">
From: webmaster@example.org
</pre>

<blockquote>
<p>
The From header field is rarely sent by non-robotic user agents. A user agent <b>SHOULD NOT</b> send a From header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy.
</p>
</blockquote>

<blockquote>
<p>
A robotic user agent <b>SHOULD</b> send a valid From header field so that the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.
</p>
</blockquote>

<blockquote>
<p>
A server <b>SHOULD NOT</b> use the From header field for access control or authentication, since most recipients will assume that the field value is public information.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orga439d85" class="outline-4">
<h4 id="orga439d85">5.5.2. Referer</h4>
<div class="outline-text-4" id="text-orga439d85">
<blockquote>
<p>
The "Referer" [sic] header field allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the "referrer", though the field name is misspelled). A user agent MUST NOT include the fragment and userinfo components of the URI reference [RFC3986], if any, when generating the Referer field value.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">Referer = absolute-URI / partial-URI
</pre>
</div>

<blockquote>
<p>
The Referer header field allows servers to generate back-links to other resources for simple analytics, logging, optimized caching, etc. It also allows obsolete or mistyped links to be found for maintenance. Some servers use the Referer header field as a means of denying links from other sites (so-called "deep linking") or restricting cross-site request forgery (CSRF), but not all requests contain it.
</p>
</blockquote>

<blockquote>
<p>
Example:
</p>
</blockquote>

<pre class="example">
Referer: http://www.example.org/hypertext/Overview.html
</pre>

<blockquote>
<p>
If the target URI was obtained from a source that does not have its own URI (e.g., input from the user keyboard, or an entry within the user's bookmarks/favorites), the user agent MUST either exclude the Referer field or send it with a value of "about:blank".
</p>
</blockquote>

<blockquote>
<p>
The Referer field has the potential to reveal information about the request context or browsing history of the user, which is a privacy concern if the referring resource's identifier reveals personal information (such as an account name) or a resource that is supposed to be confidential (such as behind a firewall or internal to a secured service). Most general-purpose user agents do not send the Referer header field when the referring resource is a local "file" or "data" URI. A user agent MUST NOT send a Referer header field in an unsecured HTTP request if the referring page was received with a secure protocol. See Section 9.4 for additional security considerations.
</p>
</blockquote>

<blockquote>
<p>
Some intermediaries have been known to indiscriminately remove Referer header fields from outgoing requests. This has the unfortunate side effect of interfering with protection against CSRF attacks, which can be far more harmful to their users. Intermediaries and user agent extensions that wish to limit information disclosure in Referer ought to restrict their changes to specific edits, such as replacing internal domain names with pseudonyms or truncating the query and/or path components. An intermediary SHOULD NOT modify or delete the Referer header field when the field value shares the same scheme and host as the request target.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org382027f" class="outline-4">
<h4 id="org382027f">5.5.3. User-Agent</h4>
<div class="outline-text-4" id="text-org382027f">
<blockquote>
<p>
The "User-Agent" header field contains information about the user agent originating the request, which is often used by servers to help identify the scope of reported interoperability problems, to work around or tailor responses to avoid particular user agent limitations, and for analytics regarding browser or operating system use. A user agent SHOULD send a User-Agent field in each request unless specifically configured not to do so.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">User-Agent = product *( RWS ( product / comment ) )
</pre>
</div>

<blockquote>
<p>
The User-Agent field-value consists of one or more product identifiers, each followed by zero or more comments (Section 3.2 of [RFC7230]), which together identify the user agent software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software. Each product identifier consists of a name and optional version.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">product         = token ["/" product-version]
product-version = token
</pre>
</div>

<blockquote>
<p>
A sender <b>SHOULD</b> limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier. A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).
</p>
</blockquote>

<blockquote>
<p>
Example:
</p>
</blockquote>

<pre class="example">
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</pre>

<blockquote>
<p>
A user agent <b>SHOULD NOT</b> generate a User-Agent field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties. Overly long and detailed User-Agent field values increase request latency and the risk of a user being identified against their wishes ("fingerprinting").
</p>
</blockquote>

<blockquote>
<p>
Likewise, implementations are encouraged not to use the product tokens of other implementations in order to declare compatibility with them, as this circumvents the purpose of the field. If a user agent masquerades as a different user agent, recipients can assume that the user intentionally desires to see responses tailored for that identified user agent, even if they might not work as well for the actual user agent being used.
</p>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-org1463c22" class="outline-2">
<h2 id="org1463c22"><a id="ID-5a69d0cc-628c-4897-a089-45f906b94a92"></a>6. 响应状态码 / Response Status Codes</h2>
<div class="outline-text-2" id="text-org1463c22">
</div>
<div id="outline-container-org5d42953" class="outline-3">
<h3 id="org5d42953">6.1. 状态码概况 / Overview of Status Codes</h3>
</div>
<div id="outline-container-org937cde4" class="outline-3">
<h3 id="org937cde4">6.2. 信息性 1xx / Informational 1xx</h3>
<div class="outline-text-3" id="text-org937cde4">
</div>
<div id="outline-container-orgb177ae0" class="outline-4">
<h4 id="orgb177ae0">6.2.1. 100 Continue</h4>
</div>
<div id="outline-container-org17170cb" class="outline-4">
<h4 id="org17170cb">6.2.2. 101 Switching Protocols</h4>
</div>
</div>
<div id="outline-container-orge3be6d7" class="outline-3">
<h3 id="orge3be6d7">6.3. 成功 2xx / Successful 2xx</h3>
<div class="outline-text-3" id="text-orge3be6d7">
</div>
<div id="outline-container-org0038347" class="outline-4">
<h4 id="org0038347">6.3.1. 200 OK</h4>
</div>
<div id="outline-container-org7621bcc" class="outline-4">
<h4 id="org7621bcc">6.3.2. 201 Created</h4>
</div>
<div id="outline-container-org90994de" class="outline-4">
<h4 id="org90994de">6.3.3. 202 Accepted</h4>
</div>
<div id="outline-container-org3a69f3a" class="outline-4">
<h4 id="org3a69f3a">6.3.4. 203 Non-Authoritative Information</h4>
</div>
<div id="outline-container-org61ddd38" class="outline-4">
<h4 id="org61ddd38">6.3.5. 204 No Content</h4>
</div>
<div id="outline-container-org9d78f6e" class="outline-4">
<h4 id="org9d78f6e">6.3.6. 205 Reset Content</h4>
</div>
</div>
<div id="outline-container-orgdf0960e" class="outline-3">
<h3 id="orgdf0960e">6.4. 重定向 3xx / Redirection 3xx</h3>
<div class="outline-text-3" id="text-orgdf0960e">
</div>
<div id="outline-container-org6a26035" class="outline-4">
<h4 id="org6a26035">6.4.1. 300 Multiple Choices</h4>
</div>
<div id="outline-container-orgdd25815" class="outline-4">
<h4 id="orgdd25815">6.4.2. 301 Moved Permanently</h4>
</div>
<div id="outline-container-org1dd45d0" class="outline-4">
<h4 id="org1dd45d0">6.4.3. 302 Found</h4>
</div>
<div id="outline-container-orga14232d" class="outline-4">
<h4 id="orga14232d">6.4.4. 303 See Other</h4>
</div>
<div id="outline-container-orgbea7275" class="outline-4">
<h4 id="orgbea7275">6.4.5. 305 Use Proxy</h4>
</div>
<div id="outline-container-orgcefeee6" class="outline-4">
<h4 id="orgcefeee6">6.4.6. 306 (Unused)</h4>
</div>
<div id="outline-container-orgd9247a2" class="outline-4">
<h4 id="orgd9247a2">6.4.7. 307 Temporary Redirect</h4>
</div>
</div>
<div id="outline-container-org187c176" class="outline-3">
<h3 id="org187c176">6.5. 客户端错误 / Client Error 4xx</h3>
<div class="outline-text-3" id="text-org187c176">
</div>
<div id="outline-container-org6b99dfb" class="outline-4">
<h4 id="org6b99dfb">6.5.1. 400 Bad Request</h4>
</div>
<div id="outline-container-org42c217d" class="outline-4">
<h4 id="org42c217d">6.5.2. 402 Payment Required</h4>
</div>
<div id="outline-container-org86089b5" class="outline-4">
<h4 id="org86089b5">6.5.3. 403 Forbidden</h4>
</div>
<div id="outline-container-org6ef9040" class="outline-4">
<h4 id="org6ef9040">6.5.4. 404 Not Found</h4>
</div>
<div id="outline-container-org9297a17" class="outline-4">
<h4 id="org9297a17">6.5.5. 405 Method Not Allowed</h4>
</div>
<div id="outline-container-orgdf502e9" class="outline-4">
<h4 id="orgdf502e9">6.5.6. 406 Not Acceptable</h4>
</div>
<div id="outline-container-org2a53d18" class="outline-4">
<h4 id="org2a53d18">6.5.7. 408 Request Timeout</h4>
</div>
<div id="outline-container-org010d0a2" class="outline-4">
<h4 id="org010d0a2">6.5.8. 409 Conflict</h4>
</div>
<div id="outline-container-org4072a5f" class="outline-4">
<h4 id="org4072a5f">6.5.9. 410 Gone</h4>
</div>
<div id="outline-container-org014abbd" class="outline-4">
<h4 id="org014abbd">6.5.10. 411 Length Required</h4>
</div>
<div id="outline-container-org7f816ee" class="outline-4">
<h4 id="org7f816ee">6.5.11. 413 Payload Too Large</h4>
</div>
<div id="outline-container-orgda225c7" class="outline-4">
<h4 id="orgda225c7">6.5.12. 414 URI Too Long</h4>
</div>
<div id="outline-container-org9aaec2d" class="outline-4">
<h4 id="org9aaec2d">6.5.13. 415 Unsupported Media Type</h4>
</div>
<div id="outline-container-orgcafc9ce" class="outline-4">
<h4 id="orgcafc9ce">6.5.14. 417 Expectation Failed</h4>
</div>
<div id="outline-container-org4cc1a60" class="outline-4">
<h4 id="org4cc1a60">6.5.15. 426 Upgrade Required</h4>
</div>
</div>
<div id="outline-container-orgbb53da7" class="outline-3">
<h3 id="orgbb53da7">6.6 服务器错误 / Server Error 5xx</h3>
<div class="outline-text-3" id="text-orgbb53da7">
</div>
<div id="outline-container-orge703f96" class="outline-4">
<h4 id="orge703f96">6.6.1. 500 Internal Server Error</h4>
</div>
<div id="outline-container-org42220c0" class="outline-4">
<h4 id="org42220c0">6.6.2. 501 Not Implemented</h4>
</div>
<div id="outline-container-orgb9f52eb" class="outline-4">
<h4 id="orgb9f52eb">6.6.3. 502 Bad Gateway</h4>
</div>
<div id="outline-container-orgda430f7" class="outline-4">
<h4 id="orgda430f7">6.6.4. 503 Service Unavailable</h4>
</div>
<div id="outline-container-orgb821e4f" class="outline-4">
<h4 id="orgb821e4f">6.6.5. 504 Gateway Timeout</h4>
</div>
<div id="outline-container-org1131bac" class="outline-4">
<h4 id="org1131bac">6.6.6. 505 HTTP Version Not Supported</h4>
</div>
</div>
</div>
<div id="outline-container-org32d1acf" class="outline-2">
<h2 id="org32d1acf"><a id="ID-30e7b781-4a14-4519-abb9-63ec43516b98"></a>7. 响应报头域 / Response Header Fields</h2>
<div class="outline-text-2" id="text-org32d1acf">
</div>
<div id="outline-container-orge68fb41" class="outline-3">
<h3 id="orge68fb41">7.1. Control Data</h3>
<div class="outline-text-3" id="text-orge68fb41">
</div>
<div id="outline-container-org67adfb6" class="outline-4">
<h4 id="org67adfb6">7.1.1. Origination Date</h4>
<div class="outline-text-4" id="text-org67adfb6">
</div>
<div id="outline-container-org8c425df" class="outline-5">
<h5 id="org8c425df">7.1.1.1. Date/Time Formats</h5>
</div>
<div id="outline-container-org8e5ec45" class="outline-5">
<h5 id="org8e5ec45"><a id="ID-5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1"></a>7.1.1.2. Data</h5>
<div class="outline-text-5" id="text-org8e5ec45">
</div>
</div>
</div>
<div id="outline-container-orgad9277e" class="outline-4">
<h4 id="orgad9277e"><a id="ID-bc2baf29-0bf6-4816-865c-3d33f5fe38e3"></a>7.1.2. Location</h4>
<div class="outline-text-4" id="text-orgad9277e">
</div>
</div>
<div id="outline-container-orgbf05a48" class="outline-4">
<h4 id="orgbf05a48">7.1.3. Retry-After</h4>
</div>
<div id="outline-container-org5ddc30c" class="outline-4">
<h4 id="org5ddc30c"><a id="ID-ca7f8781-b183-4563-a90a-b9b7ad4f1032"></a>7.1.4. Vary</h4>
<div class="outline-text-4" id="text-org5ddc30c">
</div>
</div>
</div>
<div id="outline-container-org4d2e5ff" class="outline-3">
<h3 id="org4d2e5ff"><a id="ID-efd98bfe-3f3c-4d75-9fa9-041a5af2f917"></a>7.2. Validator Header Fields</h3>
<div class="outline-text-3" id="text-org4d2e5ff">
</div>
</div>
<div id="outline-container-org847a265" class="outline-3">
<h3 id="org847a265">7.3. Authentication Challenges</h3>
</div>
<div id="outline-container-orgee15c9d" class="outline-3">
<h3 id="orgee15c9d">7.4. Response Context</h3>
<div class="outline-text-3" id="text-orgee15c9d">
</div>
<div id="outline-container-orgbfaeb5b" class="outline-4">
<h4 id="orgbfaeb5b"><a id="ID-f8577773-512f-4d68-8f5d-444368db7c29"></a>7.4.1. Allow</h4>
<div class="outline-text-4" id="text-orgbfaeb5b">
</div>
</div>
<div id="outline-container-orgb253800" class="outline-4">
<h4 id="orgb253800">7.4.2. Server</h4>
</div>
</div>
</div>
<div id="outline-container-orgb1bfeaa" class="outline-2">
<h2 id="orgb1bfeaa">8. IANA 注意事项 / IANA Considerations</h2>
<div class="outline-text-2" id="text-orgb1bfeaa">
</div>
<div id="outline-container-org04dcb6c" class="outline-3">
<h3 id="org04dcb6c"><a id="ID-193d7ad5-9c6d-4bf7-98f1-6984a42af639"></a>8.1. 方法注册表 / Method Registry</h3>
<div class="outline-text-3" id="text-org04dcb6c">
</div>
<div id="outline-container-orgbd9a42f" class="outline-4">
<h4 id="orgbd9a42f">8.1.1. Procedure</h4>
</div>
<div id="outline-container-orgba5b1d5" class="outline-4">
<h4 id="orgba5b1d5">8.1.2. Considerations for New Methods</h4>
</div>
<div id="outline-container-org4689641" class="outline-4">
<h4 id="org4689641">8.1.3. Registrations</h4>
</div>
</div>
<div id="outline-container-orgbd7074f" class="outline-3">
<h3 id="orgbd7074f">8.2. 状态码注册表 / Status Code Registry</h3>
<div class="outline-text-3" id="text-orgbd7074f">
</div>
<div id="outline-container-org97fd11b" class="outline-4">
<h4 id="org97fd11b">8.2.1. Procedure</h4>
</div>
<div id="outline-container-org0c87ec2" class="outline-4">
<h4 id="org0c87ec2">8.2.2. Considerations for New Status Codes</h4>
</div>
<div id="outline-container-org091139b" class="outline-4">
<h4 id="org091139b">8.2.3. Registrations</h4>
</div>
</div>
<div id="outline-container-orgc36cdf1" class="outline-3">
<h3 id="orgc36cdf1">8.3. 报头域注册表 / Header Field Registry</h3>
<div class="outline-text-3" id="text-orgc36cdf1">
</div>
<div id="outline-container-org97979b4" class="outline-4">
<h4 id="org97979b4">8.3.1. Considerations for New Header Fields</h4>
</div>
<div id="outline-container-orgc14b9da" class="outline-4">
<h4 id="orgc14b9da">8.3.2. Registrations</h4>
</div>
</div>
<div id="outline-container-orgb8f27ff" class="outline-3">
<h3 id="orgb8f27ff"><a id="ID-87f2ed30-a48b-4c31-a181-8e3a33ba1080"></a>8.4. 内容编码值注册表 / Content Coding Registry</h3>
<div class="outline-text-3" id="text-orgb8f27ff">
</div>
<div id="outline-container-org1c5ac4f" class="outline-4">
<h4 id="org1c5ac4f">8.4.1. Procedure</h4>
</div>
<div id="outline-container-orgbee91f3" class="outline-4">
<h4 id="orgbee91f3">8.4.2. Registrations</h4>
</div>
</div>
</div>
<div id="outline-container-orgc08e2c6" class="outline-2">
<h2 id="orgc08e2c6">9. 安全注意事项 / Security Considerations</h2>
<div class="outline-text-2" id="text-orgc08e2c6">
</div>
<div id="outline-container-org64f3a9f" class="outline-3">
<h3 id="org64f3a9f"><a id="ID-9195be98-bd4e-40ae-a5a0-6af920044f02"></a>9.1. 基于文件和路径名称的攻击 / Attacks Based on File and Path Names</h3>
<div class="outline-text-3" id="text-org64f3a9f">
</div>
</div>
<div id="outline-container-org16209ea" class="outline-3">
<h3 id="org16209ea">9.2. 基于命令、代码、查询注入 / Attacks Based on Command, Code, or Query Injection</h3>
</div>
<div id="outline-container-org088e6f0" class="outline-3">
<h3 id="org088e6f0">9.3. 个人信息的披露 / Disclosure of Personal Information</h3>
</div>
<div id="outline-container-org73c0e2a" class="outline-3">
<h3 id="org73c0e2a">9.4. URLs 敏感信息的披露 / Disclosure of Sensitive Information in URLs</h3>
</div>
<div id="outline-container-org25a250a" class="outline-3">
<h3 id="org25a250a">9.5. Disclosure of Fragment after Redirects</h3>
</div>
<div id="outline-container-org6f777ff" class="outline-3">
<h3 id="org6f777ff">9.6. Disclosure of Product Information</h3>
</div>
<div id="outline-container-org588cbb2" class="outline-3">
<h3 id="org588cbb2">9.7. 浏览器指纹识别 / Browser Fingerprinting</h3>
</div>
</div>
<div id="outline-container-org1702724" class="outline-2">
<h2 id="org1702724">10. 鸣谢 / Acknowledgements</h2>
</div>
<div id="outline-container-org1b106b3" class="outline-2">
<h2 id="org1b106b3">11. 参考资料 / References</h2>
<div class="outline-text-2" id="text-org1b106b3">
</div>
<div id="outline-container-org1cb72c1" class="outline-3">
<h3 id="org1cb72c1">11.1. Normative References</h3>
</div>
<div id="outline-container-orgb0730d9" class="outline-3">
<h3 id="orgb0730d9">11.2. Informative References</h3>
</div>
</div>
<div id="outline-container-orgc9f7ec8" class="outline-2">
<h2 id="orgc9f7ec8"><a id="ID-84208afd-e458-4f40-97cc-2e9535523797"></a>A. HTTP 与 MIME 的区别 / Defferences between HTTP and MIME</h2>
<div class="outline-text-2" id="text-orgc9f7ec8">
</div>
<div id="outline-container-org5e69c70" class="outline-3">
<h3 id="org5e69c70">A.1. MIME-VERSION</h3>
</div>
<div id="outline-container-org6beafbd" class="outline-3">
<h3 id="org6beafbd">A.2. Conversion to Canonical Form</h3>
</div>
<div id="outline-container-org372beac" class="outline-3">
<h3 id="org372beac">A.3. Conversion of Date Formats</h3>
</div>
<div id="outline-container-org6064441" class="outline-3">
<h3 id="org6064441">A.4. Conversion of Content-Encoding</h3>
</div>
<div id="outline-container-org6eb57d2" class="outline-3">
<h3 id="org6eb57d2">A.5. Conversion of Content-Transfer-Encoding</h3>
</div>
<div id="outline-container-orgbad58ce" class="outline-3">
<h3 id="orgbad58ce">A.6. MHTML and Line Length Limitations</h3>
</div>
</div>
<div id="outline-container-org9b37d9f" class="outline-2">
<h2 id="org9b37d9f">B. 相对 RFC 2616 的变化 / Changes from RFC 2616</h2>
</div>
<div id="outline-container-orgc3125d2" class="outline-2">
<h2 id="orgc3125d2">C. 引入的 ABNF 规则 / Imported ABNF</h2>
</div>
<div id="outline-container-org19b465a" class="outline-2">
<h2 id="org19b465a">D. ABNF 规则集合 Collected ABNF</h2>
</div>
<div id="outline-container-org91aa32b" class="outline-2">
<h2 id="org91aa32b">Index</h2>
</div>
<div id="outline-container-org40e7e5d" class="outline-2">
<h2 id="org40e7e5d">Author' Addresses</h2>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Backlink，反向连接，参考 <a href="https://en.wikipedia.org/wiki/Backlink">Wikipedia: Backlink</a>。
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Content Object Tree
</p>
<blockquote>
<p>
a <b>Content Object</b> is a single piece of managed content. Often referred to as simply "content".
</p>

<p>
The suffx of "object" is often used specifically to differentiate an object from its defining content type. For example: The "2016 Annual Report" content object is based on the "Managed Document" content type.
</p>

<p>
a <b>Content Tree</b> is the aggregation of content in a hierarchical tree.
</p>

<p>
Each content object in the tree has a parent (except, of course, for the object at the base of the tree &#x2013; the "root" object), zero or more siblings, and zero or more children. The tree can be used to represent relationships between content objects
</p>

<p>
&#x2013; O'REILLY "<a href="http://flyingsquirrelbook.com/glossary/term/content-object">Web Content Management, SYSTEMS, FEATURES, AND BEST PRACTICES</a>" Deane Barker
</p>
</blockquote></div></div>


</div>
</div></div>
</body>
</html>
