<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-01-07 Mon 12:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RFC7232: Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
* {
  box-sizing: border-box;
}

html {
  padding: 0;
}

body {
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 15px;
  line-height: 1.6;
  padding: 0;
  margin: 0;
  color: #24292e;
  word-wrap: break-word;
}

b, strong {
  font-weight: 700;
}

p {
  margin: 0 0 16px;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a:active, a:hover {
  outline-width: 0;
}

.underline{
  text-decoration: underline;
}

del{
  text-decoration: line-through;
}

i {
  font-style: italic;
}

ul, ol {
  padding-left: 1em;
}

ruby {
  border-bottom: 1px solid #d9d9d9;
}

ruby > rt {
  color: #6a737d;
  text-align: center;
}

h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h1.title {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h1 {
  font-size: 2.5em;
}

.outline-2 h2 {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h3 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
  border-bottom: 1px solid #eaecef;
}

.outline-2 h4 {
  font-size: 1.25em
}

.outline-2 h5 {
  font-size: 1.1em
}

.outline-2 h6 {
  font-size: 1.1em
}

.outline-2 code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;

  color: #c7254e;
  background-color: #f9f2f4;
  white-space: normal;
  font-family: Consolas,Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,sans-serif;
}

.outline-2 table{
  width: 100%;
}

.org-ul,
.org-ol,
.org-dl,
.org-dl > dt,
.org-dl > dd,
.outline-2 p,
.outline-2 blockquote,
.outline-2 table,
.outline-2 pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.org-ul,
.org-ol,
.org-dl {
  padding-left: 2em;
}

.org-dl > dt {
  float: left;
  max-width: 40%;
  margin-bottom: 3px;
  margin-right: 2em;
  font-size: 110%;
  font-family: Courier New;
  font-weight: bolder;
  color: #1c3030;
  clear: left;
}

.org-dl > dd {
  text-align: justify;
  margin-bottom: 14pt;
  overflow: hidden;
  clear: right;
}

table tbody tr:nth-child(odd){
  background-color: #efefef;
}

.org-center {
  text-align: center;
}

.org-left {
  text-align: left;
}

.org-right {
  text-align: right;
}

pre,
blockquote {
  margin-bottom: 1em;
}

pre {
  margin: 0;
  padding: 1em;
  line-height: 1.45;
  font-size: 95%;
  font-family: Consolas,Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,sans-serif;
  border-radius: 3px;
  overflow: auto;
}

blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
  margin: 0;
}

.org-src-container, .example {
  width: 100%;
  overflow-x: auto;
  border-left: 0.25em solid #dfe2e5;
  border-radius: 0.5rem;
  background-color: #f6f8fa;
  margin-bottom: 16px;
}

.org-src-container pre {
  margin-bottom: 0;
}

.timestamp {
  font-family: Courier New;
  color: #888888;
}

#table-of-contents {
  font-size: 9pt;
  position: fixed;
  right: 0em;
  top: 0em;
  background: white;
  -webkit-box-shadow: 0 0 1em #777777;
  -moz-box-shadow: 0 0 1em #777777;
  -webkit-border-bottom-left-radius: 5px;
  -moz-border-radius-bottomleft: 5px;
  text-align: right;
  max-height: 80%;
  overflow: auto;
  z-index: 200;
}

#table-of-contents h2 {
  font-size: 14px;
  font-weight: normal;
  padding: 0 .5em;
  margin: 16px 0;
  text-align: left;
}

#table-of-contents ul {
  margin-left: 14pt;
  margin-bottom: 10pt;
  padding: 0
}

#table-of-contents li {
  padding: 0;
  margin: 1px;
  list-style: none;
}

#table-of-contents ul>:first-child {
  color: blue;
}

#table-of-contents #text-table-of-contents {
  display: none;
  text-align: left;
}

#table-of-contents:hover #text-table-of-contents {
  display: block;
  padding: 0.5em;
  margin-top: -1.5em;
}

#content {
  width: 980px;
  padding: 45px 15px 15px 15px;
  margin-right: auto;
  margin-left: auto;
}

@media screen and (max-width: 980px) {
  #content {
    width: 100%;
  }
  #table-of-contents {
    float: right;
    border: 1px solid #CCC;
    max-width: 75%;
    overflow: auto;
  }
  .org-dl > dt {
    float: none;
  }
}

.footdef {
}
.footdef sup {
  float: left;
  width: 3em;
}
.footdef > .footpara {
  margin-left: 3em;
  overflow-x: hidden;
}
.org-src-container {
  width: 100%;
  overflow-x: auto;
}
.github-repo {
  position: absolute;
  top: 0;
  left: -24px;
  margin-top: 32px;
  padding: 0 20px 0 40px;
  background-color: rgba(0,0,0,.2);
  height: 22px;
  line-height: 22px;
  padding-left: 42px;
  transform: rotate(-45deg);
  transform-origin: 40% 50%;
}
.github-repo:hover,
.github-repo:active {
  text-decoration: none;
}
.github-repo svg {
  position: absolute;
  width: 18px;
  height: 18px;
  left: 20px;
  top: 2px;
}
.github-repo span {
  color: #fff;
}
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">RFC7232: Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9b1b6e8">摘要 / Abstract</a></li>
<li><a href="#org0558c1f">备忘状态 / Status of This Memo</a></li>
<li><a href="#orgd01380a">Copyright Notice</a></li>
<li><a href="#org64b7c38">1. 引言 / Introduction</a>
<ul>
<li><a href="#org4ac137e">1.1. 一致性和错误处理 / Conformance and Error Handling</a></li>
<li><a href="#org5be0b73">1.2. 句法标记 / Syntax Notation</a></li>
</ul>
</li>
<li><a href="#org246112d">2. 验证器 / Validators</a>
<ul>
<li><a href="#org265ee00">2.1. 弱与强 / Weak versus Strong</a></li>
<li><a href="#org3974cdd">2.2. Last-Modified</a>
<ul>
<li><a href="#orgae2fffe">2.2.1. 生成 / Generation</a></li>
<li><a href="#org29822b9">2.2.2. 对比 / Comparison</a></li>
</ul>
</li>
<li><a href="#orgf0f9907">2.3. ETag</a>
<ul>
<li><a href="#orge4892c6">2.3.1. 生成 / Generation</a></li>
<li><a href="#org078e6e7">2.3.2. 对比 / Comparison</a></li>
<li><a href="#orga57841d">2.3.3. 示例：实体标签在内容协商资源上的变化 / Example: Entity-Tags Varying on Content-Negotiated Resources</a></li>
</ul>
</li>
<li><a href="#org9ec4f9e">2.4. 什么时候使用实体标签和最后修改日期 / When to Use Entity-Tags and Last-Modified Dates</a></li>
</ul>
</li>
<li><a href="#org098ebb3">3. 前提条件头字段 / Precondition Header Fields</a>
<ul>
<li><a href="#org220193c">3.1. If-Match</a></li>
<li><a href="#org870b652">3.2. If-None-Match</a></li>
<li><a href="#orgbe71300">3.3. If-Modified-Since</a></li>
<li><a href="#org2f3f176">3.4. If-Unmodified-Since</a></li>
<li><a href="#org76fb615">3.5. If-Range</a></li>
</ul>
</li>
<li><a href="#org1c69e05">4. 状态码定义 / Status Code Definitions</a>
<ul>
<li><a href="#orgf85f7a6">4.1. 304 未更改 / 304 Not Modified</a></li>
<li><a href="#org664c54f">4.2. 412 前提条件失败 / 412 Precondition Failed</a></li>
</ul>
</li>
<li><a href="#org8287389">5. 求值 / Evaluation</a></li>
<li><a href="#org35abd07">6. 优先级 / Precedence</a></li>
<li><a href="#org9097ce2">7. IANA 注意事项 / IANA Considerations</a>
<ul>
<li><a href="#org0a76196">7.1. 状态码登记 / Status Code Registration</a></li>
<li><a href="#orge607eac">7.2. 头字段登记 / Header Field Registration</a></li>
</ul>
</li>
<li><a href="#org01ca2bc">8. 安全注意事项 / Security Considerations</a></li>
<li><a href="#org196768e">9. 鸣谢 / Acknowledgments</a></li>
<li><a href="#org9123b20">10. 参考资料 / References</a>
<ul>
<li><a href="#org8d78b42">10.1. 规范性参考资料 / Normative References</a></li>
<li><a href="#org82edc8f">10.2. 信息性参考资料 / Informative References</a></li>
</ul>
</li>
<li><a href="#orga07aac9">附录 A：相对 RFC 2616 的变化 / Appendix A. Changes from RFC 2616</a></li>
<li><a href="#org4dbc73e">附录 B：引进的 ABNF / Appendix B. Imported ABNF</a></li>
<li><a href="#orgbc516f2">附录 C：ABNF 集合 / Appendix C. Collected ABNF</a></li>
<li><a href="#orgddedd39">Index</a></li>
<li><a href="#org59265de">Authors' Addresses</a></li>
</ul>
</div>
</div>
<a class="github-repo" href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <svg height="18" width="18" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
  <span>View Repo</span>
</a>

<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img alt="" src="https://img.shields.io/github/license/duoani/HTTP-RFCs.zh-cn.svg?style=social"/>
</a>
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img src="https://img.shields.io/github/stars/duoani/HTTP-RFCs.zh-cn.svg?style=social&label=Stars"/>
</a>

<div class="org-src-container">
<pre class="src src-text">                                                       PROPOSED STANDARD
                                                            Errata Exist
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7232                                         Adobe
Obsoletes: 2616                                          J. Reschke, Ed.
Category: Standards Track                                     greenbytes
ISSN: 2070-1721                                                June 2014
</pre>
</div>

<div id="outline-container-org9b1b6e8" class="outline-2">
<h2 id="org9b1b6e8">摘要 / Abstract</h2>
<div class="outline-text-2" id="text-org9b1b6e8">
<blockquote>
<p>
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP/1.1 conditional requests, including metadata header fields for indicating state changes, request header fields for making preconditions on such state, and rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.
</p>
</blockquote>

<p>
超文本传输协议（HTTP）是一种<ruby>无状态<rt>stateless</rt></ruby>的应用层协议，适用于分布式、协作式的超文本信息系统。本文档定义了 HTTP/1.1 条件请求，包括：<ruby>元数据头字段<rt>metadata header fields</rt></ruby>——用于表明状态的改变、<ruby>请求头字段<rt>request header fields</rt></ruby>——用于对这些状态设置前提条件、以及<ruby>规则<rt>rules</rt></ruby>——用于当一个或多个前提条件求值结果为<ruby>假<rt>false</rt></ruby>的时候构造响应给条件请求。
</p>
</div>
</div>

<div id="outline-container-org0558c1f" class="outline-2">
<h2 id="org0558c1f">备忘状态 / Status of This Memo</h2>
<div class="outline-text-2" id="text-org0558c1f">
<blockquote>
<p>
This is an Internet Standards Track document.
</p>
</blockquote>

<blockquote>
<p>
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
</p>
</blockquote>

<blockquote>
<p>
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at <a href="http://www.rfc-editor.org/info/rfc7232">http://www.rfc-editor.org/info/rfc7232</a>.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgd01380a" class="outline-2">
<h2 id="orgd01380a">Copyright Notice</h2>
<div class="outline-text-2" id="text-orgd01380a">
<blockquote>
<p>
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>
</blockquote>

<blockquote>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
</p>
</blockquote>

<blockquote>
<p>
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org64b7c38" class="outline-2">
<h2 id="org64b7c38">1. 引言 / Introduction</h2>
<div class="outline-text-2" id="text-org64b7c38">
<blockquote>
<p>
Conditional requests are HTTP requests [<a href="RFC7231.html">RFC7231</a>] that include one or more header fields indicating a precondition to be tested before applying the method semantics to the target resource. This document defines the HTTP/1.1 conditional request mechanisms in terms of the architecture, syntax notation, and conformance criteria defined in [<a href="RFC7230.html">RFC7230</a>].
</p>
</blockquote>

<p>
<ruby>条件请求<rt>conditional requests</rt></ruby>是这样一种 HTTP 请求【<a href="RFC7231.html">RFC7231</a>】，它包含了一个或多个头字段来表明一种<ruby>前提条件<rt>precondition</rt></ruby>，这种前提条件需要在将方法语义应用到目标资源之前进行测试。本文档依据【<a href="RFC7230.html">RFC7230</a>】所定义的架构、句法标记、以及一致性准则，来定义 HTTP/1.1 条件请求的机制。
</p>

<blockquote>
<p>
Conditional GET requests are the most efficient mechanism for HTTP cache updates [<a href="RFC7234.html">RFC7234</a>]. Conditionals can also be applied to state-changing methods, such as PUT and DELETE, to prevent the "lost update" problem: one client accidentally overwriting the work of another client that has been acting in parallel.
</p>
</blockquote>

<p>
对于 HTTP 缓存更新【<a href="RFC7234.html">RFC7234</a>】来说，条件 GET 请求是最有效的。条件请求也可以被应用到<ruby>状态改变的方法<rt>state-changing methods</rt></ruby>中，比如 PUT 和 DELETE，来预防“<ruby>丢失更新<rt>lost update</rt></ruby>”问题——在并行处理的环境中，一个客户端意外地<ruby>覆盖<rt>overwriting</rt></ruby>了另一个客户端的处理结果。
</p>

<blockquote>
<p>
Conditional request preconditions are based on the state of the target resource as a whole (its current value set) or the state as observed in a previously obtained representation (one value in that set). A resource might have multiple current representations, each with its own observable state. The conditional request mechanisms assume that the mapping of requests to a "selected representation" (<a href="RFC7231.html#ID-7dd837af-fd6a-4918-9c62-cf12a4c31522">Section 3</a> of [RFC7231]) will be consistent over time if the server intends to take advantage of conditionals. Regardless, if the mapping is inconsistent and the server is unable to select the appropriate representation, then no harm will result when the precondition evaluates to false.
</p>
</blockquote>

<p>
总的来说，条件请求的前提条件是基于目标资源的状态（目标资源的<ruby>当前值<rt>current value</rt></ruby>的集合），或者在之前获得的一种表示形式所观察到的状态（这个当前值集合中的其中之一）的。一个资源可以有多种当前表示形式，每个具有它自身可观察到的状态码。如果服务器打算使用条件请求，条件请求的机制会假定请求与一种“<ruby>已选表示形式<rt>selected representation</rt></ruby>”（<a href="RFC7231.html#ID-7dd837af-fd6a-4918-9c62-cf12a4c31522">【RFC7231】章节 3</a>）的映射会随时间的改变而保持一致。不管怎么样，如果这种映射是不一致的，并且服务器不能够选择合适的表示形式，那么，当前提条件的求值结果为假（即条件不成立）的时候，最终结果应该要是无害的。
</p>

<blockquote>
<p>
The conditional request preconditions defined by this specification (<a href="#org098ebb3">Section 3</a>) are evaluated when applicable to the recipient (<a href="#org8287389">Section 5</a>) according to their order of precedence (<a href="#org35abd07">Section 6</a>).
</p>
</blockquote>

<p>
由本规范所定义的条件请求的前提条件（<a href="#org098ebb3">章节 3</a>）会在应用到接收端的时候进行求值（<a href="#org8287389">章节 5</a>），依据它们的优先级顺序（<a href="#org35abd07">章节 6</a>）。
</p>
</div>

<div id="outline-container-org4ac137e" class="outline-3">
<h3 id="org4ac137e">1.1. 一致性和错误处理 / Conformance and Error Handling</h3>
<div class="outline-text-3" id="text-org4ac137e">
<blockquote>
<p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [<a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>].
</p>
</blockquote>

<p>
本文档中的关键词 <b><ruby>必须<rt>MUST</rt></ruby></b>、<b><ruby>禁止<rt>MUST NOT</rt></ruby></b>、<b><ruby>要求<rt>REQUIRED</rt></ruby></b>、<b><ruby>必须<rt>SHALL</rt></ruby></b>、<b><ruby>禁止<rt>SHALL NOT</rt></ruby></b>、<b><ruby>应该<rt>SHOULD</rt></ruby></b>、<b><ruby>不应当<rt>SHOULD NOT</rt></ruby></b>、<b><ruby>推荐<rt>RECOMMENDED</rt></ruby></b>、<b><ruby>可以<rt>MAY</rt></ruby></b> 和 <b><ruby>可选<rt>OPTIONAL</rt></ruby></b> 的意义与【<a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>】一致。
</p>

<blockquote>
<p>
Conformance criteria and considerations regarding error handling are defined in <a href="RFC7230.html#ID-A0441F72-9799-4667-9477-1E05885946A1">Section 2.5</a> of [RFC7230].
</p>
</blockquote>

<p>
关于错误处理的一致性标准以及注意事项已在<a href="RFC7230.html#ID-A0441F72-9799-4667-9477-1E05885946A1">【RFC7230】章节 2.5</a> 中定义了。
</p>
</div>
</div>

<div id="outline-container-org5be0b73" class="outline-3">
<h3 id="org5be0b73">1.2. 句法标记 / Syntax Notation</h3>
<div class="outline-text-3" id="text-org5be0b73">
<blockquote>
<p>
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [<a href="https://tools.ietf.org/html/rfc5234">RFC5234</a>] with a list extension, defined in <a href="RFC7230.html#ID-b9db011d-fe47-4781-929a-4b1b0aa55aec">Section 7</a> of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). <a href="#org4dbc73e">Appendix B</a> describes rules imported from other documents. <a href="#orgbc516f2">Appendix C</a> shows the collected grammar with all list operators expanded to standard ABNF notation.
</p>
</blockquote>

<p>
本规范使用了扩展巴科斯范式（ABNF）标记法【<a href="https://tools.ietf.org/html/rfc5234">RFC5234</a>】，另外，出于定义的紧凑性的考虑，本规范对 ABNF 规则进行了扩展（见<a href="RFC7230.html#ID-b9db011d-fe47-4781-929a-4b1b0aa55aec">【RFC7230】章节 7</a>），允许使用一个 <code>#</code> 操作符（类似于 <code>*</code> 操作符，指代“重复”）来定义一种以逗号分隔的列表。<a href="#org4dbc73e">附录 B</a> 描述了引进自其他文档的规则。<a href="#orgbc516f2">附录 C</a> 展示了所有已收集的包含列表扩展规则以及标准 ABNF 标记的语法。
</p>
</div>
</div>
</div>

<div id="outline-container-org246112d" class="outline-2">
<h2 id="org246112d">2. 验证器 / Validators</h2>
<div class="outline-text-2" id="text-org246112d">
<blockquote>
<p>
This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates (<a href="#org3974cdd">Section 2.2</a>) and opaque entity tags (<a href="#orgf0f9907">Section 2.3</a>). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning (WebDAV, [<a href="https://tools.ietf.org/html/rfc4918">RFC4918</a>]), that are beyond the scope of this specification. A resource metadata value is referred to as a "validator" when it is used within a precondition.
</p>
</blockquote>

<p>
本规范定义了两类元数据：<ruby>修改日期<rt>modification dates</rt></ruby>（<a href="#org3974cdd">章节 2.2</a>）和<ruby>不透明实体标签<rt>opaque entity tags</rt></ruby>（<a href="#orgf0f9907">章节 2.3</a>），它们常用于观察资源的状态以及对前提条件进行测试。其他额外的反映资源状态的元数据定义在各种 HTTP 扩展当中，比如 <ruby>Web 分布式创作和版本管理<rt>Web Distributed Authoring and Versioning</rt></ruby>（WebDAV，【<a href="https://tools.ietf.org/html/rfc4918">RFC4918</a>】），超出了本规范的范畴。<ruby>资源元数据<rt>resource metadata</rt></ruby>的值使用在一个<ruby>前提条件<rt>precondition</rt></ruby>中的时候，它被称为“<ruby>验证器<rt>validator</rt></ruby>”。
</p>

<blockquote>
<p>
译注：可以先将验证器理解为是一种头字段，以方便理解下文。
</p>
</blockquote>
</div>

<div id="outline-container-org265ee00" class="outline-3">
<h3 id="org265ee00"><a id="ID-d232decc-3720-4edf-bbfa-df942f60aa50"></a>2.1. 弱与强 / Weak versus Strong</h3>
<div class="outline-text-3" id="text-org265ee00">
<blockquote>
<p>
Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.
</p>
</blockquote>

<p>
<ruby>验证器<rt>validator</rt></ruby>分成两类：强验证和弱验证。<ruby>弱验证器<rt>weak validators</rt></ruby>容易生成，但对于<ruby>对比<rt>comparisons</rt></ruby>来说几乎没有什么用处。<ruby>强验证器<rt>strong validators</rt></ruby>是理想的对比方式，但它很难有效地生成（有时甚至不可能生成）。与其强制资源的所有形式都附带相同的验证器类型，HTTP 显露出使用中的验证器的类型并对“什么时候弱验证器可以用作前提条件”施加限制。
</p>

<blockquote>
<p>
A "strong validator" is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the payload body of a <code>200 (OK)</code> response to GET.
</p>
</blockquote>

<p>
<ruby>强验证器<rt>strong validator</rt></ruby>是这样一种<ruby>表示形式元数据<rt>representation metadata</rt></ruby>：每当对应的<ruby>表示形式数据<rt>representation data</rt></ruby>的发生变化的时候，它们的值同样会作出改变。这种变化可以在回应给 GET 的 <code>200 (OK)</code> 响应的有效载荷里观察到。
</p>

<blockquote>
<p>
A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., <code>Content-Type</code>), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.
</p>
</blockquote>

<p>
除了表示形式数据发生变化以外，强验证器还可能因为其他原因而发生改变，比如表示形式元数据中语义上的重要组成部分（例如 <code>Content-Type</code>）发生了变化，然而，当有必要让已存储在<ruby>远程缓存服务器<rt>remote caches</rt></ruby>或者<ruby>创作工具<rt>authoring tools</rt></ruby>里的响应<ruby>置为失效<rt>invalidate</rt></ruby>的时候，仅改变它的值是最符合源服务器的最大利益的。
</p>

<blockquote>
<p>
Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).
</p>
</blockquote>

<p>
缓存服务器里的条目可能持续存储到任意长的时间周期中，而不管它的过期时间。这样，缓存服务器可能会试图对它很久以前就获得的条目使用验证器来进行验证。对于一个特定资源相关的所有表示形式的所有版本，不管什么时候强验证器都是唯一的。然而，不同资源的表示形式没有唯一的实现（也就是说，同一个强验证器可能会同时用在多个资源的表示形式中，而且这并不意味着这些表示形式是等价的）。
</p>

<blockquote>
<p>
译注：再说明一下，对于同一个资源，它的所有表示形式的所有版本的 <code>ETag</code> 都是不相同，即它们都是唯一的。但是，不能保证不同资源所使用的 <code>ETag</code> 是唯一的，即它们可能有相同的值。
</p>
</blockquote>

<blockquote>
<p>
There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the [strong] validator to distinguish those representations.
</p>
</blockquote>

<p>
实践中使用了各种各样的强验证器。最好的方式是基于<ruby>严格的版本控制<rt>strict revision control</rt></ruby>，在让 GET 访问之前，对其内的每一个表示形式的每一次修改总是会得到一个唯一的记录节点和版本标识符。要在将要发送响应头字段之前表示形式数据的数据就可使用并且在每次接收到一个验证请求时并不需要重新计算摘要的充分条件是对这份数据应用<ruby>冲突保护<rt>collision-resistant</rt></ruby>的<ruby>散列方法<rt>hash function</rt></ruby>。但是，如果资源的某些表示形式的区别只在于它们的元数据的话，比如可能发生在忽略媒体类型的内容协商导致共享了相同的数据格式的情况，那么，源服务器需要在强验证器内加入额外的信息来区分这些表示形式。
</p>

<blockquote>
<p>
译注：本段有勘误，见 <a href="https://www.rfc-editor.org/errata/eid5236">Errata #5236</a>。
</p>
</blockquote>

<blockquote>
<p>
In contrast, a "weak validator" is representation metadata that might not change for every change to the representation data. This weakness might be due to limitations in how the value is calculated, such as clock resolution, an inability to ensure uniqueness for all possible representations of the resource, or a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data. An origin server <b>SHOULD</b> change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.
</p>
</blockquote>

<p>
作为对比，<ruby>弱验证器<rt>weak validator</rt></ruby>是这样一种<ruby>表示形式元数据<rt>representation metadata</rt></ruby>：对应的表示形式数据每次发生变化的时候，它们的值并不一定会跟随改变。造成这种弱关系的原因可能是：由于计算它的值时的限制，比如<ruby>时间精度<rt>clock resolution</rt></ruby>，无法保证一个资源所有可能的表示形式的唯一性；或者由于资源所有者希望通过某些自主决定的等价规则而不是依据数据序列的唯一性，来对表示形式进行归纳。无论何时，一旦源服务器认为之前的那些表示形式不再能作为当前表示形式的替代的时候，它 <b>应当</b> 改变<ruby>弱实体标签<rt>weak entity-tag</rt></ruby>的值。换句话说，无论何时，一旦源服务器希望缓存服务器将旧的响应<ruby>置为失效<rt>invalidate</rt></ruby>的时候，弱实体标签应该被改变。
</p>

<blockquote>
<p>
For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.
</p>
</blockquote>

<p>
例如，基于动态的天气数据测量，天气报告的表示形式的内容在每一秒都会发生变化，但为了让已缓存的表示形式能够在一个合理的时间周期（这个时间周期可能基于服务器的负载或者天气质量而动态地调整）内仍然有效，可能会使用同一个弱验证器来将这些新产生的表示形式归纳到一系列等价的表示形式里（所谓等价是从源服务器的观点来看）。同样，一个表示形式的修改时间，如果仅仅使用时间精度为一秒来定义的话，而且如果这个表示形式有可能在一秒钟之内被修改两次并在这两次修改之间被请求获取，那么，它可能就是一个弱验证器。
</p>

<blockquote>
<p>
Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, even if those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a <code>gzip</code> content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.
</p>
</blockquote>

<p>
同样，如果一个验证器在同一时间内被一个给定资源的两个或以上表示形式所共享，即使这些表示形式有相同的<ruby>表示形式数据<rt>representation data</rt></ruby>，那么，这个验证器是弱类型的。例如，如果源服务器对于某个资源的一种应用过 <code>gzip</code> 内容编码的表示形式以及一种未应用任何内容编码的表示形式发送的都是相同的验证器，那么，可以确定这个验证器是弱类型的。但是，两个同时生成的表示形式可能共享相同的强验证器，如果它们的区别仅在于表示形式元数据，比如当两个不同的媒体类型都可用于同一份表示形式数据。
</p>

<blockquote>
<p>
译注：本段有勘误，见 <a href="https://www.rfc-editor.org/errata_search.php?rfc=7232">Errata #5236</a>。
</p>
</blockquote>

<blockquote>
<p>
Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and "lost update" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.
</p>
</blockquote>

<p>
强验证器可使用于所有条件请求中，包括：缓存验证、部分内容范围、以及避免“丢失更新”。弱验证器仅能用于当客户端并不要求与之前所获得的表示形式数据完全相等的情况，比如当验证一个缓存条目或者限制一个网页遍历到最近的变更的情况。
</p>
</div>
</div>

<div id="outline-container-org3974cdd" class="outline-3">
<h3 id="org3974cdd"><a id="ID-9c92bfe5-3e6e-4b70-9cf5-9a5fd8810840"></a>2.2. Last-Modified</h3>
<div class="outline-text-3" id="text-org3974cdd">
<blockquote>
<p>
The "Last-Modified" header field in a response provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.
</p>
</blockquote>

<p>
响应里的 <code>Last-Modified</code> 头字段提供了一个时间戳，这个时间戳是指：源服务器认为这个<ruby>已选择的表示形式<rt>selected representation</rt></ruby>最后一次被修改的日期和时间。这个头字段是在请求处理结束时所确定的。
</p>

<div class="org-src-container">
<pre class="src src-text">Last-Modified = HTTP-date
</pre>
</div>

<blockquote>
<p>
An example of its use is
</p>
</blockquote>

<p>
使用它的一个例子：
</p>

<pre class="example">
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</pre>
</div>

<div id="outline-container-orgae2fffe" class="outline-4">
<h4 id="orgae2fffe">2.2.1. 生成 / Generation</h4>
<div class="outline-text-4" id="text-orgae2fffe">
<blockquote>
<p>
An origin server <b>SHOULD</b> send <code>Last-Modified</code> for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([<a href="RFC7234.html">RFC7234</a>]) results in a substantial reduction of HTTP traffic on the Internet and can be a significant factor in improving service scalability and reliability.
</p>
</blockquote>

<p>
对于能够合理和统一确定最后修改日期的所有已选定表示形式，源服务器都 <b>应当</b> 发送 <code>Last-Modified</code>，这是因为这个头字段会用于条件请求中去对缓存的<ruby>新鲜度<rt>freshness</rt></ruby>进行求值（【<a href="RFC7234.html">RFC7234</a>】），从而降低接下来在互联网的 HTTP 流量成本，同时，它还是提升服务的<ruby>伸缩性<rt>scalability</rt></ruby>和<ruby>可靠性<rt>reliability</rt></ruby>的一个重要的因素。
</p>

<blockquote>
<p>
A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification. What matters to HTTP is how recipients of the <code>Last-Modified</code> header field can use its value to make conditional requests and test the validity of locally cached responses.
</p>
</blockquote>

<p>
一个表示形式通常是由资源接口背后的许多部分组成的。最后修改时间一般是所有这些组成部分中最近一次出现改变的时间。如何为任意给定的资源来确定这个值，那是实现上的细节，已超出了本规范的范畴。HTTP 所关心的是 <code>Last-Modified</code> 头字段的接收端如何使用它的值来进行条件请求，以及测试本地缓存的响应的<ruby>有效性<rt>validity</rt></ruby>。
</p>

<blockquote>
<p>
An origin server <b>SHOULD</b> obtain the <code>Last-Modified</code> value of the representation as close as possible to the time that it generates the <code>Date</code> field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.
</p>
</blockquote>

<p>
源服务器 <b>应当</b> 尽可能获取靠近它在响应里生成的 <code>Date</code> 字段的时间来作为<ruby>表示形式<rt>representation</rt></ruby>的 <code>Last-Modified</code> 的值。这样，接收端就可以对表示形式的修改时间进行精确的评估，特别是如果表示形式在临近生成响应的时候又出现了变化。
</p>

<blockquote>
<p>
An origin server with a clock <b>MUST NOT</b> send a <code>Last-Modified</code> date that is later than the server's time of message origination (<code>Date</code>). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server <b>MUST</b> replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.
</p>
</blockquote>

<p>
具备时钟功能的源服务器 <b>禁止</b> 发送一个比消息<ruby>诞生<rt>origination</rt></ruby>的服务器时间（<code>Date</code>）还要晚的 <code>Last-Modified</code> 日期（译注：也就是说，响应里的 <code>Last-Modified</code> 字段的时间必须早于或等于 <code>Date</code> 字段的时间）。如果这个表示形式的最近修改的时间是源自<ruby>实现专用<rt>implementation-specific</rt></ruby>的元数据，而这些元数据依据源服务器的时钟计算得出最近修改时间是在将来某个时间，那么源服务器 <b>必须</b> 使用<ruby>消息诞生日期<rt>message origination date</rt></ruby>来替换这个值。这样做避免了一个将来的修改日期对缓存的验证的不利影响。
</p>

<blockquote>
<p>
An origin server without a clock <b>MUST NOT</b> assign <code>Last-Modified</code> values to a response unless these values were associated with the resource by some other system or user with a reliable clock.
</p>
</blockquote>

<p>
不具备时钟功能的源服务器 <b>禁止</b> 分配 <code>Last-Modified</code> 值到一个响应里，除非这些值是由某些具有可靠时钟功能的其他系统或用户关联到资源上的。
</p>
</div>
</div>

<div id="outline-container-org29822b9" class="outline-4">
<h4 id="org29822b9"><a id="ID-ba954c8f-272f-409a-9fdd-e092207700c5"></a>2.2.2. 对比 / Comparison</h4>
<div class="outline-text-4" id="text-org29822b9">
<blockquote>
<p>
A <code>Last-Modified</code> time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:
</p>

<ul class="org-ul">
<li>The validator is being compared by an origin server to the actual current validator for the representation and,</li>
<li>That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator.</li>
</ul>

<p>
or
</p>

<ul class="org-ul">
<li>The validator is about to be used by a client in an <code>If-Modified-Since</code>, <code>If-Unmodified-Since</code>, or <code>If-Range</code> header field, because the client has a cache entry for the associated representation, and</li>
<li>That cache entry includes a <code>Date</code> value, which gives the time when the origin server sent the original response, and</li>
<li>The presented <code>Last-Modified</code> time is at least 60 seconds before the <code>Date</code> value.</li>
</ul>

<p>
or
</p>

<ul class="org-ul">
<li>The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and</li>
<li>That cache entry includes a <code>Date</code> value, which gives the time when the origin server sent the original response, and</li>
<li>The presented <code>Last-Modified</code> time is at least 60 seconds before the <code>Date</code> value.</li>
</ul>
</blockquote>

<p>
当一个 <code>Last-Modified</code> 的时间用作一个请求里一个验证器的时候，这种使用方式暗示这个 <code>Last-Modified</code> 是弱验证类型，除非使用以下规则可以推断出它是强验证类型：
</p>

<ul class="org-ul">
<li>源服务器会将这个验证器与表示形式的<ruby>当前真实的验证器<rt>actual current validator</rt></ruby>进行对比，并且</li>
<li><p>
源服务器可靠了解相关联的表示形式，在第二次适用这个在请求里出现的验证器期间（译注：也就是说，在源服务器通过了这次验证让客户端再次使用缓存的这段时间里），这些表示形式并不会被二次改变。
</p>

<blockquote>
<p>
译注：上述“这个验证器”指的是请求里带过来的 <code>Last-Modified</code>，之所以请求里会有这个字段，是因为在之前响应里，源服务器已经向客户端提供了这个资源表示形式的 Last-Modified。换句话说，这个请求已经是第二次（或以上）向源服务器请求同一个资源了。
</p>
</blockquote></li>
</ul>

<p>
或者：
</p>

<ul class="org-ul">
<li>这个验证器即将被客户端用于 <code>If-Modified-Since</code>、<code>If-Unmodified-Since</code>、或者 <code>If-Range</code> 头字段里，因为这个客户端有相关联的表示形式的缓存条目，并且</li>
<li>这个缓存条目包含了一个 <code>Date</code> 值，给出了源服务器在什么时间发送这个原始响应，并且</li>
<li>请求里出现的 <code>Last-Modified</code> 时间至少比这个 <code>Date</code> 值早 60 秒以上。</li>
</ul>

<p>
或者：
</p>

<ul class="org-ul">
<li>这个验证器会被一个中间人缓存服务器与存储在它的缓存条目中的对应的表示形式的验证器进行对比，并且</li>
<li>这个缓存条目包含了一个 <code>Date</code> 值，给出了源服务器在什么时间发送这个原始响应，并且</li>
<li>请求里出现的 <code>Last-Modified</code> 时间至少比这个 <code>Date</code> 值早 60 秒以上。</li>
</ul>

<blockquote>
<p>
This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same <code>Last-Modified</code> time, then at least one of those responses would have a <code>Date</code> value equal to its <code>Last-Modified</code> time. The arbitrary 60-second limit guards against the possibility that the <code>Date</code> and <code>Last-Modified</code> values are generated from different clocks or at somewhat different times during the preparation of the response. An implementation <b>MAY</b> use a value larger than 60 seconds, if it is believed that 60 seconds is too short.
</p>
</blockquote>

<p>
上述这种方法是依赖于一个事实：如果两个不同的响应被源服务器在同一秒内发送，且两者都有相同的 <code>Last-Modified</code> 时间，那么，这些响应中至少有一个响应会带有其值与 <code>Last-Modified</code> 的时间相同的 <code>Date</code> 字段。这个随意设定的 60 秒限制是为了防止出现以下可能：<code>Date</code> 与 <code>Last-Modified</code> 的值是生成自不同的时钟，或者响应的准备时长有一点不同。如果<ruby>实现<rt>implementation</rt></ruby>认为 60 秒太短的话，它 <b>可以</b> 使用大于 60 秒的值。
</p>
</div>
</div>
</div>

<div id="outline-container-orgf0f9907" class="outline-3">
<h3 id="orgf0f9907"><a id="ID-0244a602-2c4a-46aa-96c4-3bd14c3eb244"></a>2.3. ETag</h3>
<div class="outline-text-3" id="text-orgf0f9907">
<blockquote>
<p>
The "ETag" header field in a response provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request. An entity-tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both. An entity-tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.
</p>
</blockquote>

<p>
响应中的 <code>ETag</code> 头字段提供了已选表示形式当前的<ruby>实体标签<rt>entity-tag</rt></ruby>，这个头字段是在请求处理结束时所确定的。实体标签是一种<ruby>不透明的验证器<rt>opaque validator</rt></ruby>，以在同一个资源的不同表示形式之间进行区分，不管是由于资源状态随时间变化而产生的多个表示形式，还是内容协商的结果使同一时间内有多个合适的表示形式，还是两者都有（译注：也就是说，只要是同一个资源的表示形式，ETag 都能够进行区分，不管是以什么方式而产生的表示形式）。一个实体标签由一个<ruby>不透明的以引号包裹的字符串<rt>opaque quoted string</rt></ruby>构成，可能会前置一个“弱验证”的指标符（"W/"）。
</p>

<blockquote>
<p>
译注：对于<ruby>不透明验证器<rt>opaque validator</rt></ruby>就是一种<ruby>不透明数据<rt>opaque data</rt></ruby>，对于不透明数据的解释见<a href="RFC7230.html#ID-1bd50237-cd26-4e74-8c0c-7af8d2d6b25f">【RFC7230】章节 3.2.4</a>末尾的译注。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-text">ETag       = entity-tag

entity-tag = [ weak ] opaque-tag
weak       = %x57.2F ; "W/", case-sensitive
opaque-tag = DQUOTE *etagc DQUOTE
etagc      = %x21 / %x23-7E / obs-text
           ; VCHAR except double quotes, plus obs-text
</pre>
</div>

<blockquote>
<p>
<b>Note:</b> Previously, opaque-tag was defined to be a quoted-string ([RFC2616], <a href="https://tools.ietf.org/html/rfc2616#section-3.11">Section 3.11</a>); thus, some recipients might perform backslash unescaping. Servers therefore ought to avoid backslash characters in entity tags.
</p>
</blockquote>

<p>
<b>注意：</b>  之前，<code>opaque-tag</code> 是定义为一个 <code>quoted-string</code> 的（<a href="https://tools.ietf.org/html/rfc2616#section-3.11">【RFC2616】章节 3.11</a>），由此，某些接收端可能会执行<ruby>反斜杠的逆转义<rt>backslash unescaping</rt></ruby>。所以，服务器应该避免在实体标签内出现反斜杠字符。
</p>

<blockquote>
<p>
An entity-tag can be more reliable for validation than a modification date in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP date values is not sufficient, or where modification dates are not consistently maintained.
</p>
</blockquote>

<p>
在以下这些情况下，基于<ruby>实体标签<rt>entity-tag</rt></ruby>的验证比<ruby>修改日期<rt>modification date</rt></ruby>更加可靠：不方便保存修改日期的情况；使用时间精度为 1 秒的 HTTP 日期不能满足需求的情况；修改日期不能<ruby>一直维持<rt>consistently maintained</rt></ruby>的情况。
</p>

<blockquote>
<p>
Examples:
</p>
</blockquote>

<p>
<code>ETag</code> 的例子：
</p>

<pre class="example">
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
</pre>

<blockquote>
<p>
An entity-tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity-tag for a representation and the generation of that entity-tag does not satisfy all of the characteristics of a strong validator (<a href="#org265ee00">Section 2.1</a>), then the origin server <b>MUST</b> mark the entity-tag as weak by prefixing its opaque value with "W/" (case-sensitive).
</p>
</blockquote>

<p>
实体标签可以是一个弱验证器，也可以是一个强验证器，默认是强验证器。如果源服务器为一个表示形式提供了一个实体标签，但这个实体标签的生成并不能满足作为一个强验证器的所有特征（<a href="#org265ee00">章节 2.1</a>），那么，源服务器 <b>必须</b> 将这个实体标签标记为弱验证类型，具体是通过在它的不透明值的前面放置一个 "W/"（区分大小写）。
</p>
</div>

<div id="outline-container-orge4892c6" class="outline-4">
<h4 id="orge4892c6">2.3.1. 生成 / Generation</h4>
<div class="outline-text-4" id="text-orge4892c6">
<blockquote>
<p>
The principle behind entity-tags is that only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that any such mechanism can be mapped to a simple sequence of octets for easy comparison. Since the value is opaque, there is no need for the client to be aware of how each entity-tag is constructed.
</p>
</blockquote>

<p>
实体标签背后的原理是：只有<ruby>服务创造者<rt>service author</rt></ruby>才懂得选择资源的最精确和最有效的验证机制的实现方法，而且所述的任何机制都可以映射为一组简单的字节序列来轻易对比。正因为这个值是不透明的，因此，客户端不需要了解每一个实体标签是如何构建的。
</p>

<blockquote>
<p>
For example, a resource that has implementation-specific versioning applied to all changes might use an internal revision number, perhaps combined with a variance identifier for content negotiation, to accurately differentiate between representations. Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution.
</p>
</blockquote>

<p>
例如，某个实现具有<ruby>实现专用<rt>implementation-specific</rt></ruby>的版本管理功能，可以对资源的对所有改变进行版本管理，那么某个资源就可以使用一个内部修订号，可能会结合一个与内容协商所不同的标识符，来精确地区分所有表示形式。其他实现可能使用表示形式内容的一个<ruby>冲突保护<rt>collision-resistant</rt></ruby>散列，或者多个文件属性的结合，或者一个精度为<ruby>亚秒级<rt>sub-second</rt></ruby>的修改时间戳。
</p>

<blockquote>
<p>
An origin server <b>SHOULD</b> send an <code>ETag</code> for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity-tag's use in conditional requests and evaluating cache freshness ([<a href="RFC7234.html">RFC7234</a>]) can result in a substantial reduction of HTTP network traffic and can be a significant factor in improving service scalability and reliability.
</p>
</blockquote>

<p>
源服务器 <b>应当</b> 发送一个 <code>ETag</code>，因为实体标签在条件请求以及<ruby>缓存新鲜度评估<rt>evaluation cache freshness</rt></ruby>（【<a href="RFC7234.html">RFC7234</a>】）上的应用能够显著降低 HTTP 网络流量成本，同时，它还是提升服务的<ruby>伸缩性<rt>scalability</rt></ruby>和<ruby>可靠性<rt>reliability</rt></ruby>的一个重要的因素。
</p>
</div>
</div>

<div id="outline-container-org078e6e7" class="outline-4">
<h4 id="org078e6e7"><a id="ID-e3a6dda6-2209-44aa-89af-c37f1b95c2fe"></a>2.3.2. 对比 / Comparison</h4>
<div class="outline-text-4" id="text-org078e6e7">
<blockquote>
<p>
There are two entity-tag comparison functions, depending on whether or not the comparison context allows the use of weak validators:
</p>

<ul class="org-ul">
<li>Strong comparison: two entity-tags are equivalent if both are not weak and their opaque-tags match character-by-character.</li>
<li>Weak comparison: two entity-tags are equivalent if their opaque-tags match character-by-character, regardless of either or both being tagged as "weak".</li>
</ul>
</blockquote>

<p>
有两种实体标签的对比方法，取决于<ruby>对比场景<rt>comparison context</rt></ruby>里是否允许使用弱验证器：
</p>

<ul class="org-ul">
<li>强对比：当两个实体标签都不是弱验证类型，并且它们的 <code>opaque-tags</code> 里的字符一一匹配，那么，这两个实体标签是相等的。</li>
<li>弱对比：当两个实体标签的 <code>opaque-tags</code> 里的字符一一匹配，而不必理会它们之中是否有被标记为弱类型（"W/"），那么，这两个实体标签是相等的。</li>
</ul>

<blockquote>
<p>
The example below shows the results for a set of entity-tag pairs and both the weak and strong comparison function results:
</p>
</blockquote>

<p>
下面的例子展示了一组实体标签使用弱对比方法和强对比方法的对比结果：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">ETag 1</th>
<th scope="col" class="org-left">ETag 2</th>
<th scope="col" class="org-left">Strong Comparison</th>
<th scope="col" class="org-left">Weak Comparison</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">W/"1"</td>
<td class="org-left">W/"1"</td>
<td class="org-left">no match</td>
<td class="org-left">match</td>
</tr>

<tr>
<td class="org-left">W/"1"</td>
<td class="org-left">W/"2"</td>
<td class="org-left">no match</td>
<td class="org-left">no match</td>
</tr>

<tr>
<td class="org-left">W/"1"</td>
<td class="org-left">"1"</td>
<td class="org-left">no match</td>
<td class="org-left">match</td>
</tr>

<tr>
<td class="org-left">"1"</td>
<td class="org-left">"1"</td>
<td class="org-left">match</td>
<td class="org-left">match</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga57841d" class="outline-4">
<h4 id="orga57841d">2.3.3. 示例：实体标签在内容协商资源上的变化 / Example: Entity-Tags Varying on Content-Negotiated Resources</h4>
<div class="outline-text-4" id="text-orga57841d">
<blockquote>
<p>
Consider a resource that is subject to content negotiation (<a href="RFC7231.html#ID-c45cb9ca-1e51-4738-8c43-231e7316ea86">Section 3.4</a> of [RFC7231]), and where the representations sent in response to a GET request vary based on the <code>Accept-Encoding</code> request header field (<a href="RFC7231.html#ID-a8fcc101-3782-4ed0-aec0-561b933e6a5f">Section 5.3.4</a> of [RFC7231]):
</p>
</blockquote>

<p>
假设一个资源受控于<ruby>内容协商<rt>content negotiation</rt></ruby>（<a href="RFC7231.html#ID-c45cb9ca-1e51-4738-8c43-231e7316ea86">【RFC7231】章节 3.4</a>），在回应给一个 GET 请求的响应中，发送哪一种表示形式是基于 <code>Accept-Encoding</code> 请求头字段（<a href="RFC7231.html#ID-a8fcc101-3782-4ed0-aec0-561b933e6a5f">【RFC7231】章节 5.3.4</a>）的不同而改变：
</p>

<blockquote>
<p>
&gt;&gt; Request:
</p>
</blockquote>

<p>
&gt;&gt; 请求：
</p>

<pre class="example">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip

</pre>

<blockquote>
<p>
In this case, the response might or might not use the <code>gzip</code> content coding. If it does not, the response might look like:
</p>
</blockquote>

<p>
在这种情况，响应可能使用或不使用 <code>gzip</code> 内容编码。如果它不使用，那么响应可能看起来是这样的：
</p>

<blockquote>
<p>
&gt;&gt; Response:
</p>
</blockquote>

<p>
&gt;&gt; 响应：
</p>

<pre class="example">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</pre>

<blockquote>
<p>
An alternative representation that does use <code>gzip</code> content coding would be:
</p>
</blockquote>

<p>
而使用 gzip 内容编码的表示形式可能是这样的：
</p>

<blockquote>
<p>
&gt;&gt; Response:
</p>
</blockquote>

<p>
&gt;&gt; 响应：
</p>

<pre class="example">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

...binary data...
</pre>

<blockquote>
<p>
<b>Note:</b> Content codings are a property of the representation data, so a strong entity-tag for a content-encoded representation has to be distinct from the entity tag of an unencoded representation to prevent potential conflicts during cache updates and range requests. In contrast, transfer codings (<a href="RFC7230.html#ID-F7261A9D-8DF2-4A92-B8E8-D8F346005C6C">Section 4</a> of [RFC7230]) apply only during message transfer and do not result in distinct entity-tags.
</p>
</blockquote>

<p>
<b>注意：</b> <ruby>内容编码值<rt>content codings</rt></ruby>是表示形式数据的一种属性，因此，<ruby>经内容编码过<rt>content-encoded</rt></ruby>的表示形式的强实体标签必须区别于它的<ruby>未编码过<rt>unencoded</rt></ruby>的版本的强实体标签，以避免在缓存更新或<ruby>范围请求<rt>range requests</rt></ruby>期间可能发生的冲突。作为对比，传输编码值（<a href="RFC7230.html#ID-F7261A9D-8DF2-4A92-B8E8-D8F346005C6C">【RFC7230】章节 4</a>）仅作用于消息传输的期间，并不会导致实体标签的不同。
</p>
</div>
</div>
</div>

<div id="outline-container-org9ec4f9e" class="outline-3">
<h3 id="org9ec4f9e">2.4. 什么时候使用实体标签和最后修改日期 / When to Use Entity-Tags and Last-Modified Dates</h3>
<div class="outline-text-3" id="text-org9ec4f9e">
<blockquote>
<p>
In <code>200 (OK)</code> responses to GET or HEAD, an origin server:
</p>

<ul class="org-ul">
<li><b>SHOULD</b> send an entity-tag validator unless it is not feasible to generate one.</li>
<li><b>MAY</b> send a weak entity-tag instead of a strong entity-tag, if performance considerations support the use of weak entity-tags, or if it is unfeasible to send a strong entity-tag.</li>
<li><b>SHOULD</b> send a <code>Last-Modified</code> value if it is feasible to send one.</li>
</ul>
</blockquote>

<p>
在回应给 GET 或者 HEAD 的 <code>200 (OK)</code> 响应中，对于服务器：
</p>

<ul class="org-ul">
<li><b>应当</b> 发送一个实体标签验证器，除非对于它来说生成一个实体标签验证器是<ruby>不可行的<rt>not feasible</rt></ruby>。</li>
<li><b>可以</b> 发送一个弱验证类型的实体标签而不是强验证类型标签，如果出于性能方面的考虑支持弱验证类型的实体标签的使用，或者生成一个强验证类型的实体标签是不可行的。</li>
<li><b>应当</b> 发送一个 <code>Last-Modified</code> 值，如果对于它来说发送一个 <code>Last-Modified</code> 是可行的话。</li>
</ul>

<blockquote>
<p>
In other words, the preferred behavior for an origin server is to send both a strong entity-tag and a <code>Last-Modified</code> value in successful responses to a retrieval request.
</p>
</blockquote>

<p>
换句话说，源服务器的首选的行为是在回应给一个检索请求（译注：例如 HTTP GET 请求）的成功响应中，既发送一个强实体标签，也发送一个 <code>Last-Modified</code> 值。
</p>

<blockquote>
<p>
A client:
</p>

<ul class="org-ul">
<li><b>MUST</b> send that entity-tag in any cache validation request (using <code>If-Match</code> or <code>If-None-Match</code>) if an entity-tag has been provided by the origin server.</li>
<li><b>SHOULD</b> send the <code>Last-Modified</code> value in non-subrange cache validation requests (using <code>If-Modified-Since</code>) if only a <code>Last-Modified</code> value has been provided by the origin server.</li>
<li><b>MAY</b> send the <code>Last-Modified</code> value in subrange cache validation requests (using <code>If-Unmodified-Since</code>) if only a <code>Last-Modified</code> value has been provided by an HTTP/1.0 origin server. The user agent <b>SHOULD</b> provide a way to disable this, in case of difficulty.</li>
<li><b>SHOULD</b> send both validators in cache validation requests if both an entity-tag and a <code>Last-Modified</code> value have been provided by the origin server. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.</li>
</ul>
</blockquote>

<p>
对于客户端：
</p>

<ul class="org-ul">
<li><b>必须</b> 在任何<ruby>缓存验证请求<rt>cache validation request</rt></ruby>中发送实体标签（使用 <code>If-Match</code> 或者 <code>If-None-Match</code> 来发送），如果源服务器已经提供了一个实体标签的话。</li>
<li><b>应当</b> 在<ruby>非子范围的缓存验证请求<rt>non-subrange cache validation requests</rt></ruby>中发送 <code>Last-Modified</code> 值（使用 <code>If-Modified-Since</code>），如果源服务器只提供了一个 <code>Last-Modified</code> 值（译注：即没有实体标签）的话。</li>
<li><b>可以</b> 在<ruby>子范围缓存验证请求<rt>subrange cache validation requests</rt></ruby>中发送 <code>Last-Modified</code> 值（使用 <code>If-Unmodified-Since</code>），如果版本为 HTTP/1.0 的源服务器只提供了一个 <code>Last-Modified</code> 值的话。如果用户代理有困难的话，<b>应当</b> 提供一种途径来禁用这种行为。</li>
<li><b>应当</b> 在缓存验证请求中将两种验证器都发送，如果源服务器既提供了一个实体标签，也提供了一个 <code>Last-Modified</code> 值的话。这样使得 HTTP/1.0 和 HTTP/1.1 的缓存服务器都可以恰当地响应请求。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org098ebb3" class="outline-2">
<h2 id="org098ebb3"><a id="ID-5d82712b-331b-4303-85fc-19b1488af561"></a>3. 前提条件头字段 / Precondition Header Fields</h2>
<div class="outline-text-2" id="text-org098ebb3">
<blockquote>
<p>
This section defines the syntax and semantics of HTTP/1.1 header fields for applying preconditions on requests. <a href="#org8287389">Section 5</a> defines when the preconditions are applied. <a href="#org35abd07">Section 6</a> defines the order of evaluation when more than one precondition is present.
</p>
</blockquote>

<p>
本章节定义了用于在请求中应用<ruby>前提条件<rt>precondition</rt></ruby>的 HTTP/1.1 头字段的句法和语义。<a href="#org8287389">章节 5</a> 定义了前提条件会在什么时候被应用。<a href="#org35abd07">章节 6</a> 定义了当出现超过一种前提条件的时候它们的求值顺序。
</p>
</div>

<div id="outline-container-org220193c" class="outline-3">
<h3 id="org220193c"><a id="ID-2c4da24a-b694-472c-8ac3-f09c20a84216"></a>3.1. If-Match</h3>
<div class="outline-text-3" id="text-org220193c">
<blockquote>
<p>
The "If-Match" header field makes the request method conditional on the recipient origin server either having at least one current representation of the target resource, when the field-value is "*", or having a current representation of the target resource that has an entity-tag matching a member of the list of entity-tags provided in the field-value.
</p>
</blockquote>

<p>
<code>If-Match</code> 头字段使得请求方法带有条件，接收端服务器仅在满足以下条件之一时才会成功响应：
</p>
<ul class="org-ul">
<li>当字段值为 "*" 的时候，目标资源存在至少一个当前表示形式，或者</li>
<li>目标资源存在一个当前表示形式，这个表示形式带有一个实体标签与此字段值所列出的实体标签之一相匹配。</li>
</ul>

<blockquote>
<p>
An origin server <b>MUST</b> use the strong comparison function when comparing entity-tags for <code>If-Match</code> (<a href="#org078e6e7">Section 2.3.2</a>), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.
</p>
</blockquote>

<p>
当源服务器对 <code>If-Match</code> 的实体标签进行对比的时候（<a href="#org078e6e7">章节 2.3.2</a>），源服务器 <b>必须</b> 使用强对比方法，这是因为客户端打算让这个前提条件来防止本执行本方法，如果表示形式数据有任何变化的话。
</p>

<div class="org-src-container">
<pre class="src src-text">If-Match = "*" / 1#entity-tag
</pre>
</div>

<blockquote>
<p>
Examples:
</p>
</blockquote>

<p>
示例：
</p>

<pre class="example">
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
</pre>

<blockquote>
<p>
<code>If-Match</code> is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to prevent the "lost update" problem). It can also be used with safe methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request.
</p>
</blockquote>

<p>
<code>If-Match</code> 经常与<ruby>会状态改变<rt>state-changing</rt></ruby>的请求方法一起使用（比如：POST、PUT、DELETE），来避免当多个用户代理可能并行操作同一个资源的时候导致的意外覆盖（也就是说，避免“丢失更新”的问题）。它还可以与<ruby>安全方法<rt>safe methods</rt></ruby>一起使用来中止请求，如果已选表示形式并没有匹配上一个已经（或可能已经）从之前的请求里存储的表示形式。
</p>

<blockquote>
<p>
An origin server that receives an <code>If-Match</code> header field <b>MUST</b> evaluate the condition prior to performing the method (<a href="#org8287389">Section 5</a>). If the field-value is "*", the condition is false if the origin server does not have a current representation for the target resource. If the field-value is a list of entity-tags, the condition is false if none of the listed tags match the entity-tag of the selected representation.
</p>
</blockquote>

<p>
源服务器接收到一个 <code>If-Match</code> 字段时 <b>必须</b> 在执行对应的请求方法之前对这个条件进行求值（<a href="#org8287389">章节 5</a>）。如果 <code>If-Match</code> 的字段值是 "*"，且源服务器的目标资源没有任何一种当前表示形式，那么，这个条件的求值结果为假。如果这个字段值是一个实体标签列表，且所列出的所有标签没有任何一个匹配已选表示形式的实体标签，那么这个条件的求值结果为假。
</p>

<blockquote>
<p>
An origin server <b>MUST NOT</b> perform the requested method if a received <code>If-Match</code> condition evaluates to false; instead, the origin server <b>MUST</b> respond with either a) the <code>412 (Precondition Failed)</code> status code or b) one of the <code>2xx (Successful)</code> status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or a compatible change was made by some other user agent). In the latter case, the origin server <b>MUST NOT</b> send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent.
</p>
</blockquote>

<p>
如果所接收到的 <code>If-Match</code> 条件的求值结果为假，源服务器 <b>禁止</b> 执行请求方法，而是，源服务器 <b>必须</b> 响应以下其中之一：
</p>

<ol class="org-ol">
<li>响应 <code>412 (Precondition Failed)</code> 状态码，或者</li>
<li>如果源服务器已检验出目标资源又被请求了一种状态改变，并且它的最终状态已经反映为目标资源当前状态（也就是说，用户代理所请求的改变已经成功完成了，但是用户请求可能没有意识到这个，可能是因为之前的响应已经丢失了没有成功到达用户代理，或者其他某些用户代理也对目标资源请求了一种与之兼容的变化），那么，响应 <code>2xx (Successful)</code> 状态码的其中之一。</li>
</ol>

<p>
对于第二种情况，源服务器 <b>禁止</b> 在响应里发送验证器头字段，除非它能够检验出这个请求与它的同一个用户代理所造成的前一个相邻的变化相重复。
</p>

<blockquote>
<p>
The <code>If-Match</code> header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>
</blockquote>

<p>
<code>If-Match</code> 头字段可以被缓存服务器以及中间人所忽略，因为它并不适用于一个已存储的响应。
</p>
</div>
</div>

<div id="outline-container-org870b652" class="outline-3">
<h3 id="org870b652"><a id="ID-30878863-9a64-4efe-bc9b-07386eae0ed7"></a>3.2. If-None-Match</h3>
<div class="outline-text-3" id="text-org870b652">
<blockquote>
<p>
The "If-None-Match" header field makes the request method conditional on a recipient cache or origin server either not having any current representation of the target resource, when the field-value is "*", or having a selected representation with an entity-tag that does not match any of those listed in the field-value.
</p>
</blockquote>

<p>
<code>If-None-Match</code> 头字段使得请求方法带有条件，接收端缓存服务器或源服务器仅在满足以下条件之一时才会成功响应：
</p>

<ul class="org-ul">
<li>当字段值为 "*"，的时候，目标资源没有任何当前表示形式。</li>
<li>有一种已选表示形式带有一个实体标签，这个实体标签并不与列在这个字段值里的任一实体标签相匹配。</li>
</ul>

<blockquote>
<p>
A recipient <b>MUST</b> use the weak comparison function when comparing entity-tags for <code>If-None-Match</code> (<a href="#org078e6e7">Section 2.3.2</a>), since weak entity-tags can be used for cache validation even if there have been changes to the representation data.
</p>
</blockquote>

<p>
当接收端对 <code>If-None-Match</code> 的实体标签进行对比的时候，<b>必须</b> 使用<ruby>弱对比方法<rt>weak comparison function</rt></ruby>（<a href="#org078e6e7">章节 2.3.2</a>）。这是因为即使<ruby>表示形式数据<rt>representation data</rt></ruby>已经改变，弱验证类型的实体标签还可以用来缓存验证。
</p>

<div class="org-src-container">
<pre class="src src-text">If-None-Match = "*" / 1#entity-tag
</pre>
</div>

<blockquote>
<p>
Examples:
</p>
</blockquote>

<p>
示例：
</p>

<pre class="example">
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
</pre>

<blockquote>
<p>
<code>If-None-Match</code> is primarily used in conditional GET requests to enable efficient updates of cached information with a minimum amount of transaction overhead. When a client desires to update one or more stored responses that have entity-tags, the client <b>SHOULD</b> generate an <code>If-None-Match</code> header field containing a list of those entity-tags when making a GET request; this allows recipient servers to send a <code>304 (Not Modified)</code> response to indicate when one of those stored responses matches the selected representation.
</p>
</blockquote>

<p>
<code>If-None-Match</code> 主要用在条件 GET 请求中使缓存信息能够以最小的传输开销来进行高效的更新。当客户端希望更新一个或多个它已经缓存的带有实体标签的响应的时候，客户端 <b>应当</b> 在执行 GET 请求的时候生成一个 <code>If-None-Match</code> 头字段来包含一个这些实体标签的列表，这样使得接收端服务器可以发送一个 <code>304 (Not Modified)</code> 响应来向客户端表明，什么时候这些已缓存的响应之一会匹配<ruby>已选表示形式<rt>selected representation</rt></ruby>。
</p>

<blockquote>
<p>
<code>If-None-Match</code> can also be used with a value of "*" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (<a href="RFC7231.html#ID-2f967e3d-8694-430b-ad06-e748fd39b281">Section 4.2.1</a> of [RFC7231]). This is a variation on the "lost update" problem that might arise if more than one client attempts to create an initial representation for the target resource.
</p>
</blockquote>

<p>
<code>If-None-Match</code> 的值也可以设置为 "*" 来阻止不安全的请求方法（比如，PUT）意外地修改了目标资源已经现存在的一种表示形式，当客户端认为所请求的资源没有这种表示形式的时候（<a href="RFC7231.html#ID-2f967e3d-8694-430b-ad06-e748fd39b281">【RFC7231】章节 4.2.1</a>）。这是一种“丢失更新”问题的变种，如果超过一个客户端试图为目标资源创建一个初始表示形式的时候，这种问题可能会发生。
</p>

<blockquote>
<p>
An origin server that receives an <code>If-None-Match</code> header field <b>MUST</b> evaluate the condition prior to performing the method (Section 5). If the field-value is "*", the condition is false if the origin server has a current representation for the target resource. If the field-value is a list of entity-tags, the condition is false if one of the listed tags match the entity-tag of the selected representation.
</p>
</blockquote>

<p>
源服务器接收到一个 <code>If-None-Match</code> 头字段的时候，<b>必须</b> 在执行这个请求方法之前对条件进行求值（章节 5）。如果字段值是 "*"，并且源服务器的目标资源有当前表示形式，那么这个条件的求值结果为假。如果字段值是一个实体标签的列表，并且列表中的实体标签之一匹配上已选表示形式的实体标签，那么这个条件的求值结果为假。
</p>

<blockquote>
<p>
An origin server <b>MUST NOT</b> perform the requested method if the condition evaluates to false; instead, the origin server <b>MUST</b> respond with either a) the <code>304 (Not Modified)</code> status code if the request method is GET or HEAD or b) the <code>412 (Precondition Failed)</code> status code for all other request methods.
</p>
</blockquote>

<p>
如果条件求值为假，那么，源服务器 <b>禁止</b> 执行所请求的方法，而是，源服务器 <b>必须</b> 响应以下其中之一：
</p>

<ol class="org-ol">
<li>如果请求方法是 GET 或者 HEAD，响应 <code>304 (Not Modified)</code> 状态码，或者</li>
<li>如果是其他请求方法，响应 <code>412 (Precondition Failed)</code> 状态码。</li>
</ol>

<blockquote>
<p>
Requirements on cache handling of a received <code>If-None-Match</code> header field are defined in <a href="RFC7234.html#ID-A500DFDD-0DD6-454E-A94A-EDBC8D38946E">Section 4.3.2</a> of [RFC7234].
</p>
</blockquote>

<p>
接收到 <code>If-None-Match</code> 头字段时的缓存处理的相关要求，定义在<a href="RFC7234.html#ID-A500DFDD-0DD6-454E-A94A-EDBC8D38946E">【RFC7234】章节 4.3.2</a> 中。
</p>
</div>
</div>

<div id="outline-container-orgbe71300" class="outline-3">
<h3 id="orgbe71300"><a id="ID-e71fa098-728a-46bf-b792-2388946ea0ee"></a>3.3. If-Modified-Since</h3>
<div class="outline-text-3" id="text-orgbe71300">
<blockquote>
<p>
The "If-Modified-Since" header field makes a GET or HEAD request method conditional on the selected representation's modification date being more recent than the date provided in the field-value. Transfer of the selected representation's data is avoided if that data has not changed.
</p>
</blockquote>

<p>
<code>If-Modified-Since</code> 头字段使得 GET 或者 HEAD 请求方法带有条件，已选表示形式的修改日期晚于这个字段值的日期的时候，服务器才会成功响应。避免表示形式的数据没有发生改变的情况下再次传输表示形式的数据。
</p>

<div class="org-src-container">
<pre class="src src-text">If-Modified-Since = HTTP-date
</pre>
</div>

<blockquote>
<p>
An example of the field is:
</p>
</blockquote>

<p>
这个字段的示例：
</p>

<pre class="example">
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>

<blockquote>
<p>
A recipient <b>MUST</b> ignore <code>If-Modified-Since</code> if the request contains an <code>If-None-Match</code> header field; the condition in <code>If-None-Match</code> is considered to be a more accurate replacement for the condition in <code>If-Modified-Since</code>, and the two are only combined for the sake of interoperating with older intermediaries that might not implement <code>If-None-Match</code>.
</p>
</blockquote>

<p>
如果请求包含有一个 <code>In-None-Match</code> 头字段，那么，接收端 <b>必须</b> 忽略 <code>If-Modified-Since</code> 头字段。在 <code>In-None-Match</code> 里的条件被认为是对在 <code>In-Modified-Since</code> 里的条件的更加精准的替代，结合使用这两种头字段的目的仅在于与可能未实现 <code>If-None-Match</code> 的旧中间人进行交互。
</p>

<blockquote>
<p>
A recipient <b>MUST</b> ignore the <code>If-Modified-Since</code> header field if the received field-value is not a valid <code>HTTP-date</code>, or if the request method is neither GET nor HEAD.
</p>
</blockquote>

<p>
接收端如果接收到的 <code>If-Modified-Since</code> 头字段的值不是一个合法的 <code>HTTP-date</code>，或者这个请求方法既不是 GET 也不是 HEAD 的时候，接收端 <b>必须</b> 忽略这个头字段。
</p>

<blockquote>
<p>
A recipient <b>MUST</b> interpret an <code>If-Modified-Since</code> field-value's timestamp in terms of the origin server's clock.
</p>
</blockquote>

<p>
接收端 <b>必须</b> 依据源服务器的时钟来解释 <code>If-Modified-Since</code> 头字段值里的时间戳。
</p>

<blockquote>
<p>
<code>If-Modified-Since</code> is typically used for two distinct purposes: 1) to allow efficient updates of a cached representation that does not have an entity-tag and 2) to limit the scope of a web traversal to resources that have recently changed.
</p>
</blockquote>

<p>
使用 <code>If-Modified-Since</code> 通常有两个不同的目的：
</p>

<ol class="org-ol">
<li>可以高效地更新一个已缓存的但没有实体标签的表示形式高效；</li>
<li>将网页的资源遍历范围限制为只有最近有改变的资源上。</li>
</ol>

<blockquote>
<p>
When used for cache updates, a cache will typically use the value of the cached message's <code>Last-Modified</code> field to generate the field value of <code>If-Modified-Since</code>. This behavior is most interoperable for cases where clocks are poorly synchronized or when the server has chosen to only honor exact timestamp matches (due to a problem with <code>Last-Modified</code> dates that appear to go "back in time" when the origin server's clock is corrected or a representation is restored from an archived backup). However, caches occasionally generate the field value based on other data, such as the <code>Date</code> header field of the cached message or the local clock time that the message was received, particularly when the cached message does not contain a <code>Last-Modified</code> field.
</p>
</blockquote>

<p>
当用于更新缓存的时候，缓存服务器一般使用已缓存的消息的 <code>Last-Modified</code> 字段的值来生成 <code>If-Modified-Since</code> 字段的值。这种行为在以下情况下最有互可操作性：在时钟不同步的场景，或者当服务器选择为只遵循准确时间戳的匹配（由于 <code>Last-Modified</code> 的日期的问题，这个问题具体是这个日期貌似是要回到从前，当源服务器的时钟被修正过或者一个表示形式是恢复自一个归档备份的时候）。但是，缓存服务器偶尔会基于其他数据来生成这个字段值，比如已缓存的消息的 <code>Date</code> 头字段，或者接收到消息时的本地时钟时间，特别是当已缓存的消息并没有包含一个 <code>Last-Modified</code> 字段的时候。
</p>

<blockquote>
<p>
When used for limiting the scope of retrieval to a recent time window, a user agent will generate an <code>If-Modified-Since</code> field value based on either its own local clock or a <code>Date</code> header field received from the server in a prior response. Origin servers that choose an exact timestamp match based on the selected representation's <code>Last-Modified</code> field will not be able to help the user agent limit its data transfers to only those changed during the specified window.
</p>
</blockquote>

<p>
当用于对检索的范围限制为一个最近的时间窗口的时候，用户代理将会生成一个 <code>If-Modified-Since</code> 字段，其值或者基于用户代理的本地时钟，或者基于接收自服务器的之前一个响应的 <code>Date</code> 头字段。源服务器选择准确匹配上基于已选表示形式的 <code>Last-Modified</code> 字段的时间戳，将无法帮助用户代理限制它的数据传输为仅仅是那些具体时间窗口期间的改动。
</p>

<blockquote>
<p>
An origin server that receives an <code>If-Modified-Since</code> header field <b>SHOULD</b> evaluate the condition prior to performing the method (<a href="#org8287389">Section 5</a>). The origin server <b>SHOULD NOT</b> perform the requested method if the selected representation's last modification date is earlier than or equal to the date provided in the field-value; instead, the origin server <b>SHOULD</b> generate a <code>304 (Not Modified)</code> response, including only those metadata that are useful for identifying or updating a previously cached response.
</p>
</blockquote>

<p>
源服务器接收到一个 <code>If-Modified-Since</code> 头字段的时候，<b>应当</b> 在执行请求方法之前对条件进行求值（<a href="#org8287389">章节 5</a>）。如果已选表示形式的最后修改时间是早于或等于 <code>If-Modified-Since</code> 所提供的日期，那么，源服务器 <b>不应当</b> 执行所请求的方法，而是，源服务器 <b>应当</b> 生成一个 <code>304 (Not Modified)</code> 响应，只包含那些有用于的元数据，所述有用的元数据指的是用来表明或更新之前所缓存的响应的那些元数据。
</p>

<blockquote>
<p>
Requirements on cache handling of a received <code>If-Modified-Since</code> header field are defined in <a href="RFC7234.html#ID-A500DFDD-0DD6-454E-A94A-EDBC8D38946E">Section 4.3.2</a> of [RFC7234].
</p>
</blockquote>

<p>
接收到 <code>If-Modified-Since</code> 头字段时的缓存处理的相关要求，定义在<a href="RFC7234.html#ID-A500DFDD-0DD6-454E-A94A-EDBC8D38946E">【RFC7234】章节 4.3.2</a> 中。
</p>
</div>
</div>

<div id="outline-container-org2f3f176" class="outline-3">
<h3 id="org2f3f176"><a id="ID-7365caf4-85ba-4e10-90a2-1abc298dc569"></a>3.4. If-Unmodified-Since</h3>
<div class="outline-text-3" id="text-org2f3f176">
<blockquote>
<p>
The "If-Unmodified-Since" header field makes the request method conditional on the selected representation's last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as <code>If-Match</code> for cases where the user agent does not have an entity-tag for the representation.
</p>
</blockquote>

<p>
<code>If-Unmodified-Since</code> 头字段使得请求方法带有条件，已选表示形式的修改日期早于或等于这个字段值的日期的时候，服务器才会成功响应。在用户代理并没有在表示形式上带有实体标签的情况下，这个字段实现了像 <code>If-Match</code> 相同的目的。
</p>

<div class="org-src-container">
<pre class="src src-text">If-Unmodified-Since = HTTP-date
</pre>
</div>

<blockquote>
<p>
An example of the field is:
</p>
</blockquote>

<p>
这个字段的一个示例：
</p>

<pre class="example">
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>

<blockquote>
<p>
A recipient <b>MUST</b> ignore <code>If-Unmodified-Since</code> if the request contains an <code>If-Match</code> header field; the condition in <code>If-Match</code> is considered to be a more accurate replacement for the condition in <code>If-Unmodified-Since</code>, and the two are only combined for the sake of interoperating with older intermediaries that might not implement <code>If-Match</code>.
</p>
</blockquote>

<p>
如果请求包含有一个 <code>If-Match</code> 头字段的时候，接收端 <b>必须</b> 忽略掉 <code>If-Unmodified-Since</code> 字段。在 <code>In-Match</code> 里的条件被认为是对在 <code>In-Unmodified-Since</code> 里的条件的更加精准的替代，结合使用这两种头字段的目的仅在于与可能未实现 <code>If-Match</code> 的旧中间人进行交互。
</p>

<blockquote>
<p>
A recipient <b>MUST</b> ignore the <code>If-Unmodified-Since</code> header field if the received field-value is not a valid <code>HTTP-date</code>.
</p>
</blockquote>

<p>
接收端如果接收到 <code>If-Unmodified-Since</code> 头字段的值不是一个合法的 <code>HTTP-date</code>，接收端 <b>必须</b> 忽略这个头字段。
</p>

<blockquote>
<p>
A recipient <b>MUST</b> interpret an <code>If-Unmodified-Since</code> field-value's timestamp in terms of the origin server's clock.
</p>
</blockquote>

<p>
接收端 <b>必须</b> 依据源服务器的时钟来解释 <code>If-Unmodified-Since</code> 头字段值里的时间戳。
</p>

<blockquote>
<p>
<code>If-Unmodified-Since</code> is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity-tags with its representations (i.e., to prevent the "lost update" problem). It can also be used with safe methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request.
</p>
</blockquote>

<p>
<code>If-Unmodified-Since</code> 经常与<ruby>会状态改变<rt>state-changing</rt></ruby>的请求方法一起使用（比如：POST、PUT、DELETE），来避免当多个用户代理可能并行操作同一个不支持实体标签的资源的时候导致的意外覆盖（也就是说，避免“丢失更新”的问题）。它还可以与<ruby>安全方法<rt>safe methods</rt></ruby>一起使用来中止请求，如果已选表示形式并没有匹配上一个已经（或可能已经）从之前的请求里存储的表示形式。
</p>

<blockquote>
<p>
An origin server that receives an <code>If-Unmodified-Since</code> header field <b>MUST</b> evaluate the condition prior to performing the method (<a href="#org8287389">Section 5</a>). The origin server <b>MUST NOT</b> perform the requested method if the selected representation's last modification date is more recent than the date provided in the field-value; instead the origin server <b>MUST</b> respond with either a) the <code>412 (Precondition Failed)</code> status code or b) one of the <code>2xx (Successful)</code> status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of that because the prior response message was lost or a compatible change was made by some other user agent). In the latter case, the origin server <b>MUST NOT</b> send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent.
</p>
</blockquote>

<p>
源服务器接收到一个 <code>If-Unmodified-Since</code> 头字段的时候，<b>必须</b> 在执行请求请求方法之前对条件进行求值（<a href="#org8287389">章节 5</a>）。如果已选表示形式的最后修改时间是晚于 <code>If-Unmodified-Since</code> 所提供的日期，那么，源服务器 <b>禁止</b> 执行所请求的方法，而是，源服务器 <b>必须</b> 响应以下其中之一：
</p>

<ol class="org-ol">
<li>响应 <code>412 (Precondition Failed)</code> 状态码，或者</li>
<li>如果源服务器检验出目标资源又被请求了一种状态改变，并且它的最终状态已经反映为目标资源当前状态（也就是说，用户代理所请求的改变已经成功完成了，但是用户请求可能没有意识到这个，可能是因为之前的响应已经丢失了没有成功到达用户代理，或者其他某些用户代理也对目标资源请求了一种与之兼容的变化），那么，响应 <code>2xx (Successful)</code> 状态码的其中之一。</li>
</ol>

<p>
对于第一种情况，源服务器 <b>禁止</b> 在响应里发送验证器头字段，除非它能够检验出这个请求与它的同一个用户代理所造成的前一个相邻的变化相重复。
</p>

<blockquote>
<p>
The <code>If-Unmodified-Since</code> header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>
</blockquote>

<p>
<code>If-Unmodified-Since</code> 头字段可以被缓存服务器以及中间人所忽略，因为它并不适用于一个已存储的响应。
</p>
</div>
</div>

<div id="outline-container-org76fb615" class="outline-3">
<h3 id="org76fb615"><a id="ID-1b40ccc8-f559-49c3-ae13-9642f9e7e9d5"></a>3.5. If-Range</h3>
<div class="outline-text-3" id="text-org76fb615">
<blockquote>
<p>
The "If-Range" header field provides a special conditional request mechanism that is similar to the <code>If-Match</code> and <code>If-Unmodified-Since</code> header fields but that instructs the recipient to ignore the <code>Range</code> header field if the validator doesn't match, resulting in transfer of the new selected representation instead of a <code>412 (Precondition Failed)</code> response. <code>If-Range</code> is defined in <a href="RFC7233.html#ID-2859ef1f-8309-4b7d-9e22-963391b5822a">Section 3.2</a> of [RFC7233].
</p>
</blockquote>

<p>
<code>If-Range</code> 头字段提供了一种特殊的条件请求机制。它类似于 <code>If-Match</code> 和 <code>If-Unmodified-Since</code> 头字段，但它指示接收到去忽略 <code>Range</code> 头字段，如果验证器不匹配的话，其结果是传输新的已选表示形式，而不是一个 <code>412 (Precondition Failed)</code> 响应。<code>If-Range</code> 是定义在<a href="RFC7233.html#ID-2859ef1f-8309-4b7d-9e22-963391b5822a">【RFC7233】章节 3.2</a>。
</p>
</div>
</div>
</div>

<div id="outline-container-org1c69e05" class="outline-2">
<h2 id="org1c69e05"><a id="ID-c983830d-bf6f-4e61-a905-285f070f9d20"></a>4. 状态码定义 / Status Code Definitions</h2>
<div class="outline-text-2" id="text-org1c69e05">
</div>

<div id="outline-container-orgf85f7a6" class="outline-3">
<h3 id="orgf85f7a6"><a id="ID-6033b2bf-1408-4756-9929-15dd6510c7e3"></a>4.1. 304 未更改 / 304 Not Modified</h3>
<div class="outline-text-3" id="text-orgf85f7a6">
<blockquote>
<p>
The <code>304 (Not Modified)</code> status code indicates that a conditional GET or HEAD request has been received and would have resulted in a <code>200 (OK)</code> response if it were not for the fact that the condition evaluated to false. In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the payload of a <code>200 (OK)</code> response.
</p>
</blockquote>

<p>
<code>304 (Not Modified)</code> 状态码表明：已接收到 GET 或 HEAD 条件请求，如果这个条件的求值结果为假的话，将返回的是一个 <code>200 (OK)</code> 响应。换句话说，服务器不需要传输目标资源的一个表示形式，因为这个请求表明了发起这个条件请求的客户端已经有一个有效的表示形式了，因此服务器让客户端重新使用那个已缓存的表示形式，可以把它当作是一个 <code>200 (OK)</code> 响应的有效载荷。
</p>

<blockquote>
<p>
The server generating a <code>304</code> response <b>MUST</b> generate any of the following header fields that would have been sent in a <code>200 (OK)</code> response to the same request: <code>Cache-Control</code>, <code>Content-Location</code>, <code>Date</code>, <code>ETag</code>, <code>Expires</code>, and <code>Vary</code>.
</p>
</blockquote>

<p>
服务器生成一个 <code>304</code> 响应的时候，假如生成的是一个 <code>200 (OK)</code> 响应到同一个请求，如果这个 <code>200</code> 响应包含下列头字段，那么，服务器 <b>必须</b> 将这些头字段同样生成到 <code>304</code> 响应里，包括：<code>Cache-Control</code>、<code>Content-Location</code>、<code>Date</code>、<code>ETag</code>、<code>Expires</code>、以及 <code>Vary</code>。
</p>

<blockquote>
<p>
Since the goal of a <code>304</code> response is to minimize information transfer when the recipient already has one or more cached representations, a sender <b>SHOULD NOT</b> generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., <code>Last-Modified</code> might be useful if the response does not have an <code>ETag</code> field).
</p>
</blockquote>

<p>
因为 <code>304</code> 响应的目标是在接收端已经有一个或多个已缓存的表示形式的时候让发送端最小化信息传输，因此，发送端 <b>不应当</b> 生成除上述所列出的头字段以外的<ruby>表示形式元数据<rt>representation metadata</rt></ruby>，除非这些元数据是为指导缓存更新的目的而存在的（比如，<code>Last-Modified</code> 可能有用于如果响应并未带有一个 <code>ETag</code> 字段的情况）。
</p>

<blockquote>
<p>
Requirements on a cache that receives a <code>304</code> response are defined in <a href="RFC7234.html#ID-eb92f86f-35bf-4b7a-b1ae-579da32c29a5">Section 4.3.4</a> of [RFC7234]. If the conditional request originated with an outbound client, such as a user agent with its own cache sending a conditional GET to a shared proxy, then the proxy <b>SHOULD</b> forward the <code>304</code> response to that client.
</p>
</blockquote>

<p>
接收到一个 <code>304</code> 响应时对于缓存服务器的要求，定义在<a href="RFC7234.html#ID-eb92f86f-35bf-4b7a-b1ae-579da32c29a5">【RFC7234】章节 4.3.4</a>。如果条件请求是源自一个<ruby>站外的客户端<rt>outbound client</rt></ruby>，比如一个用户代理具有它自己的缓存功能发送了一个条件 GET 到一个共享代理，那么，这个代理 <b>应当</b> 转发这个 <code>304</code> 响应到那个客户端。
</p>

<blockquote>
<p>
A <code>304</code> response cannot contain a message-body; it is always terminated by the first empty line after the header fields.
</p>
</blockquote>

<p>
<code>304</code> 响应消息不能包含一个<ruby>消息体<rt>message-body</rt></ruby>，它总是终止于头字段之后的第一个空行。
</p>
</div>
</div>

<div id="outline-container-org664c54f" class="outline-3">
<h3 id="org664c54f"><a id="ID-02e5a084-aac8-4f06-840f-507ef2489bb1"></a>4.2. 412 前提条件失败 / 412 Precondition Failed</h3>
<div class="outline-text-3" id="text-org664c54f">
<blockquote>
<p>
The <code>412 (Precondition Failed)</code> status code indicates that one or more conditions given in the request header fields evaluated to false when tested on the server. This response code allows the client to place preconditions on the current resource state (its current representations and metadata) and, thus, prevent the request method from being applied if the target resource is in an unexpected state.
</p>
</blockquote>

<p>
<code>412 (Precondition Failed)</code> 状态码表明：请求头字段所给定的一个或多个条件，在服务器上测试时的求值结果为假。这个响应让客户端可以放置前提条件到当前的资源状态（它的当前表示形式和元数据）上，然后，如果目标资源是处在一种预料之外的状态上时，阻止将请求方法的应用。
</p>
</div>
</div>
</div>

<div id="outline-container-org8287389" class="outline-2">
<h2 id="org8287389"><a id="ID-fce45320-6c1c-4486-a32b-2c553780d785"></a>5. 求值 / Evaluation</h2>
<div class="outline-text-2" id="text-org8287389">
<blockquote>
<p>
Except when excluded below, a recipient cache or origin server <b>MUST</b> evaluate received request preconditions after it has successfully performed its normal request checks and just before it would perform the action associated with the request method. A server <b>MUST</b> ignore all received preconditions if its response to the same request without those conditions would have been a status code other than a <code>2xx (Successful)</code> or <code>412 (Precondition Failed)</code>. In other words, redirects and failures take precedence over the evaluation of preconditions in conditional requests.
</p>
</blockquote>

<p>
除非被下面的情况所排除，接收端<ruby>缓存<rt>cache</rt></ruby>或者源服务器对所接收到的请求在成功完成的一般检查以后，在即将执行请求方法所关联的动作之前，<b>必须</b> 对这个请求的前提条件进行求值。如果一个请求在没有带有某些条件的时候，服务器将会响应除 <code>2xx (Successful)</code> 和 <code>412 (Precondition Failed)</code>，那么，相同的请求如果这些带有条件的话，服务器 <b>必须</b> 忽略所有接收到的前提条件。换句话说，在条件请求中，<ruby>重定向响应<rt>redirects</rt></ruby>以及<ruby>失败响应<rt>failures</rt></ruby>的优先级高于对前提条件的求值。
</p>

<blockquote>
<p>
A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource <b>MUST NOT</b> evaluate the conditional request header fields defined by this specification, and it <b>MUST</b> forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation. Likewise, a server <b>MUST</b> ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.
</p>
</blockquote>

<p>
一个服务器，如果它既不是目标资源的源服务器，也不能充当一个所请求的目标资源的缓存服务器，那么，它 <b>禁止</b> 对本规范所定义的条件请求头字段进行求值，并且它 <b>必须</b> 转发这些头字段，如果请求会被转发的话，这是因为生成这些头字段的客户是想让它们被能提供一种当前表示形式的服务器来求值的。同样，当服务器所接收到的条件请求的请求方法并不涉及对已选表示形式的选择或修改（比如 CONNECT、OPTIONS、或者 TRACE）的时候，服务器 <b>必须</b> 忽略由本规范所定义的条件请求头字段。
</p>

<blockquote>
<p>
Conditional request header fields that are defined by extensions to HTTP might place conditions on all recipients, on the state of the target resource in general, or on a group of resources. For instance, the "If" header field in WebDAV can make a request conditional on various aspects of multiple resources, such as locks, if the recipient understands and implements that field ([RFC4918], <a href="https://tools.ietf.org/html/rfc4918#section-10.4">Section 10.4</a>).
</p>
</blockquote>

<p>
由 HTTP 的扩展所定义的条件请求头字段可能将条件设定为针对所有接收端、或者针对目标资源的普遍状态、或者针对某一类资源。例如，WebDAV 规范里的 <code>If</code> 头字段能够发起一个针对多种资源的各个方面的条件请求，比如<ruby>锁<rt>locks</rt></ruby>，如果接收端理解并实现这个字段的话（<a href="https://tools.ietf.org/html/rfc4918#section-10.4">【RFC4918】章节 10.4</a>）。
</p>

<blockquote>
<p>
Although conditional request header fields are defined as being usable with the HEAD method (to keep HEAD's semantics consistent with those of GET), there is no point in sending a conditional HEAD because a successful response is around the same size as a <code>304 (Not Modified)</code> response and more useful than a <code>412 (Precondition Failed)</code> response.
</p>
</blockquote>

<p>
虽然条件请求头字段是定义为可以和 HEAD 方法一起使用（为了保持 HEAD 与 GET 的语义一致），但是发送一个条件 HEAD 请求是没有任何意义的，因为它的成功响应的大小差不多与一个 <code>304 (Not Modified)</code> 响应一样，并且比一个 <code>412 (Precondition Failed)</code> 响应更加实用。
</p>
</div>
</div>

<div id="outline-container-org35abd07" class="outline-2">
<h2 id="org35abd07"><a id="ID-a8107f7c-c07e-4a0b-a0e5-fc41064ca2b2"></a>6. 优先级 / Precedence</h2>
<div class="outline-text-2" id="text-org35abd07">
<blockquote>
<p>
When more than one conditional request header field is present in a request, the order in which the fields are evaluated becomes important. In practice, the fields defined in this document are consistently implemented in a single, logical order, since "lost update" preconditions have more strict requirements than cache validation, a validated cache is more efficient than a partial response, and entity tags are presumed to be more accurate than date validators.
</p>
</blockquote>

<p>
当一个请求中出现了超过一个条件请求头字段的时候，这些头字段的求值顺序就变得很重要了。实践中，本规范所定义的字段被一致实现为一种单一的逻辑顺序，但因为“丢失更新”的前提条件比<ruby>缓存验证<rt>cache validation</rt></ruby>有着更加严格的要求，因此，缓存验证比<ruby>部分响应<rt>partial response</rt></ruby>更加高效，以及，<ruby>实体标签<rt>entity tags</rt></ruby>被认为比<ruby>日期验证器<rt>date validators</rt></ruby>更加精准。
</p>

<blockquote>
<p>
A recipient cache or origin server <b>MUST</b> evaluate the request preconditions defined by this specification in the following order:
</p>

<ol class="org-ol">
<li>When recipient is the origin server and <code>If-Match</code> is present, evaluate the <code>If-Match</code> precondition:

<ul class="org-ul">
<li>if true, continue to step 3</li>
<li>if false, respond <code>412 (Precondition Failed)</code> unless it can be determined that the state-changing request has already succeeded (see <a href="#org220193c">Section 3.1</a>)</li>
</ul></li>

<li>When recipient is the origin server, <code>If-Match</code> is not present, and <code>If-Unmodified-Since</code> is present, evaluate the <code>If-Unmodified-Since</code> precondition:

<ul class="org-ul">
<li>if true, continue to step 3</li>
<li>if false, respond <code>412 (Precondition Failed)</code> unless it can be determined that the state-changing request has already succeeded (see <a href="#org2f3f176">Section 3.4</a>)</li>
</ul></li>

<li>When <code>If-None-Match</code> is present, evaluate the <code>If-None-Match</code> precondition:

<ul class="org-ul">
<li>if true, continue to step 5</li>
<li>if false for GET/HEAD, respond <code>304 (Not Modified)</code></li>
<li>if false for other methods, respond <code>412 (Precondition Failed)</code></li>
</ul></li>

<li>When the method is GET or HEAD, <code>If-None-Match</code> is not present, and <code>If-Modified-Since</code> is present, evaluate the <code>If-Modified-Since</code> precondition:

<ul class="org-ul">
<li>if true, continue to step 5</li>
<li>if false, respond <code>304 (Not Modified)</code></li>
</ul></li>

<li>When the method is GET and both <code>Range</code> and <code>If-Range</code> are present, evaluate the <code>If-Range</code> precondition:

<ul class="org-ul">
<li>if the validator matches and the <code>Range</code> specification is applicable to the selected representation, respond <code>206 (Partial Content)</code> [<a href="RFC7233.html">RFC7233</a>]</li>
</ul></li>

<li>Otherwise,

<ul class="org-ul">
<li>all conditions are met, so perform the requested action and respond according to its success or failure.</li>
</ul></li>
</ol>
</blockquote>

<p>
接收端缓存服务器或源服务器 <b>必须</b> 按以下的顺序来对本规范所定义的请求前提条件进行求值：
</p>

<ol class="org-ol">
<li>当接收端是源服务器，且出现了 <code>If-Match</code>，那么，对 <code>If-Match</code> 前提条件进行求值：

<ul class="org-ul">
<li>如果条件为真，跳到步骤 3；</li>
<li>如果条件为假，响应 <code>412 (Precondition Failed)</code>，除非它能够确定这个会改变状态的请求已经是成功的；（<a href="#org220193c">章节 3.1</a>）</li>
</ul></li>

<li>当接收端是源服务器，未出现 <code>If-Match</code>，但出现了 <code>If-Unmodified-Since</code>，那么，对 <code>If-Unmodified-Since</code> 前提条件进行求值：

<ul class="org-ul">
<li>如果条件为真，跳到步骤 3；</li>
<li>如果条件为假，响应 <code>412 (Precondition Failed)</code>，除非它能够确定这个会改变状态的请求已经是成功的；（<a href="#org2f3f176">章节 3.4</a>）</li>
</ul></li>

<li>当出现了 <code>If-None-Match</code>，那么，对 <code>If-None-Match</code> 前提条件进行求值：

<ul class="org-ul">
<li>如果条件为真，跳到步骤 5；</li>
<li>如果条件为假，且请求方法为 GET 或者 HEAD，响应 <code>304 (Not Modified)</code>；</li>
<li>如果条件为假，且请求方法为其他方法，响应 <code>412 (Precondition Failed)</code>；</li>
</ul></li>

<li>当请求方法是 GET 或者 HEAD，未出现 <code>If-None-Match</code>，但出现了 <code>If-Modified-Since</code>，那么，对 <code>If-Modified-Since</code> 前提条件进行求值：

<ul class="org-ul">
<li>如果条件为真，跳到步骤 5；</li>
<li>如果条件为假，响应 304 <code>(Not Modified)</code>；</li>
</ul></li>

<li>当请求方法是 GET，并且 <code>Range</code> 和 <code>If-Range</code> 都出现了，那么，对 <code>If-Range</code> 前提条件进行求值：

<ul class="org-ul">
<li>如果这个验证器匹配上了，并且 <code>Range</code> 规范适用于已选表示形式，那么，响应 <code>206 (Partial Content)</code>；【<a href="RFC7233.html">RFC7233</a>】</li>
</ul></li>

<li>否则

<ul class="org-ul">
<li>已经遍历了所有条件了，于是执行所请求的动作并根据它的成功或失败作出响应。</li>
</ul></li>
</ol>

<blockquote>
<p>
Any extension to HTTP/1.1 that defines additional conditional request header fields ought to define its own expectations regarding the order for evaluating such fields in relation to those defined in this document and other conditionals that might be found in practice.
</p>
</blockquote>

<p>
定义额外条件请求头字段的任何 HTTP/1.1 扩展都应该定义它自身期望这些字段相对于本文档所定义的字段以及其他可能在实践中所发现的条件式之间的求值顺序。
</p>
</div>
</div>

<div id="outline-container-org9097ce2" class="outline-2">
<h2 id="org9097ce2">7. IANA 注意事项 / IANA Considerations</h2>
<div class="outline-text-2" id="text-org9097ce2">
</div>
<div id="outline-container-org0a76196" class="outline-3">
<h3 id="org0a76196">7.1. 状态码登记 / Status Code Registration</h3>
<div class="outline-text-3" id="text-org0a76196">
<blockquote>
<p>
The "Hypertext Transfer Protocol (HTTP) Status Code Registry" located at <a href="http://www.iana.org/assignments/http-status-codes">http://www.iana.org/assignments/http-status-codes</a> has been updated with the registrations below:
</p>
</blockquote>

<p>
《超文本传输协议（HTTP）状态码登记表》位于 <a href="http://www.iana.org/assignments/http-status-codes">http://www.iana.org/assignments/http-status-codes</a>，已经更新了以下登记项。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Value</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">304</td>
<td class="org-left">Not Modified</td>
<td class="org-left"><a href="#orgf85f7a6">Section 4.1</a></td>
</tr>

<tr>
<td class="org-right">312</td>
<td class="org-left">Precondition Failed</td>
<td class="org-left"><a href="#org664c54f">Section 4.2</a></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orge607eac" class="outline-3">
<h3 id="orge607eac">7.2. 头字段登记 / Header Field Registration</h3>
<div class="outline-text-3" id="text-orge607eac">
<blockquote>
<p>
HTTP header fields are registered within the "Message Headers" registry maintained at <a href="http://www.iana.org/assignments/message-headers/">http://www.iana.org/assignments/message-headers/</a>.
</p>
</blockquote>

<p>
HTTP 头字段被登记在《消息头部》登记表中，并维护在 <a href="http://www.iana.org/assignments/message-headers/">http://www.iana.org/assignments/message-headers/</a>。
</p>

<blockquote>
<p>
This document defines the following HTTP header fields, so their associated registry entries have been updated according to the permanent registrations below (see [<a href="https://tools.ietf.org/html/rfc3864">BCP90</a>]):
</p>
</blockquote>

<p>
本文档定义了以下 HTTP 头字段，因此它们相关联的登记项已经根据以下永久登记条目进行更新（见【<a href="https://tools.ietf.org/html/rfc3864">BCP90</a>】）：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Header Field Name</th>
<th scope="col" class="org-left">Protocol</th>
<th scope="col" class="org-left">Status</th>
<th scope="col" class="org-left">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ETag</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left"><a href="#orgf0f9907">Section 2.3</a></td>
</tr>

<tr>
<td class="org-left">If-Match</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left"><a href="#org220193c">Section 3.1</a></td>
</tr>

<tr>
<td class="org-left">If-Modified-Since</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left"><a href="#orgbe71300">Section 3.3</a></td>
</tr>

<tr>
<td class="org-left">If-None-Match</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left"><a href="#org870b652">Section 3.2</a></td>
</tr>

<tr>
<td class="org-left">If-Unmodified-Since</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left"><a href="#org2f3f176">Section 3.4</a></td>
</tr>

<tr>
<td class="org-left">Last-Modified</td>
<td class="org-left">http</td>
<td class="org-left">standard</td>
<td class="org-left"><a href="#org3974cdd">Section 2.2</a></td>
</tr>
</tbody>
</table>

<blockquote>
<p>
The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</p>
</blockquote>

<p>
主管以上条目的变更的是 "IETF (iesg@ietf.org) - Internet Engineering Task Force"。
</p>
</div>
</div>
</div>

<div id="outline-container-org01ca2bc" class="outline-2">
<h2 id="org01ca2bc">8. 安全注意事项 / Security Considerations</h2>
<div class="outline-text-2" id="text-org01ca2bc">
<blockquote>
<p>
This section is meant to inform developers, information providers, and users of known security concerns specific to the HTTP conditional request mechanisms. More general security considerations are addressed in HTTP "Message Syntax and Routing" [<a href="RFC7230.html">RFC7230</a>] and "Semantics and Content" [<a href="RFC7231.html">RFC7231</a>].
</p>
</blockquote>

<p>
本章节是为了告诉开发者、信息提供商、以及用户，针对 HTTP 条件请求机制的已知的安全注意事项。《消息句法和路由》【<a href="RFC7230.html">RFC7230</a>】以及《语义和内容》【<a href="RFC7231.html">RFC7231</a>】有更广泛的安全注意事项。
</p>

<blockquote>
<p>
The validators defined by this specification are not intended to ensure the validity of a representation, guard against malicious changes, or detect man-in-the-middle attacks. At best, they enable more efficient cache updates and optimistic concurrent writes when all participants are behaving nicely. At worst, the conditions will fail and the client will receive a response that is no more harmful than an HTTP exchange without conditional requests.
</p>
</blockquote>

<p>
本规范所定义的验证器并不是试图去保证表示形式的<ruby>有效性<rt>validity</rt></ruby>、<ruby>恶意修改<rt>malicious changes</rt></ruby>的防范、以及<ruby>中间人攻击<rt>man-in-the-middle attacks</rt></ruby>的检测。最好的情况是，当所有参与者都行为良好，它们使得缓存的更新能够更加高效，使得支持乐观锁的写入。最坏的情况是，条件会失败并且客户端像没有进行条件请求一样正常地接收到响应。
</p>

<blockquote>
<p>
An entity-tag can be abused in ways that create privacy risks. For example, a site might deliberately construct a semantically invalid entity-tag that is unique to the user or user agent, send it in a cacheable response with a long freshness time, and then read that entity-tag in later conditional requests as a means of re-identifying that user or user agent. Such an identifying tag would become a persistent identifier for as long as the user agent retained the original cache entry. User agents that cache representations ought to ensure that the cache is cleared or replaced whenever the user performs privacy-maintaining actions, such as clearing stored cookies or changing to a private browsing mode.
</p>
</blockquote>

<p>
实体标签可能在生成私隐风险方面被滥用。例如，一个网站可能故意构造一个语义有效的实体标签，这个实体标签是一一对应于一个用户或用户代理的，然后将它发送到一个可缓存的响应里，带有一个非常长的新鲜度时间，然后在接下来的条件请求中读取这个实体标签来作为重新识别用户或用户代理的一种方法。只要用户代理保持原始的缓存条目，这种识别型的标签就会成为一种永久的标识符。每当用户执行<ruby>确保隐私的行为<rt>privacy-maintaining actions</rt></ruby>的时候，缓存表示形式的用户代理应该确保缓存已被清除或者替换，比如清除已存储的 cookies 或者变更为一种隐私浏览模式。
</p>
</div>
</div>

<div id="outline-container-org196768e" class="outline-2">
<h2 id="org196768e">9. 鸣谢 / Acknowledgments</h2>
<div class="outline-text-2" id="text-org196768e">
<blockquote>
<p>
See <a href="RFC7230.html#ID-ccf5090b-19c1-4f1a-a7ac-2e94a6dfa626">Section 10</a> of [RFC7230].
</p>
</blockquote>

<p>
见【RFC7230】<a href="RFC7230.html#ID-ccf5090b-19c1-4f1a-a7ac-2e94a6dfa626">章节 10</a>。
</p>
</div>
</div>

<div id="outline-container-org9123b20" class="outline-2">
<h2 id="org9123b20">10. 参考资料 / References</h2>
<div class="outline-text-2" id="text-org9123b20">
</div>
<div id="outline-container-org8d78b42" class="outline-3">
<h3 id="org8d78b42">10.1. 规范性参考资料 / Normative References</h3>
<div class="outline-text-3" id="text-org8d78b42">
<dl class="org-dl">
<dt>[RFC2119]</dt><dd>Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, March 1997.</dd>
<dt>[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, RFC 5234, January 2008.</dd>
<dt>[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, RFC 7230, June 2014.</dd>
<dt>[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”, RFC 7231, June 2014.</dd>
<dt>[RFC7233]</dt><dd>Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Range Requests”, RFC 7233, June 2014.</dd>
<dt>[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Caching”, RFC 7234, June 2014.</dd>
</dl>
</div>
</div>

<div id="outline-container-org82edc8f" class="outline-3">
<h3 id="org82edc8f">10.2. 信息性参考资料 / Informative References</h3>
<div class="outline-text-3" id="text-org82edc8f">
<dl class="org-dl">
<dt>[BCP90]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, “Registration Procedures for Message Header Fields”, BCP 90, RFC 3864, September 2004.</dd>
<dt>[RFC2616]</dt><dd>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol &#x2013; HTTP/1.1”, RFC 2616, June 1999.</dd>
<dt>[RFC4918]</dt><dd>Dusseault, L., Ed., “HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)”, RFC 4918, June 2007.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orga07aac9" class="outline-2">
<h2 id="orga07aac9">附录 A：相对 RFC 2616 的变化 / Appendix A. Changes from RFC 2616</h2>
<div class="outline-text-2" id="text-orga07aac9">
<blockquote>
<p>
The definition of validator weakness has been expanded and clarified. (<a href="#org265ee00">Section 2.1</a>)
</p>
</blockquote>

<p>
扩充以及明确了验证器的弱验证类型的定义。（<a href="#org265ee00">章节 2.1</a>）
</p>

<blockquote>
<p>
Weak entity-tags are now allowed in all requests except range requests. (<a href="#org265ee00">Sections 2.1</a> and <a href="#org870b652">3.2</a>)
</p>
</blockquote>

<p>
现在，允许弱实体标签用在除范围请求以外的所有的请求中。（<a href="#org265ee00">章节 2.1</a> 和 <a href="#org870b652">3.2</a>）
</p>

<blockquote>
<p>
The <code>ETag</code> header field ABNF has been changed to not use <code>quoted-string</code>, thus avoiding escaping issues. (<a href="#orgf0f9907">Section 2.3</a>)
</p>
</blockquote>

<p>
<code>ETag</code> 头字段的 ABNF 规则已经改变为不使用 <code>quoted-string</code> 规则，以避免转义的问题。（<a href="#orgf0f9907">章节 2.3</a>）
</p>

<blockquote>
<p>
<code>ETag</code> is defined to provide an entity tag for the selected representation, thereby clarifying what it applies to in various situations (such as a PUT response). (<a href="#orgf0f9907">Section 2.3</a>)
</p>
</blockquote>

<p>
<code>ETag</code> 被定义为为已选表示形式提供一个实体标签，因此明确了它在各种场景中的适用范围（比如一个 PUT 响应）。（<a href="#orgf0f9907">章节 2.3</a>）
</p>

<blockquote>
<p>
The precedence for evaluation of conditional requests has been defined. (<a href="#org35abd07">Section 6</a>)
</p>
</blockquote>

<p>
定义了条件请求的求值优级级。（<a href="#org35abd07">章节 6</a>）
</p>
</div>
</div>

<div id="outline-container-org4dbc73e" class="outline-2">
<h2 id="org4dbc73e"><a id="ID-6076a436-545c-46ed-ab6b-a6a7c31ab308"></a>附录 B：引进的 ABNF / Appendix B. Imported ABNF</h2>
<div class="outline-text-2" id="text-org4dbc73e">
<blockquote>
<p>
The following core rules are included by reference, as defined in <a href="https://tools.ietf.org/html/rfc5234#appendix-B.1">Appendix B.1</a> of [RFC5234]: <code>ALPHA</code> (letters), <code>CR</code> (carriage return), <code>CRLF</code> (CR LF), <code>CTL</code> (controls), <code>DIGIT</code> (decimal 0-9), <code>DQUOTE</code> (double quote), <code>HEXDIG</code> (hexadecimal 0-9/A-F/a-f), <code>LF</code> (line feed), <code>OCTET</code> (any 8-bit sequence of data), <code>SP</code> (space), and <code>VCHAR</code> (any visible US-ASCII character).
</p>
</blockquote>

<p>
本规范引用了以下定义在<a href="https://tools.ietf.org/html/rfc5234#appendix-B.1">【RFC5234】附录 B.1</a> 中的核心规则：<code>ALPHA</code> （字母）、<code>CR</code> （回车符）、<code>CRLF</code> （回车换行符）、<code>CTL</code> （控制字符）、<code>DIGIT</code> （十进制数字 0-9）、<code>DQUOTE</code> （双引号）、<code>HEXDIG</code> （十六进制数字 0-9/A-F/a-f）、<code>HTAB</code> （水平制表符）、<code>LF</code> （换行符）、<code>OCTET</code> （八位组字节）、<code>SP</code> （空白）以及 <code>VCHAR</code> （【USASCII】可见字符）。
</p>

<blockquote>
<p>
The rules below are defined in [<a href="RFC7230.html">RFC7230</a>]:
</p>
</blockquote>

<p>
以下规则定义在【<a href="RFC7230.html">RFC7230</a>】中：
</p>

<div class="org-src-container">
<pre class="src src-text">OWS           = &lt;OWS, see [RFC7230], Section 3.2.3&gt;
obs-text      = &lt;obs-text, see [RFC7230], Section 3.2.6&gt;
</pre>
</div>

<blockquote>
<p>
The rules below are defined in other parts:
</p>
</blockquote>

<p>
以下规则定义在其他部分中：
</p>

<div class="org-src-container">
<pre class="src src-text">HTTP-date     = &lt;HTTP-date, see [RFC7231], Section 7.1.1.1&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc516f2" class="outline-2">
<h2 id="orgbc516f2"><a id="ID-263a84c3-9879-4599-b429-05cfdb9bf039"></a>附录 C：ABNF 集合 / Appendix C. Collected ABNF</h2>
<div class="outline-text-2" id="text-orgbc516f2">
<blockquote>
<p>
In the collected ABNF below, list rules are expanded as per <a href="RFC7230.html#ID-f8234cb5-154d-4daf-82fd-ed54ac75cf8b">Section 1.2</a> of [RFC7230].
</p>
</blockquote>

<p>
下列 ABNF 规则集合中，列表规则是在<a href="RFC7230.html#ID-f8234cb5-154d-4daf-82fd-ed54ac75cf8b">【RFC7230】章节 1.2</a> 所扩充的。
</p>

<div class="org-src-container">
<pre class="src src-text">ETag = entity-tag

HTTP-date = &lt;HTTP-date, see [RFC7231], Section 7.1.1.1&gt;

If-Match = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
If-Modified-Since = HTTP-date
If-None-Match = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
If-Unmodified-Since = HTTP-date

Last-Modified = HTTP-date

OWS = &lt;OWS, see [RFC7230], Section 3.2.3&gt;

entity-tag = [ weak ] opaque-tag
etagc = "!" / %x23-7E ; '#'-'~'
 / obs-text

obs-text = &lt;obs-text, see [RFC7230], Section 3.2.6&gt;
opaque-tag = DQUOTE *etagc DQUOTE

weak = %x57.2F ; W/
</pre>
</div>
</div>
</div>

<div id="outline-container-orgddedd39" class="outline-2">
<h2 id="orgddedd39">Index</h2>
<div class="outline-text-2" id="text-orgddedd39">
<ul class="org-ul">
<li>3
<ul class="org-ul">
<li>304 Not Modified (status code)  4.1, 7.1</li>
</ul></li>
<li>4
<ul class="org-ul">
<li>412 Precondition Failed (status code)  4.2, 7.1</li>
</ul></li>
<li>B
<ul class="org-ul">
<li>BCP90  7.2, 10.2</li>
</ul></li>
<li>E
<ul class="org-ul">
<li>ETag header field  2, 2.3, 7.2, A, A</li>
</ul></li>
<li>G
<ul class="org-ul">
<li>Grammar  
<ul class="org-ul">
<li>entity-tag  2.3</li>
<li>ETag  2.3</li>
<li>etagc  2.3</li>
<li>If-Match  3.1</li>
<li>If-Modified-Since  3.3</li>
<li>If-None-Match  3.2</li>
<li>If-Unmodified-Since  3.4</li>
<li>Last-Modified  2.2</li>
<li>opaque-tag  2.3</li>
<li>weak  2.3</li>
</ul></li>
</ul></li>
<li>I
<ul class="org-ul">
<li>If-Match header field  3.1, 6, 7.2</li>
<li>If-Modified-Since header field  3.3, 7.2</li>
<li>If-None-Match header field  3.2, 7.2, A</li>
<li>If-Unmodified-Since header field  3.4, 6, 7.2</li>
</ul></li>
<li>L
<ul class="org-ul">
<li>Last-Modified header field  2, 2.2, 7.2</li>
</ul></li>
<li>M
<ul class="org-ul">
<li>metadata  2</li>
</ul></li>
<li>R
<ul class="org-ul">
<li>RFC2119  1.1, 10.1</li>
<li>RFC2616  2.3, 10.2
<ul class="org-ul">
<li>Section 3.11  2.3</li>
</ul></li>
<li>RFC4918  2, 5, 10.2
<ul class="org-ul">
<li>Section 10.4  5</li>
</ul></li>
<li>RFC5234  1.2, 10.1, B
<ul class="org-ul">
<li>Appendix B.1  B</li>
</ul></li>
<li>RFC7230  1, 1.1, 1.2, 2.3.3, 8, 9, 10.1, B, B, B, C
<ul class="org-ul">
<li>Section 1.2  C</li>
<li>Section 2.5  1.1</li>
<li>Section 3.2.3  B</li>
<li>Section 3.2.6  B</li>
<li>Section 4  2.3.3</li>
<li>Section 7  1.2</li>
<li>Section 10  9</li>
</ul></li>
<li>RFC7231  1, 1, 2.3.3, 2.3.3, 3.2, 8, 10.1, B
<ul class="org-ul">
<li>Section 3  1</li>
<li>Section 3.4  2.3.3</li>
<li>Section 4.2.1  3.2</li>
<li>Section 5.3.4  2.3.3</li>
<li>Section 7.1.1.1  B</li>
</ul></li>
<li>RFC7233  3.5, 6, 10.1
<ul class="org-ul">
<li>Section 3.2  3.5</li>
</ul></li>
<li>RFC7234  1, 2.2.1, 2.3.1, 3.2, 3.3, 4.1, 10.1
<ul class="org-ul">
<li>Section 4.3.2  3.2, 3.3</li>
<li>Section 4.3.4  4.1</li>
</ul></li>
</ul></li>
<li>S
<ul class="org-ul">
<li>selected representation  1</li>
</ul></li>
<li>V
<ul class="org-ul">
<li>validator  2
<ul class="org-ul">
<li>strong  2.1</li>
<li>weak  2.1</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org59265de" class="outline-2">
<h2 id="org59265de">Authors' Addresses</h2>
<div class="outline-text-2" id="text-org59265de">
<pre class="example">
Roy T. Fielding (editor)
Adobe Systems Incorporated
345 Park Ave
San Jose, CA 95110
USA
Email: fielding@gbiv.com
URI: http://roy.gbiv.com/
</pre>

<pre class="example">
Julian F. Reschke (editor)
greenbytes GmbH
Hafenweg 16
Muenster, NW 48155
Germany
Email: julian.reschke@greenbytes.de
URI: http://greenbytes.de/tech/webdav/
</pre>

<pre class="example">
阿多（译者）
</pre>
</div>
</div>
</div>
</body>
</html>
