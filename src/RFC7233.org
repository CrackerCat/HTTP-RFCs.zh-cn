#+FILETAGS: :note:rfc:
#+TITLE: RFC7233: Hypertext Transfer Protocol (HTTP/1.1): Range Requests
#+SELECT_TAGS: export
#+OPTIONS: toc:5 ^:{} H:6 num:0
#+UNNUMBERED: t
#+bind: org-export-publishing-directory "./docs"

#+BEGIN_EXPORT html
<a class="github-repo" href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <svg height="18" width="18" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
  <span>View Repo</span>
</a>
#+END_EXPORT

#+BEGIN_EXPORT html
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img alt="" src="https://img.shields.io/github/license/duoani/HTTP-RFCs.zh-cn.svg?style=social"/>
</a>
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img src="https://img.shields.io/github/stars/duoani/HTTP-RFCs.zh-cn.svg?style=social&label=Stars"/>
</a>
#+END_EXPORT

#+BEGIN_SRC text
                                                         PROPOSED STANDARD
                                                              Errata Exist
  Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
  Request for Comments: 7233                                         Adobe
  Obsoletes: 2616                                            Y. Lafon, Ed.
  Category: Standards Track                                            W3C
  ISSN: 2070-1721                                          J. Reschke, Ed.
                                                                greenbytes
                                                                June 2014
#+END_SRC

* 摘要 / Abstract

#+BEGIN_QUOTE
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines range requests and the rules for constructing and combining responses to those requests.
#+END_QUOTE

超文本传输协议（HTTP）是一种[[ruby:stateless][无状态]]的应用层协议，适用于分布式、协作式的超文本信息系统。本文档定义了[[ruby:range%20requests][范围请求]]，以及回应给这些请求的响应相关的构造和结合规则。

* 备忘状态 / Status of This Memo

#+BEGIN_QUOTE
This is an Internet Standards Track document.
#+END_QUOTE

#+BEGIN_QUOTE
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
#+END_QUOTE

#+BEGIN_QUOTE
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7233.
#+END_QUOTE

* Copyright Notice

#+BEGIN_QUOTE
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
#+END_QUOTE

#+BEGIN_QUOTE
This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
#+END_QUOTE

#+BEGIN_QUOTE
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
#+END_QUOTE

* 1. 引言 / Introduction

#+BEGIN_QUOTE
Hypertext Transfer Protocol (HTTP) clients often encounter interrupted data transfers as a result of canceled requests or dropped connections. When a client has stored a partial representation, it is desirable to request the remainder of that representation in a subsequent request rather than transfer the entire representation. Likewise, devices with limited local storage might benefit from being able to request only a subset of a larger representation, such as a single page of a very large document, or the dimensions of an embedded image.
#+END_QUOTE

超文本传输协议（HTTP）客户端在请求被取消或者连接被丢弃的时候，其结果通常是数据传输被打断。当客户端已经存储了表示形式的一部分的时候，理想的情况是在一个后续请求中继续请求这个表示形式的[[ruby:remainder][剩余部分]]，而不是重新传输[[ruby:entire][整个]]表示形式。同样，本地存储受限的设备可以受益于能够请求一个大的表示形式的一个[[ruby:subset][子集]]，比如一个非常大的文档中的其中一页，或者一张内嵌图像的尺寸。

#+BEGIN_QUOTE
This document defines HTTP/1.1 range requests, partial responses, and the multipart/byteranges media type. Range requests are an OPTIONAL feature of HTTP, designed so that recipients not implementing this feature (or not supporting it for the target resource) can respond as if it is a normal GET request without impacting interoperability. Partial responses are indicated by a distinct status code to not be mistaken for full responses by caches that might not implement the feature.
#+END_QUOTE

本文档定义了 HTTP/1.1 [[ruby:range%20requests][范围请求]]、[[ruby:partial%20responses][部分响应]]、以及 multipart/byteranges 媒体类型。范围请求是 HTTP 的一种 *可选的* 的功能，这样设计以便于接收端在没有实现这个功能（或者目标资源不支持这个功能）的情况下能够像一个普通 GET 请求一样作出响应，而不会影响[[ruby:interoperability][互操作性]]。[[ruby:partial%20response][部分响应]]由一个独特状态码来表明，以避免可能未实现这个功能的缓存不会误以为这是一个[[ruby:full%20response][完整的响应]]。

#+BEGIN_QUOTE
Although the range request mechanism is designed to allow for extensible range types, this specification only defines requests for byte ranges.
#+END_QUOTE

虽然范围请求的机制被设计为允许[[ruby:extensible%20range%20types][可扩展的范围类型]]，但本规范只对[[ruby:byte%20ranges][字节范围]]的请求进行定义。

** 1.1. 一致性和错误处理 / Conformance and Error Handling

#+BEGIN_QUOTE
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[[https://tools.ietf.org/html/rfc2119][RFC2119]]].
#+END_QUOTE

本文档中的关键词 *[[ruby:MUST][必须]]*、*[[ruby:MUST%20NOT][禁止]]*、*[[ruby:REQUIRED][要求]]*、*[[ruby:SHALL][必须]]*、*[[ruby:SHALL%20NOT][禁止]]*、*[[ruby:SHOULD][应该]]*、*[[ruby:SHOULD%20NOT][不应当]]*、*[[ruby:RECOMMENDED][推荐]]*、*[[ruby:MAY][可以]]* 和 *[[ruby:OPTIONAL][可选]]* 的意义与【[[https://tools.ietf.org/html/rfc2119][RFC2119]]】一致。

#+BEGIN_QUOTE
Conformance criteria and considerations regarding error handling are defined in [[id:A0441F72-9799-4667-9477-1E05885946A1][Section 2.5]] of [RFC7230].
#+END_QUOTE

关于错误处理的一致性标准以及注意事项已在[[id:A0441F72-9799-4667-9477-1E05885946A1][【RFC7230】章节 2.5]] 中定义了。

** 1.2. 句法标记 / Syntax Notation

#+BEGIN_QUOTE
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [[[https://tools.ietf.org/html/rfc5234][RFC5234]]] with a list extension, defined in [[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][Section 7]] of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). [[id:47a9d902-5e79-48a6-b335-dae2828bbde5][Appendix C]] describes rules imported from other documents. [[id:89bbf73a-99bb-4124-88c1-b860a26b1f77][Appendix D]] shows the collected grammar with all list operators expanded to standard ABNF notation.
#+END_QUOTE

本规范使用了扩展巴科斯范式（ABNF）标记法【[[https://tools.ietf.org/html/rfc5234][RFC5234]]】，另外，出于定义的紧凑性的考虑，本规范对 ABNF 规则进行了扩展（见[[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][【RFC7230】章节 7]]），允许使用一个 =#= 操作符（类似于 =*= 操作符，指代“重复”）来定义一种以逗号分隔的列表。[[id:47a9d902-5e79-48a6-b335-dae2828bbde5][附录 C]] 描述了从其他文档中引进的规则。[[id:89bbf73a-99bb-4124-88c1-b860a26b1f77][附录 D]] 展示了所有已收集的包含列表扩展规则以及标准 ABNF 标记的语法。

* 2. 范围单位 / Range Units
:PROPERTIES:
:ID:       6d7d656a-9741-4193-abd3-60f2f2b3a11a
:END:

#+BEGIN_QUOTE
A representation can be partitioned into subranges according to various structural units, depending on the structure inherent in the representation's media type. This "range unit" is used in the =Accept-Ranges= ([[id:cf601084-e3af-41bc-9ff7-8f903ca59fa8][Section 2.3]]) response header field to advertise support for range requests, the =Range= ([[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][Section 3.1]]) request header field to delineate the parts of a representation that are requested, and the =Content-Range= ([[id:7a682301-f05e-4e79-8242-398bbfb57c74][Section 4.2]]) payload header field to describe which part of a representation is being transferred.
#+END_QUOTE

一个表示形式可以依据各种[[ruby:structural%20units][结构单元（结构单位）]]来划分为多个子范围，这种划分依赖于继承自这个表示形式的媒体类型的结构。这个“[[ruby:range%20unit][范围单位]]”是用在 =Accept-Ranges= （[[id:cf601084-e3af-41bc-9ff7-8f903ca59fa8][章节 2.3]]）响应头字段里以声明：服务器能够支持范围请求；用在 =Range= （[[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][章节 3.1]]）请求头字段里以描绘：所请求的一个表示形式的哪一部分；用在 =Content-Range= （[[id:7a682301-f05e-4e79-8242-398bbfb57c74][章节 4.2]]）有效载荷头字段里以描述：一个表示形式的哪一部分将会被传输。

#+BEGIN_SRC text
  range-unit       = bytes-unit / other-range-unit
#+END_SRC

** 2.1. 字节范围 / Byte Ranges
:PROPERTIES:
:ID:       67c9bce9-6c76-46ec-9932-1b5dde9f7746
:END:

#+BEGIN_QUOTE
Since representation data is transferred in payloads as a sequence of octets, a byte range is a meaningful substructure for any representation transferable over HTTP (Section 3 of [RFC7231]). The "bytes" range unit is defined for expressing subranges of the data's octet sequence.
#+END_QUOTE

因为表示形式数据是以[[ruby:octets][字节]]序列的方式在有效载荷里传输的，因此，对于任何可通过 HTTP 进行传输的表示形式，[[ruby:byte%20range][字节范围]]都是[[ruby:meaningful%20substructure][有意义的基础结构]]。

#+BEGIN_QUOTE
译注："octet" 和 "byte" 都译作字节，其区别是，"octet" 是特指 8 位的字节，因此也被称为“八位组”。而 "byte" 可能是 8 位，也可能为其他位。
#+END_QUOTE

#+BEGIN_SRC text
  bytes-unit       = "bytes"
#+END_SRC

#+BEGIN_QUOTE
A byte-range request can specify a single range of bytes or a set of ranges within a single representation.
#+END_QUOTE

一个字节范围请求能够指定一个单一的字节范围，也可以指定同一个表示形式里的一个范围集合。

#+BEGIN_SRC text
  byte-ranges-specifier = bytes-unit "=" byte-range-set
  byte-range-set  = 1#( byte-range-spec / suffix-byte-range-spec )
  byte-range-spec = first-byte-pos "-" [ last-byte-pos ]
  first-byte-pos  = 1*DIGIT
  last-byte-pos   = 1*DIGIT
#+END_SRC

#+BEGIN_QUOTE
The =first-byte-pos= value in a =byte-range-spec= gives the byte-offset of the first byte in a range. The =last-byte-pos= value gives the byte-offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero.
#+END_QUOTE

在一个 =byte-range-spec= 中的 =first-byte-pos= 的值给出了在一个范围内第一个字节的[[ruby:byte-offset][偏移量]]。=last-byte-pos= 的值给出了在一个范围内最后一个字节的偏移量，也就是说，是[[ruby:inclusive][包括]]所指定的这个位置的字节的。字节偏移量从 0 开始。

#+BEGIN_QUOTE
Examples of =byte-ranges-specifier= values:
#+END_QUOTE

=byte-ranges-specifier= 值的一些示例：

- The first 500 bytes (byte offsets 0-499, inclusive):
  
  第一组 500 个字节（字节偏移量为 0-499，[[ruby:inclusive][闭合区间]]）：
  
  #+BEGIN_EXAMPLE
    bytes=0-499
  #+END_EXAMPLE
  
- The second 500 bytes (byte offsets 500-999, inclusive):
  
  第二组 500 个字节（字节偏移量为 500-999，闭合区间）：

  #+BEGIN_EXAMPLE
    bytes=500-999
  #+END_EXAMPLE

#+BEGIN_QUOTE
A =byte-range-spec= is invalid if the =last-byte-pos= value is present and less than the =first-byte-pos=.
#+END_QUOTE

在 =byte-range-spec= 中，如果有出现 =last-byte-pos= 值，并且它小于 =first-byte-pos=，那么这个 =byte-range-spec= 是无效的。

#+BEGIN_QUOTE
A client can limit the number of bytes requested without knowing the size of the selected representation. If the =last-byte-pos= value is absent, or if the value is greater than or equal to the current length of the representation data, the byte range is interpreted as the remainder of the representation (i.e., the server replaces the value of =last-byte-pos= with a value that is one less than the current length of the selected representation).
#+END_QUOTE

客户端可以在不知道已选表示形式大小的情况下限制所请求的字节数量。如果缺少 =last-byte-pos= 值，或者其值大于或等于表示形式数据的当前长度，那么，字节范围会被解释为这个表示形式的剩余部分（也就是说，服务器将这个 =last-byte-pos= 的值替换为已选定表示形式的长度减 1 的值）。

#+BEGIN_QUOTE
A client can request the last N bytes of the selected representation using a =suffix-byte-range-spec=.
#+END_QUOTE

客户端可以使用一个 =suffix-byte-range-spec= 来请求已选表示形式的最后 N 个字节。

#+BEGIN_SRC text
  suffix-byte-range-spec = "-" suffix-length
  suffix-length = 1*DIGIT
#+END_SRC

#+BEGIN_QUOTE
译注：需要注意的是，=suffix-length= 的语义是“字节的长度”，而 =first-byte-pos= 和 =last-byte-pos= 的语义是“字节的序号（偏移量）”。
#+END_QUOTE

#+BEGIN_QUOTE
If the selected representation is shorter than the specified =suffix-length=, the entire representation is used.
#+END_QUOTE

如果已选表示形式的长度小于 =suffix-length= 所指定的值，表示使用整个表示形式。

#+BEGIN_QUOTE
Additional examples, assuming a representation of length 10000:
#+END_QUOTE

再给出一些例子，假设一个表示形式的长度为 10000：

- The final 500 bytes (byte offsets 9500-9999, inclusive):
  
  最后 500 个字节（字节偏移量为 9500-9999，闭合区间）：

  #+BEGIN_EXAMPLE
    bytes=-500
  #+END_EXAMPLE
  
  Or:

  或者
  
  #+BEGIN_EXAMPLE
    bytes=9500-
  #+END_EXAMPLE
  
- The first and last bytes only (bytes 0 and 9999):
  
  第一个字节和最后一个字节（第 0 号字节和第 9999 号字节）：
  
  #+BEGIN_EXAMPLE
    bytes=0-0,-1
  #+END_EXAMPLE
  
- Other valid (but not canonical) specifications of the second 500 bytes (byte offsets 500-999, inclusive):
  
  其他有效的（但[[ruby:not%20canonical][不规范的]]）对第二组 500 个字节的指定（字节偏移量为 500-999，闭合区间）：

  #+BEGIN_EXAMPLE
  bytes=500-600,601-999
  bytes=500-700,601-999
  #+END_EXAMPLE
  
#+BEGIN_QUOTE
If a valid =byte-range-set= includes at least one =byte-range-spec= with a =first-byte-pos= that is less than the current length of the representation, or at least one =suffix-byte-range-spec= with a non-zero =suffix-length=, then the =byte-range-set= is satisfiable. Otherwise, the =byte-range-set= is unsatisfiable.
#+END_QUOTE

如果一个有效的 =byte-range-set= 包含至少一个 =byte-range-spec= 带有少于表示形式的当前长度的一个 =first-byte-pos= 值，或者包含至少一个 =suffix-byte-range-spec= 带有一个非零的 =suffix-length=，那么，这个 =byte-range-set= 是[[ruby:satisfiable][可以满足的]]。否则，这个 =byte-range-set= 是[[ruby:unsatisfiable][不可满足的]]。

#+BEGIN_QUOTE
In the byte-range syntax, =first-byte-pos=, =last-byte-pos=, and =suffix-length= are expressed as decimal number of octets. Since there is no predefined limit to the length of a payload, recipients *MUST* anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.
#+END_QUOTE

在字节范围句法中，=first-byte-pos=、=last-byte-pos=、以及 =suffix-length= 所表达的是[[ruby:decimal%20number%20of%20octets][八位组字节的十进制数]]。由于没有预定义有效载荷的长度限制，因此，接收端 *必须* 能预料到[[ruby:big%20decimal%20numbers][特大数值]]的可能，并且避免由于整型类型转换溢出所引起的解析错误。

** 2.2. 其他范围单位 / Other Range Units

#+BEGIN_QUOTE
Range units are intended to be extensible. New range units ought to be registered with IANA, as defined in [[id:c7bd6955-92e0-4665-a775-766ad3133ac0][Section 5.1]].
#+END_QUOTE

范围单位是可扩展的。新的范围单位应该在 IANA 上进行登记，如[[id:c7bd6955-92e0-4665-a775-766ad3133ac0][章节 5.1]] 所述。

#+BEGIN_SRC text
  other-range-unit = token
#+END_SRC

** 2.3. Accept-Ranges
:PROPERTIES:
:ID:       cf601084-e3af-41bc-9ff7-8f903ca59fa8
:END:

#+BEGIN_QUOTE
The "Accept-Ranges" header field allows a server to indicate that it supports range requests for the target resource.
#+END_QUOTE

=Accept-Range= 头字段让服务器可以表明它支持对这个目标资源的范围请求。

#+BEGIN_SRC text
  Accept-Ranges     = acceptable-ranges
  acceptable-ranges = 1#range-unit / "none"
#+END_SRC

#+BEGIN_QUOTE
An origin server that supports byte-range requests for a given target resource *MAY* send
#+END_QUOTE

支持对一个给定目标资源进行范围请求的源服务器 *可以* 发送：

#+BEGIN_EXAMPLE
  Accept-Ranges: bytes
#+END_EXAMPLE

#+BEGIN_QUOTE
to indicate what range units are supported. A client *MAY* generate range requests without having received this header field for the resource involved. Range units are defined in [[id:6d7d656a-9741-4193-abd3-60f2f2b3a11a][Section 2]].
#+END_QUOTE

来表明它支持什么范围单位。客户端 *可以* 在没有接收到这个头字段的情况下生成范围请求。范围单位定义在[[id:6d7d656a-9741-4193-abd3-60f2f2b3a11a][章节 2]]。

#+BEGIN_QUOTE
A server that does not support any kind of range request for the target resource *MAY* send
#+END_QUOTE

不支持对目标资源进行任何类型的范围请求的服务器，*可以* 发送：

#+BEGIN_EXAMPLE
  Accept-Ranges: none
#+END_EXAMPLE

#+BEGIN_QUOTE
to advise the client not to attempt a range request.
#+END_QUOTE

来通告客户端不要试图发送范围请求。

* 3. 范围请求 / Range Requests
:PROPERTIES:
:ID:       6be04fa7-4c91-438b-8fa6-f152390569c0
:END:
** 3.1. Range
:PROPERTIES:
:ID:       a70b4aaa-f776-4d5b-a31d-60d1ad16d85e
:END:

#+BEGIN_QUOTE
The "Range" header field on a GET request modifies the method semantics to request transfer of only one or more subranges of the selected representation data, rather than the entire selected representation data.
#+END_QUOTE

在一个 GET 请求中的 =Range= 头字段将请求方法的语义修改为去请求传输[[ruby:selected%20representation%20data][已选表示形式数据]]的仅仅一个或多个子范围，而不是整个已选表示形式数据。

#+BEGIN_SRC text
  Range = byte-ranges-specifier / other-ranges-specifier
  other-ranges-specifier = other-range-unit "=" other-range-set
  other-range-set = 1*VCHAR
#+END_SRC

#+BEGIN_QUOTE
A server *MAY* ignore the =Range= header field. However, origin servers and intermediate caches ought to support byte ranges when possible, since =Range= supports efficient recovery from partially failed transfers and partial retrieval of large representations. A server *MUST* ignore a =Range= header field received with a request method other than GET.
#+END_QUOTE

服务器 *可以* 忽略 =Range= 头字段。但是，源服务器和中间人缓存服务器应该尽可能去支持[[ruby:byte%20ranges][字节范围]]，因为 =Range= 支持从传输一部分数据后（因某种原因导致）传输失败了的场景中高效地恢复过来，还支持获取一个大的表示形式中的一部分。如果所接收到的请求方法不是 GET，那么，服务器 *必须* 忽略这个消息中的 =Range= 头字段。

#+BEGIN_QUOTE
An origin server *MUST* ignore a =Range= header field that contains a range unit it does not understand. A proxy *MAY* discard a =Range= header field that contains a range unit it does not understand.
#+END_QUOTE

如果 =Range= 头字段包含了源服务器所不能理解的[[ruby:range%20unit][范围单位]]，那么，源服务器 *必须* 忽略这个头字段。如果 =Range= 头字段包含了代理所不能理解的范围单位，代理 *可以* 丢弃掉这个头字段。

#+BEGIN_QUOTE
A server that supports range requests *MAY* ignore or reject a =Range= header field that consists of more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since both are indications of either a broken client or a deliberate denial-of-service attack ([[id:f9a13f54-ed44-4a7f-b1ef-1e912979e5cd][Section 6.1]]). A client *SHOULD NOT* request multiple ranges that are inherently less efficient to process and transfer than a single range that encompasses the same data.
#+END_QUOTE

如果 =Range= 头字段由不止两个的重叠范围组成，或者由许多不是以升序排列的小范围组成，那么，支持范围请求的服务器 *可以* 忽略或者拒绝这个头字段。因为之所以出现这两种组成方式，要不就是客户端的实现有问题，要不就是出现了刻意的[[ruby:denial-of-service%20attack][拒绝服务攻击]]（[[id:f9a13f54-ed44-4a7f-b1ef-1e912979e5cd][章节 6.1]]）。如果划分为多个小范围进行处理和传输本质上比包含同样数据的单个大范围的效率要差的话，客户端 *不应当* 请求多个范围。

#+BEGIN_QUOTE
A client that is requesting multiple ranges *SHOULD* list those ranges in ascending order (the order in which they would typically be received in a complete representation) unless there is a specific need to request a later part earlier. For example, a user agent processing a large representation with an internal catalog of parts might need to request later parts first, particularly if the representation consists of pages stored in reverse order and the user agent wishes to transfer one page at a time.
#+END_QUOTE

客户端在请求多个范围时，*应当* 将这些范围按升序排序（按它们通常被接收成为一个完整的表示形式的顺序），除非它明确需要更早地请求一个更后的部分。例如，用户代理正在处理一个非常大的表示形式，这个表示形式带有一个自身组成部分的内部目录可能需要先请求更后的部分的情况，特别是如果这个表示形式由多页组成，以页码倒序的方式保存，并且用户代理希望一次一页地传输。

#+BEGIN_QUOTE
The =Range= header field is evaluated after evaluating the precondition header fields defined in [[[file:RFC7232.org][RFC7232]]], and only if the result in absence of the =Range= header field would be a =200 (OK)= response. In other words, =Range= is ignored when a conditional GET would result in a =304 (Not Modified)= response.

在[[ruby:precondition%20header%20fields][前提条件头字段]]（定义在【[[file:RFC7232.org][RFC7232]]】）求值以后，并且假如没有 =Range= 头字段的话这次请求的最终结果将会是一个 =200 (OK)= 响应，那么，=Range= 头字段才会被求值。换句话说，当一个条件 GET 请求的结果是一个 =304 (Not Modified)= 响应的时候，=Range= 会被忽略。

#+END_QUOTE

#+BEGIN_QUOTE
The =If-Range= header field ([[id:2859ef1f-8309-4b7d-9e22-963391b5822a][Section 3.2]]) can be used as a precondition to applying the =Range= header field.
#+END_QUOTE

=If-Range= 头字段（[[id:2859ef1f-8309-4b7d-9e22-963391b5822a][章节 3.2]]）能够被用作应用 =Range= 头字段的一个前提条件。

#+BEGIN_QUOTE
译注：也就是说，当 =If-Range= 的求值结果为真（即条件成立）的时候，才会对 =Range= 进行求值。
#+END_QUOTE

#+BEGIN_QUOTE
If all of the preconditions are true, the server supports the =Range= header field for the target resource, and the specified range(s) are valid and satisfiable (as defined in [[id:67c9bce9-6c76-46ec-9932-1b5dde9f7746][Section 2.1]]), the server *SHOULD* send a =206 (Partial Content)= response with a payload containing one or more partial representations that correspond to the satisfiable ranges requested, as defined in [[id:028da72d-1e54-4bee-ac56-3d63169c6c3f][Section 4]].
#+END_QUOTE

如果所有前提条件皆为真，且服务器支持对目标资源应用 =Range= 头字段，且所指定的范围皆为有效的和[[ruby:satisfiable][可满足的]]（其定义见[[id:67c9bce9-6c76-46ec-9932-1b5dde9f7746][章节 2.1]]），那么，服务器 *应当* 发送一个 =206 (Partial Content)= 响应，带有一个有效载荷来包含一个表示形式的一个或多个部分，这些部分对应于客户端所请求的[[ruby:satisfiable%20ranges][可满足的范围]]，其定义见[[id:028da72d-1e54-4bee-ac56-3d63169c6c3f][章节 4]]。

#+BEGIN_QUOTE
If all of the preconditions are true, the server supports the =Range= header field for the target resource, and the specified range(s) are invalid or unsatisfiable, the server *SHOULD* send a =416 (Range Not Satisfiable)= response.
#+END_QUOTE

如果所有前提条件皆为真，且服务器支持对目标资源应用 =Range= 头字段，但所指定的范围无效或不可满足的，那么，服务器 *应当* 发送一个 =416 (Range Not Satisfiable)= 响应。

** 3.2. If-Range
:PROPERTIES:
:ID:       2859ef1f-8309-4b7d-9e22-963391b5822a
:END:

#+BEGIN_QUOTE
If a client has a partial copy of a representation and wishes to have an up-to-date copy of the entire representation, it could use the =Range= header field with a conditional GET (using either or both of =If-Unmodified-Since= and =If-Match=.) However, if the precondition fails because the representation has been modified, the client would then have to make a second request to obtain the entire current representation.
#+END_QUOTE

如果客户端已有一个表示形式的[[ruby:partial%20copy][一部分副本]]，它希望获得整个表示形式的一份最新副本，那么，它可以使用在一个条件 GET 请求中带有 =Range= 头字段（使用 =If-Unmodified-Since= 和 =If-Match= 两者或两者之一）。但是，如果因表示形式已经被修改而导致前提条件不成立的话，客户端将不得不发起第二次请求来获得整个当前表示形式。

#+BEGIN_QUOTE
The "If-Range" header field allows a client to "short-circuit" the second request. Informally, its meaning is as follows: if the representation is unchanged, send me the part(s) that I am requesting in =Range=; otherwise, send me the entire representation.
#+END_QUOTE

=If-Range= 头字段让客户端可以“[[ruby:short-circuit][短路]]”第二次请求。通俗地说，它的含义如下：如果表示形式未发生变化，把我在 =Range= 所请求的范围的那部分发送给我；否则，把整个表示形式发送给我。

#+BEGIN_QUOTE
译注：编程语言中的逻辑表达式 and 和 or 通常都带有“短路”功能。
#+END_QUOTE

#+BEGIN_SRC text
  If-Range = entity-tag / HTTP-date
#+END_SRC

#+BEGIN_QUOTE
A client *MUST NOT* generate an =If-Range= header field in a request that does not contain a =Range= header field. A server *MUST* ignore an =If-Range= header field received in a request that does not contain a =Range= header field. An origin server *MUST* ignore an =If-Range= header field received in a request for a target resource that does not support =Range= requests.
#+END_QUOTE

如果一个请求中不包含有 =Range= 头字段，那么，客户端 *禁止* 在这个请求中生成 =If-Range= 头字段。如果服务器所接收到的请求中不包含有 =Range= 头字段，那么，服务器 *必须* 忽略这个请求中的 =If-Range= 头字段。如果源服务器所接收到的请求所指的目标资源并不支持 =Range= 范围请求，那么，源服务器 *必须* 忽略这个请求中的 =If-Range= 头字段。

#+BEGIN_QUOTE
A client *MUST NOT* generate an =If-Range= header field containing an entity-tag that is marked as weak. A client *MUST NOT* generate an =If-Range= header field containing an =HTTP-date= unless the client has no entity-tag for the corresponding representation and the date is a strong validator in the sense defined by [[id:ba954c8f-272f-409a-9fdd-e092207700c5][Section 2.2.2]] of [RFC7232].
#+END_QUOTE

客户端 *禁止* 生成这样一种 =If-Range= 头字段，其值是一个标记为弱验证类型的实体标签。客户端 *禁止* 生成这样一种 =If-Range= 头字段，其值是一个 =HTTP-date=，除非这个客户端的表示形式没有对应的实体标签，并且这个日期是一种[[id:ba954c8f-272f-409a-9fdd-e092207700c5][【RFC7232】章节 2.2.2]] 所说的强验证类型。

#+BEGIN_QUOTE
A server that evaluates an =If-Range= precondition *MUST* use the strong comparison function when comparing entity-tags ([[id:e3a6dda6-2209-44aa-89af-c37f1b95c2fe][Section 2.3.2]] of [RFC7232]) and *MUST* evaluate the condition as false if an =HTTP-date= validator is provided that is not a strong validator in the sense defined by [[id:ba954c8f-272f-409a-9fdd-e092207700c5][Section 2.2.2]] of [RFC7232]. A valid entity-tag can be distinguished from a valid =HTTP-date= by examining the first two characters for a =DQUOTE=.
#+END_QUOTE

服务器对一个 =If-Range= 前提条件进行求值的时候，如果它的值是一个实体标签的话，那么，服务器 *必须* 使用强对比方法（[[id:e3a6dda6-2209-44aa-89af-c37f1b95c2fe][【RFC7232】章节 2.3.2]]）；另外，如果它的值是一个 =HTTP-date= 验证器，但不是一种[[id:ba954c8f-272f-409a-9fdd-e092207700c5][【RFC7232】章节 2.2.2]] 所说的强验证类型，那么，服务器 *必须* 将这个条件求值为假。一个有效的（强验证类型的）实体标签可以通过检测前两个字符是否有一个双引号 =DQUOTE= 来区分一个有效的 HTTP-date。

#+BEGIN_QUOTE
译注：
强实体标签第一个字符必定为双引号，如： "xyzzy"，弱实体标签的开头带有一个 =W\=，如：W\"zyzzy"。详细的 ABNF 见章[[id:0244a602-2c4a-46aa-96c4-3bd14c3eb244][【RFC7232】章节 2.3]]。

=HTTP-date= 并不是一个字符串，它没被双引号包裹，见[[id:2091e4af-684f-4511-aaa1-8094dc7dcb21][【RFC7231】章节 7.1.1.1]]。
#+END_QUOTE

#+BEGIN_QUOTE
If the validator given in the =If-Range= header field matches the current validator for the selected representation of the target resource, then the server *SHOULD* process the =Range= header field as requested. If the validator does not match, the server *MUST* ignore the =Range= header field. Note that this comparison by exact match, including when the validator is an =HTTP-date=, differs from the "earlier than or equal to" comparison used when evaluating an =If-Unmodified-Since= conditional.
#+END_QUOTE

如果 =If-Range= 头字段所给出的验证器匹配上了目标资源的已选表示形式的当前验证器，那么，服务器 *应当* 将 =Range= 头字段作为所要请求的范围来处理。如果验证器没有匹配，那么，服务器 *必须* 忽略 =Range= 头字段。需要注意的是，这种对比是通过精准匹配的，包括验证器是一个 =HTTP-date= 的情况，区别于对一个 =If-Unmodified-Since= 条件式进行求值时所使用的“早于或等于”对比方式。

* 4. 响应给范围请求 / Responses to a Range Request
  :PROPERTIES:
  :ID:       028da72d-1e54-4bee-ac56-3d63169c6c3f
  :END:
** 4.1. 206 部分内容 / 206 Partial Content
:PROPERTIES:
:ID:       32182a4e-00f6-44d9-82e2-f08d98b59324
:END:

#+BEGIN_QUOTE
The =206 (Partial Content)= status code indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation that correspond to the satisfiable ranges found in the request's =Range= header field ([[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][Section 3.1]]).
#+END_QUOTE

=206 (Partial Content)= 状态码表明：服务器通过传输已选表示形式的一个或多个部分，已经成功地[[ruby:fulfilling][实现]]了客户端对目标资源的一个范围请求，这些部分的表示形式对应于请求消息的 =Range= 头字段（[[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][章节 3.1]]）里的可满足的范围。

#+BEGIN_QUOTE
If a single part is being transferred, the server generating the =206= response *MUST* generate a =Content-Range= header field, describing what range of the selected representation is enclosed, and a payload consisting of the range. For example:
#+END_QUOTE

服务器在生成一个 206 响应的时候，如果即将传输的是表示形式的[[ruby:single%20part][单个部分]]（区别于[[ruby:multiple%20part][多个部分]]），那么，服务器 *必须* 生成一个 =Content-Range= 头字段来描述这个响应所封装的是已选表示形式的什么范围，以及生成这个范围所组成的一个有效载荷。例如：

#+BEGIN_EXAMPLE
  HTTP/1.1 206 Partial Content
  Date: Wed, 15 Nov 1995 06:25:24 GMT
  Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
  Content-Range: bytes 21010-47021/47022
  Content-Length: 26012
  Content-Type: image/gif

  ... 26012 bytes of partial image data ...
#+END_EXAMPLE

#+BEGIN_QUOTE
If multiple parts are being transferred, the server generating the =206= response *MUST* generate a "multipart/byteranges" payload, as defined in [[id:d0f2a428-d1ab-49fd-9ac2-531946ecac25][Appendix A]], and a =Content-Type= header field containing the multipart/byteranges media type and its required =boundary= parameter. To avoid confusion with single-part responses, a server *MUST NOT* generate a =Content-Range= header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).
#+END_QUOTE

服务器在生成一个 =206= 响应的时候，如果即将传输的是表示形式的[[ruby:multiple%20parts][多个部分]]（区别于[[ruby:single%20part][单个部分]]），那么，服务器 *必须* 生成一个 "multipart/byteranges" 类型的有效载荷（其定义见[[id:d0f2a428-d1ab-49fd-9ac2-531946ecac25][附录 A]]），以及生成一个 =Content-Type= 头字段，这个头字段包含 multipart/byteranges 媒体类型以及该媒体类型所要求的 =boundary= 参数。为了避免与[[ruby:single-part%20responses][单个部分的响应]]产生混淆，服务器 *禁止* 在[[ruby:multiple%20part][多个部分]]的 HTTP 响应头里生成 =Content-Range= 头字段（而是改为将这个字段在每一个部分内部进行发送）。

#+BEGIN_QUOTE
Within the header area of each body part in the multipart payload, the server *MUST* generate a =Content-Range= header field corresponding to the range being enclosed in that body part. If the selected representation would have had a =Content-Type= header field in a =200 (OK)= response, the server *SHOULD* generate that same =Content-Type= field in the header area of each body part. For example:
#+END_QUOTE

对于 multipart 类型的有效载荷，服务器 *必须* 在这种有效载荷中的每一个 =body-part= 的[[ruby:header%20area][头部区域]]内都生成一个 =Content-Range= 头字段，每个头字段的值表示被置入到对应的 =body-part= 的表示形式数据的范围。假设这个已选表示形式在 =200 (OK)= 响应的时候会带有一个 =Content-Type= 头字段，那么，在 =206= 响应中，服务器 *应当* 在每个 =body-part= 的头部区域中生成同样的 =Content-Type= 字段。例如：

#+BEGIN_EXAMPLE
  HTTP/1.1 206 Partial Content
  Date: Wed, 15 Nov 1995 06:25:24 GMT
  Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
  Content-Length: 1741
  Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

  --THIS_STRING_SEPARATES
  Content-Type: application/pdf
  Content-Range: bytes 500-999/8000

  ...the first range...
  --THIS_STRING_SEPARATES
  Content-Type: application/pdf
  Content-Range: bytes 7000-7999/8000

  ...the second range
  --THIS_STRING_SEPARATES--
#+END_EXAMPLE

#+BEGIN_QUOTE
When multiple ranges are requested, a server *MAY* coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding =byte-range-spec= appeared in the received =Range= header field. Since the typical overhead between parts of a multipart/byteranges payload is around 80 bytes, depending on the selected representation's media type and the chosen =boundary= parameter length, it can be less efficient to transfer many small disjoint parts than it is to transfer the entire selected representation.
#+END_QUOTE

当服务器被请求[[ruby:multiple%20ranges][多个范围]]，无论这些范围所对应的 =byte-range-spec= 按什么顺序出现在服务器接收到的 =Range= 头字段里，服务器都 *可以* 将这些范围的重叠部分合并起来，或者将以一个小间隙分隔的范围合并起来——如果这个间隙小于发送多个部分的[[ruby:overhead][开销]]的话。因为一个 multipart/byteranges 类型的有效载荷的各个部分之间的一般开销是 80 [[ruby:bytes][字节]]，根据已选表示形式的媒体类型以及所选择的 =boundary= 参数的长度，传输许多小的分离部分的效率可能会低于传输整个已选表示形式。

#+BEGIN_QUOTE
overhead，在计算机网络的帧结构中，除了有用数据以外，还有很多控制信息，这些控制信息用来保证通信的完成。这些控制信息被称作系统开销。
——百度百科
#+END_QUOTE

#+BEGIN_QUOTE
A server *MUST NOT* generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server *MAY* generate a multipart/byteranges payload with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a multipart/byteranges response *MUST NOT* generate a request that asks for multiple ranges.
#+END_QUOTE

当客户端请求一个[[ruby:single%20range][单个范围]]的时候，服务器 *禁止* 生成一个[[ruby:multipart%20response][多个部分的响应]]来回应，这是因为客户端之所以不请求多个部分，可能是由于它不支持多个部分的响应。但是，如果所请求的是多个范围，并且最后发现只有一个范围可被满足，或者经合并后只剩下一个范围，那么，服务器 *可以* 生成一个 multipart/byteranges 有效载荷，其仅带有单个 =body-part=。不能处理 multipart/byteranges 响应的客户端 *禁止* 生成一个[[ruby:asks%20for][请求]]多个范围的请求消息。

#+BEGIN_QUOTE
When a multipart response payload is generated, the server *SHOULD* send the parts in the same order that the corresponding =byte-range-spec= appeared in the received =Range= header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges. A client that receives a multipart response *MUST* inspect the =Content-Range= header field present in each body part in order to determine which range is contained in that body part; a client cannot rely on receiving the same ranges that it requested, nor the same order that it requested.
#+END_QUOTE

当服务器生成了一个[[ruby:multipart%20response%20payload][多个部分的响应有效载荷]]的时候，服务器 *应当* 按照它所接收到的 =Range= 头字段里的 =byte-range-spec= 的出现顺序（排除掉它认为是不可满足的或合并成其他范围的那些范围）来发送这些部分。客户端在接收到一个多个部分的响应时，*必须* 检查出现在每一个 =body-part= 里的 =Content-Range= 头字段，为了确定哪一个范围是包含在那个主体部分里的。客户端不能完全相信可以接收到与它所请求相一致的范围，或者与它所请求相一致的顺序。

#+BEGIN_QUOTE
When a =206= response is generated, the server *MUST* generate the following header fields, in addition to those required above, if the field would have been sent in a =200 (OK)= response to the same request: =Date=, =Cache-Control=, =ETag=, =Expires=, =Content-Location=, and =Vary=.
#+END_QUOTE

服务器生成一个 =206= 响应的时候，服务器除了需要生成上述所要求的头字段以外，假如生成的是一个 =200 (OK)= 响应到同一个请求，如果这个 =200= 响应包含下列头字段，那么，服务器 *必须* 将这些头字段同样生成到 =206= 响应里，包括：=Date=、=Cache-Control=、=ETag=、=Expires=、=Content-Location=、以及 =Vary=。

#+BEGIN_QUOTE
If a =206= is generated in response to a request with an =If-Range= header field, the sender *SHOULD NOT* generate other representation header fields beyond those required above, because the client is understood to already have a prior response containing those header fields. Otherwise, the sender *MUST* generate all of the representation header fields that would have been sent in a =200 (OK)= response to the same request.
#+END_QUOTE

如果一个请求带有一个 =If-Range= 头字段，那么，发送端在生成一个 =206= 来回应这个请求的时候，*不应当* 生成上述所要求的头字段以外的其他的表示形式头字段，因为客户端被认为是已经有一个之前的响应包含那些头字段了。否则，发送端 *必须* 像生成一个 =200 (OK)= 响应给同一个请求时所带有的所有表示形式头字段生成到这个 =206= 响应里。

#+BEGIN_QUOTE
A =206= response is cacheable by default; i.e., unless otherwise indicated by explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=206= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非由显式带有的[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）另有指定。

** 4.2. Content-Range
:PROPERTIES:
:ID:       7a682301-f05e-4e79-8242-398bbfb57c74
:END:

#+BEGIN_QUOTE
The "Content-Range" header field is sent in a single part =206 (Partial Content)= response to indicate the partial range of the selected representation enclosed as the message payload, sent in each part of a multipart =206= response to indicate the range enclosed within each body part, and sent in =416 (Range Not Satisfiable)= responses to provide information about the selected representation.
#+END_QUOTE

如果 =Content-Range= 头字段发送在一种[[ruby:single%20part][单个部分]]的 =206 (Partial Content)= 响应里，那么它表明一个范围，这个范围是指封装为消息有效载荷的已选表示形式的[[ruby:partial%20range][局部范围]]。如果它发送在一种[[ruby:multipart][多个部分]]的 =206= 响应里的每一个 =body-part= 中，那么它表示一个范围，这个范围是指封装在每个 =body-part= 中的表示形式的范围。如果它发送在 =416 (Range Not Staisfiable)= 响应中，它提供了已选表示形式的相关信息。

#+BEGIN_QUOTE
译注：下文会多次提及 =body-part= 这个概念，可在[[https://tools.ietf.org/html/rfc2046#section-5.1][【RFC2046】章节 5]] 找到更详细的信息。
#+END_QUOTE

#+BEGIN_SRC text
  Content-Range       = byte-content-range
                      / other-content-range
                          
  byte-content-range  = bytes-unit SP
                        ( byte-range-resp / unsatisfied-range )

  byte-range-resp     = byte-range "/" ( complete-length / "*" )
  byte-range          = first-byte-pos "-" last-byte-pos
  unsatisfied-range   = "*/" complete-length
                          
  complete-length     = 1*DIGIT
  
  other-content-range = other-range-unit SP other-range-resp
  other-range-resp    = *CHAR
#+END_SRC

#+BEGIN_QUOTE
If a =206 (Partial Content)= response contains a =Content-Range= header field with a range unit ([[id:6d7d656a-9741-4193-abd3-60f2f2b3a11a][Section 2]]) that the recipient does not understand, the recipient *MUST NOT* attempt to recombine it with a stored representation. A proxy that receives such a message *SHOULD* forward it downstream.
#+END_QUOTE

如果一个 =206 (Partial Content)= 响应包含有一个 =Content-Range= 头字段，这个头字段使用了一种接收端无法理解的[[ruby:range%20unit][范围单位]]（[[id:6d7d656a-9741-4193-abd3-60f2f2b3a11a][章节 2]]），那么，接收端 *禁止* 试图去使用一个已存储的表示形式来[[ruby:recombine][重组]]它。代理在接收到这种消息时 *应当* 将它转发给下游。

#+BEGIN_QUOTE
For byte ranges, a sender *SHOULD* indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine. An asterisk character ("*") in place of the complete-length indicates that the representation length was unknown when the header field was generated.
#+END_QUOTE

对于[[ruby:byte%20ranges][字节范围]]，发送端 *应当* 指明表示形式的[[ruby:complete%20length][完整长度]]，除非完整长度是未知的或者是难以确定的，所述表示形式指的是提取出这个字节范围的那一个表示形式。使用一个星号字符（"*"）来代替 =complete-length=，表明：当头字段生成的时候，表示形式的长度还是未知的。

#+BEGIN_QUOTE
The following example illustrates when the complete length of the selected representation is known by the sender to be 1234 bytes:
#+END_QUOTE

以下示例说明了当发送端知道已选表示形式的完整长度是 1234 个字节的时候：

#+BEGIN_EXAMPLE
  Content-Range: bytes 42-1233/1234
#+END_EXAMPLE

#+BEGIN_QUOTE
and this second example illustrates when the complete length is unknown:
#+END_QUOTE

第二个示例说明当完整长度是未知的时候：

#+BEGIN_EXAMPLE
  Content-Range: bytes 42-1233/*
#+END_EXAMPLE

#+BEGIN_QUOTE
A =Content-Range= field value is invalid if it contains a =byte-range-resp= that has a =last-byte-pos= value less than its =first-byte-pos= value, or a =complete-length= value less than or equal to its =last-byte-pos= value. The recipient of an invalid =Content-Range= *MUST NOT* attempt to recombine the received content with a stored representation.
#+END_QUOTE

如果 =Content-Range= 的值包含有带有 =last-byte-pos= 值的一个 =byte-range-resp= 符合下列情况之一，那么，这个 =Content-Range= 的值就是无效的：

- =last-byte-pos= 的值小于 =first-byte-pos= 的值。
- =complete-length= 的值小于或等于 =last-byte-pos= 的值。

接收端在接收到一个无效的 =Content-Range= 头字段的时候，*禁止* 试图使用一个已存储的表示形式去重组所接收到的内容。

#+BEGIN_QUOTE
A server generating a =416 (Range Not Satisfiable)= response to a byte-range request *SHOULD* send a =Content-Range= header field with an unsatisfied-range value, as in the following example:
#+END_QUOTE

服务器在生成一个 =416 (Range Not Satisfiable)= 响应来回应给一个[[ruby:byte-range%20request][字节范围请求]]的时候，*应当* 发送一个 =Content-Range= 头字段，它的值表示一个[[ruby:unsatisfied-range][不可满足的范围]]，见以下示例：

#+BEGIN_EXAMPLE
  Content-Range: bytes */1234
#+END_EXAMPLE

#+BEGIN_QUOTE
The =complete-length= in a =416= response indicates the current length of the selected representation.
#+END_QUOTE

=416= 响应里的 =complete-length= 表明已选表示形式的当前长度。

#+BEGIN_QUOTE
The =Content-Range= header field has no meaning for status codes that do not explicitly describe its semantic. For this specification, only the =206 (Partial Content)= and =416 (Range Not Satisfiable)= status codes describe a meaning for =Content-Range=.
#+END_QUOTE

=Content-Range= 使用在没有明确描述它的语义的那些状态码里是没有任何意义的。对于本规范，只有 =206 (Partial Content)= 和 =416 (Range Not Satisfiable)= 有描述过 =Content-Range= 的意义。

#+BEGIN_QUOTE
The following are examples of =Content-Range= values in which the selected representation contains a total of 1234 bytes:
#+END_QUOTE

以下是一个总大小为 1234 字节的已选表示形式中的 =Content-Range= 值的示例：

- The first 500 bytes:
  
  第一组 500 个字节：
  
  #+BEGIN_EXAMPLE
    Content-Range: bytes 0-499/1234
  #+END_EXAMPLE

- The second 500 bytes:

  第二组 500 个字节：
  
  #+BEGIN_EXAMPLE
    Content-Range: bytes 500-999/1234
  #+END_EXAMPLE

- All except for the first 500 bytes:

  所有字节，除了第一组 500 个字节以外：

  #+BEGIN_EXAMPLE
    Content-Range: bytes 500-1233/1234
  #+END_EXAMPLE
  
- The last 500 bytes:

  最后一组 500 个字节：

  #+BEGIN_EXAMPLE
    Content-Range: bytes 734-1233/1234
  #+END_EXAMPLE

** 4.3. 重组范围 / Combining Ranges

#+BEGIN_QUOTE
A response might transfer only a subrange of a representation if the connection closed prematurely or if the request used one or more =Range= specifications. After several such transfers, a client might have received several ranges of the same representation. These ranges can only be safely combined if they all have in common the same strong validator ([[id:d232decc-3720-4edf-bbfa-df942f60aa50][Section 2.1]] of [RFC7232]).
#+END_QUOTE

如果连接被过早地关闭了，或者请求使用了一个或多个 =Range= 规格，那么，一个响应可能只对一个表示形式的一个[[ruby:subrange][子范围]]进行传输。历经多次这样的传输以后，客户端可能已接收到同一个表示形式的许多范围。这些范围只有在它们都具有同一个[[ruby:strong%20validator][强验证器]]（[[id:d232decc-3720-4edf-bbfa-df942f60aa50][【RFC7232】章节 2.1]]）的时候才能够被安全地[[ruby:combined][重组]]起来。

#+BEGIN_QUOTE
A client that has received multiple partial responses to GET requests on a target resource *MAY* combine those responses into a larger continuous range if they share the same strong validator.
#+END_QUOTE

在向一个目标资源发起多次 GET 请求后，客户端接收到多个[[ruby:partial%20responses][部分响应]]，那么，客户端 *可以* 将这些响应重组为一个大的连续的范围，如果它们共享同一个强验证器的话。

#+BEGIN_QUOTE
If the most recent response is an incomplete =200 (OK)= response, then the header fields of that response are used for any combined response and replace those of the matching stored responses.
#+END_QUOTE

如果最近一次响应是一个不完整的 =200 (OK)= 响应，那么，这个响应的头字段会被用作任何重组后的响应，并替换掉与已存储的响应相匹配的那些头字段。

#+BEGIN_QUOTE
If the most recent response is a =206 (Partial Content)= response and at least one of the matching stored responses is a =200 (OK)=, then the combined response header fields consist of the most recent =200= response's header fields. If all of the matching stored responses are =206= responses, then the stored response with the most recent header fields is used as the source of header fields for the combined response, except that the client *MUST* use other header fields provided in the new response, aside from =Content-Range=, to replace all instances of the corresponding header fields in the stored response.
#+END_QUOTE

如果最近一次响应是一个 =206 (Partial Content)= 响应，并且与之匹配的已存储的响应中至少有一个的状态码是 =200 (OK)=，那么，重组后的响应的头字段由最后一次 =200= 响应的那些头字段组成。如果与之匹配的所有已存储的响应都是 =206= 响应，那么，已存储的响应中，以具有最新的头字段的那个响应来作为重组后的响应的头字段的来源，除了以下情况的头字段以外：客户端 *必须* 使用提供自新响应的（除了 =Content-Range= 以外还有）其他的头字段来替换有已存储的响应中所有对应的头字段的实际值。

#+BEGIN_QUOTE
The combined response message body consists of the union of partial content ranges in the new response and each of the selected responses. If the union consists of the entire range of the representation, then the client *MUST* process the combined response as if it were a complete =200 (OK)= response, including a =Content-Length= header field that reflects the complete length. Otherwise, the client *MUST* process the set of continuous ranges as one of the following: an incomplete =200 (OK)= response if the combined response is a prefix of the representation, a single =206 (Partial Content)= response containing a multipart/byteranges body, or multiple =206 (Partial Content)= responses, each with one continuous range that is indicated by a =Content-Range= header field.
#+END_QUOTE

重组后的响应消息体由新响应内的部分内容范围以及选定的响应的每个部分联合组成。如果这个联合是由表示形式的完整范围组成，那么，客户端 *必须* 像处理一个完整的 =200 (OK)= 响应一样来处理这个重组后的响应，包括使用一个 =Content-Length= 头字段来反映完整的长度。否则，客户端 *必须* 按以下的方式之一来处理连续的范围：

- 一个不完整的 =200 (OK)= 响应，如果重组后的响应是表示形式的开头部分
- 一个单个的 =206 (Partial Content)= 响应，包含一个 multipart/byteranges 主体部分
- 多个 =206 (Partial Content)= 响应，其中每个都是一个连续的范围并且都由一个 =Content-Range= 头字段来指明。

** 4.4. 416 范围无法满足 / 416 Range Not Satisfiable
:PROPERTIES:
:ID:       a2f29dcf-8c15-4b15-ab66-742f476d27f3
:END:

#+BEGIN_QUOTE
The =416 (Range Not Satisfiable)= status code indicates that none of the ranges in the request's =Range= header field (Section 3.1) overlap the current extent of the selected resource or that the set of ranges requested has been rejected due to invalid ranges or an excessive request of small or overlapping ranges.
#+END_QUOTE

=416 (Range Not Satisfiable)= 状态码表明：请求的 =Range= 头字段中没有一个范围与已选资源的当前范围有[[ruby:overlap][重合]]，或者所请求的范围集由于范围无效或者请求了太多小的或重合的范围已被拒绝。

#+BEGIN_QUOTE
For byte ranges, failing to overlap the current extent means that the =first-byte-pos= of all of the =byte-range-spec= values were greater than the current length of the selected representation. When this status code is generated in response to a byte-range request, the sender *SHOULD* generate a =Content-Range= header field specifying the current length of the selected representation ([[id:7a682301-f05e-4e79-8242-398bbfb57c74][Section 4.2]]).
#+END_QUOTE

对于[[ruby:byte%20ranges][字节范围]]，与当前范围没有重合的意思是所有 =byte-range-spec= 的值里的 =first-byte-pos= 都大于已选表示形式的当前长度。当生成这个状态码来回应一个[[ruby:byte-range%20request][字节范围请求]]的时候，发送端 *应当* 生成一个 =Content-Range= 头字段来指定已选表示形式的当前长度（[[id:7a682301-f05e-4e79-8242-398bbfb57c74][章节 4.2]]）。

#+BEGIN_QUOTE
For example:
#+END_QUOTE

例如：

#+BEGIN_EXAMPLE
  HTTP/1.1 416 Range Not Satisfiable
  Date: Fri, 20 Jan 2012 15:41:54 GMT
  Content-Range: bytes */47022
#+END_EXAMPLE

#+BEGIN_QUOTE
*Note:* Because servers are free to ignore =Range=, many implementations will simply respond with the entire selected representation in a =200 (OK)= response. That is partly because most clients are prepared to receive a =200 (OK)= to complete the task (albeit less efficiently) and partly because clients might not stop making an invalid partial request until they have received a complete representation. Thus, clients cannot depend on receiving a =416 (Range Not Satisfiable)= response even when it is most appropriate.
#+END_QUOTE

*注意：* 因为服务器可以自由忽略 =Range=，许多实现会简单地使用一个 =200 (OK)= 包含整个已选表示形式来响应这种请求。有部分原因是因为大多数客户端都准备使用一个 =200 (OK)= 来完成请求任务（即使不那么高效），以及有部分原因是因为客户端可能不会停止发送一个无效的[[ruby:partial%20request][部分请求]]直到它们已经接收到一个完整的表示形式。所以，客户端不能完全相信一个 =416 (Range Not Satisfiable)= 响应，即使这种响应是最合适的。

* 5. IANA 注意事项 / IANA Considerations
** 5.1. 范围单位登记表 / Range Unit Registry
:PROPERTIES:
:ID:       c7bd6955-92e0-4665-a775-766ad3133ac0
:END:

#+BEGIN_QUOTE
The "HTTP Range Unit Registry" defines the namespace for the range unit names and refers to their corresponding specifications. The registry has been created and is now maintained at <http://www.iana.org/assignments/http-parameters>.
#+END_QUOTE

《HTTP 范围单位登记表》为范围单位定义了命名空间，并引用到它们对应的规范上。这份登记表已经被创建，目前维护在 <http://www.iana.org/assignments/http-parameters>。

*** 5.1.1. 手续 / Procedure

#+BEGIN_QUOTE
Registration of an HTTP Range Unit *MUST* include the following fields:

- Name
- Description
- Pointer to specification text
#+END_QUOTE

一个 HTTP 范围单位的登记 *必须* 包括以下字段：

- 名称
- 描述
- 指向到规范文本的引用

#+BEGIN_QUOTE
Values to be added to this namespace require IETF Review (see [RFC5226], [[https://tools.ietf.org/html/rfc5226#section-4.1][Section 4.1]]).
#+END_QUOTE

添加到 HTTP 状态码命名空间的值要求由 IETF 复审（见[[https://tools.ietf.org/html/rfc5226#section-4.1][【RFC5226】章节 4.1]]）。

*** 5.1.2. 登记 / Registrations

#+BEGIN_QUOTE
The initial range unit registry contains the registrations below:
#+END_QUOTE

初始的《范围单位登记表》包含以下登记项：

| Range Unit Name | Description                                             | Reference   |
|-----------------+---------------------------------------------------------+-------------|
| bytes           | a range of octets                                       | [[id:67c9bce9-6c76-46ec-9932-1b5dde9f7746][Section 2.1]] |
| none            | reserved as keyword, indicating no ranges are supported | [[id:cf601084-e3af-41bc-9ff7-8f903ca59fa8][Section 2.3]] |

#+BEGIN_QUOTE
The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
#+END_QUOTE

主管以上条目的变更的是 "IETF (iesg@ietf.org) - Internet Engineering Task Force"。

** 5.2. 状态码登记 / Status Code Registration

#+BEGIN_QUOTE
The "Hypertext Transfer Protocol (HTTP) Status Code Registry" located at <http://www.iana.org/assignments/http-status-codes> has been updated to include the registrations below:
#+END_QUOTE

《超文本传输协议（HTTP）状态码登记表》位于 <http://www.iana.org/assignments/http-status-codes>，已经更新了以下登记项。

| Value | Description           | Reference   |
|-------+-----------------------+-------------|
|   206 | Partial Control       | [[id:32182a4e-00f6-44d9-82e2-f08d98b59324][Section 4.1]] |
|   416 | Range Not Satisfiable | [[id:a2f29dcf-8c15-4b15-ab66-742f476d27f3][Section 4.4]] |

** 5.3. 头字段登记  / Header Field Registration

#+BEGIN_QUOTE
HTTP header fields are registered within the "Message Headers" registry maintained at <http://www.iana.org/assignments/message-headers/>.
#+END_QUOTE

HTTP 头字段被登记在《消息头部》登记表中，并维护在 <http://www.iana.org/assignments/message-headers/>。

#+BEGIN_QUOTE
This document defines the following HTTP header fields, so their associated registry entries have been updated according to the permanent registrations below (see [[[https://tools.ietf.org/html/rfc3864][BCP90]]]):
#+END_QUOTE

本文档定义了以下 HTTP 头字段，因此它们相关联的登记项已经根据以下永久登记条目进行更新（见【[[https://tools.ietf.org/html/rfc3864][BCP90]]】）：

| Header Field name | Protocol | Status   | Reference   |
|-------------------+----------+----------+-------------|
| Accept-Ranges     | http     | standard | [[id:cf601084-e3af-41bc-9ff7-8f903ca59fa8][Section 2.3]] |
| Content-Range     | http     | standard | [[id:7a682301-f05e-4e79-8242-398bbfb57c74][Section 4.2]] |
| If-Range          | http     | standard | [[id:2859ef1f-8309-4b7d-9e22-963391b5822a][Section 3.2]] |
| Range             | http     | standard | [[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][Section 3.1]] |

#+BEGIN_QUOTE
The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
#+END_QUOTE

主管以上条目的变更的是 "IETF (iesg@ietf.org) - Internet Engineering Task Force"。

** 5.4. 互联网媒体类型登记 / Internet Media Type Registration

#+BEGIN_QUOTE
IANA maintains the registry of Internet media types [[[https://tools.ietf.org/html/rfc6838][BCP13]]] at <http://www.iana.org/assignments/media-types>.
#+END_QUOTE

IANA 将互联网媒体类型的登记表【[[https://tools.ietf.org/html/rfc6838][BCP13]]】维护在 <http://www.iana.org/assignments/media-types>。

#+BEGIN_QUOTE
This document serves as the specification for the Internet media type "multipart/byteranges". The following has been registered with IANA.
#+END_QUOTE

本文档充当 "multipart/byteranges" 互联网媒体类型的规范。以下信息已经在 IANA 进行过登记。

*** 5.4.1. Internet Media Type multipart/byteranges

#+BEGIN_EXAMPLE
  Type name: multipart
  Subtype name: byteranges
  Required parameters: boundary
  Optional parameters: N/A
  Encoding considerations: only "7bit", "8bit", or "binary" are permitted
  Security considerations: see Section 6
  Interoperability considerations: N/A
  Published specification: This specification (see Appendix A).
  Applications that use this media type: HTTP components supporting multiple ranges in a single request.
  Fragment identifier considerations: N/A
  Additional information: 
    Deprecated alias names for this type: N/A
    Magic number(s): N/A
    File extension(s): N/A
    Macintosh file type code(s): N/A
  Person and email address to contact for further information: See Authors' Addresses section.
  Intended usage: COMMON
  Restrictions on usage: N/A
  Author: See Authors' Addresses section.
  Change controller: IESG
#+END_EXAMPLE
* 6. 安全注意事项 / Security Considerations
:PROPERTIES:
:ID:       10894c92-80fd-43f6-b8b7-652df6045f37
:END:

#+BEGIN_QUOTE
This section is meant to inform developers, information providers, and users of known security concerns specific to the HTTP range request mechanisms. More general security considerations are addressed in HTTP messaging [[[file:RFC7230.org][RFC7230]]] and semantics [[[file:RFC7231.org][RFC7231]]].
#+END_QUOTE

本章节是为了告诉开发者、信息提供商、以及用户，针对 HTTP 范围请求机制的已知的安全注意事项。《消息句法和路由》【[[file:RFC7230.org][RFC7230]]】以及《语义和内容》【[[file:RFC7231.org][RFC7231]]】有更广泛的安全注意事项。

** 6.1. 使用范围进行拒绝服务攻击 / Denial-of-Service Attacks Using Range
:PROPERTIES:
:ID:       f9a13f54-ed44-4a7f-b1ef-1e912979e5cd
:END:

#+BEGIN_QUOTE
Unconstrained multiple range requests are susceptible to denial-of-service attacks because the effort required to request many overlapping ranges of the same data is tiny compared to the time, memory, and bandwidth consumed by attempting to serve the requested data in many parts. Servers ought to ignore, coalesce, or reject egregious range requests, such as requests for more than two overlapping ranges or for many small ranges in a single set, particularly when the ranges are requested out of order for no apparent reason. Multipart range requests are not designed to support random access.
#+END_QUOTE

不加约束的[[ruby:multiple%20range%20requests][多个部分的范围请求]]容易受到[[ruby:denial-of-service%20attacks][拒绝服务攻击]]的影响，这是因为请求相同数据的许多重合范围的工作量与试图提供所请求的许多部分的数据所消耗的时间、内存、以及宽带相比显得太微不足道了。服务器应该忽略、合并、或者拒绝异常的范围请求，比如请求超过两个以上的重合范围，或者在在一个范围集里面请求了许多小范围，特别是当这些范围顺序混乱又没有合理的理由的情况。[[ruby:multipart%20range%20requests][多个部分的范围请求]]不是为了支持[[ruby:random%20access][随机访问]]而设计的。

* 7. 鸣谢 / Acknowledgments

#+BEGIN_QUOTE
See [[id:ccf5090b-19c1-4f1a-a7ac-2e94a6dfa626][Section 10]] of [RFC7230].
#+END_QUOTE

见[[id:ccf5090b-19c1-4f1a-a7ac-2e94a6dfa626][【RFC7230】章节 10]]。

* 8. 参考资料 / References
** 8.1. 规范性参考资料 / Normative References

- [RFC2046] :: Freed, N. and N. Borenstein, “Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types”, RFC 2046, November 1996.
- [RFC2119] :: Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, March 1997.
- [RFC5234] :: Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, RFC 5234, January 2008.
- [RFC7230] :: Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, RFC 7230, June 2014.
- [RFC7231] :: Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”, RFC 7231, June 2014.
- [RFC7232] :: Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests”, RFC 7232, June 2014.
- [RFC7234] :: Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Caching”, RFC 7234, June 2014.

** 8.2. 信息性参考资料 / Informative References

- [BCP13] :: Freed, N., Klensin, J., and T. Hansen, “Media Type Specifications and Registration Procedures”, BCP 13, RFC 6838, January 2013.
- [BCP90] :: Klyne, G., Nottingham, M., and J. Mogul, “Registration Procedures for Message Header Fields”, BCP 90, RFC 3864, September 2004.
- [RFC2616] :: Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, RFC 2616, June 1999.
- [RFC5226] :: Narten, T. and H. Alvestrand, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, RFC 5226, May 2008.

* 附录 A：互联网媒体类型 multipart/byteranges / Appendix A. Internet Media Type multipart/byteranges
:PROPERTIES:
:ID:       d0f2a428-d1ab-49fd-9ac2-531946ecac25
:END:

#+BEGIN_QUOTE
When a =206 (Partial Content)= response message includes the content of multiple ranges, they are transmitted as body parts in a multipart message body ([RFC2046], [[https://tools.ietf.org/html/rfc2046#section-5.1][Section 5.1]]) with the media type of "multipart/byteranges".
#+END_QUOTE

当一个 =206 (Partial Content)= 响应消息包含了多个范围的内容的时候，它们会作为 multipart 类型的消息体（[[https://tools.ietf.org/html/rfc2046#section-5.1][【RFC2046】章节 5.1]]）的 =body-part= 来传输，这个消息体带有一个 "multipart/byteranges" 的媒体类型。

#+BEGIN_QUOTE
The multipart/byteranges media type includes one or more body parts, each with its own =Content-Type= and =Content-Range= fields. The required boundary parameter specifies the boundary string used to separate each body part.
#+END_QUOTE

multipart/byteranges 媒体类型包括一个或多个的 =body-part=，每个都带有自己的 =Content-Type= 和 =Content-Range= 字段。必要的 =boundary= 参数指定了用来分隔每一个 =body-part= 所使用的[[ruby:boundary%20string][边界字符串]]。

#+BEGIN_QUOTE
Implementation Notes:

1. Additional CRLFs might precede the first boundary string in the body.
2. Although [[[https://tools.ietf.org/html/rfc2046][RFC2046]]] permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly.
3. A number of clients and servers were coded to an early draft of the byteranges specification that used a media type of multipart/x-byteranges, which is almost (but not quite) compatible with this type.
#+END_QUOTE

实现注意事项：

1. 在消息体内的第一个边界字符串之前可能会有额外的换行符 =CRLF=。
2. 虽然【[[https://tools.ietf.org/html/rfc2046][RFC2046]]】允许使用引号将边界字符串[[ruby:quoted][包裹]]起来，但现有的某些实现并没有正确处理好带引号包裹的边界字符串。
3. 有大量的客户端及服务器的程序是按照字节范围规范的[[ruby:early%20draft][早期草案]]来编写的，使用了一个 multipart/x-byteranges 的媒体类型，这个媒体类型几乎（但并不完全）兼容 multipart/byteranges。

#+BEGIN_QUOTE
Despite the name, the "multipart/byteranges" media type is not limited to byte ranges. The following example uses an "exampleunit" range unit:
#+END_QUOTE

尽管 "multipart/byteranges" 的名称看起来是限定为使用字节范围，但其实并不是。以下示例使用了一个名叫 "exampleunit" 的范围单位：

#+BEGIN_EXAMPLE
  HTTP/1.1 206 Partial Content
  Date: Tue, 14 Nov 1995 06:25:24 GMT
  Last-Modified: Tue, 14 July 04:58:08 GMT
  Content-Length: 2331785
  Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

  --THIS_STRING_SEPARATES
  Content-Type: video/example
  Content-Range: exampleunit 1.2-4.3/25

  ...the first range...
  --THIS_STRING_SEPARATES
  Content-Type: video/example
  Content-Range: exampleunit 11.2-14.3/25

  ...the second range
  --THIS_STRING_SEPARATES--
#+END_EXAMPLE

* 附录 B：相对 RFC 2616 的变化 / Appendix B. Changes from RFC 2616

#+BEGIN_QUOTE
Servers are given more leeway in how they respond to a range request, in order to mitigate abuse by malicious (or just greedy) clients. ([[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][Section 3.1]])
#+END_QUOTE

对于如何响应给一个范围请求，为服务器留出了更多的回旋余地，以减少被恶意（或仅为贪婪）的客户端滥用的可能性。（[[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][章节 3.1]]）

#+BEGIN_QUOTE
A weak validator cannot be used in a =206= response. ([[id:32182a4e-00f6-44d9-82e2-f08d98b59324][Section 4.1]])
#+END_QUOTE

弱验证器不能用在 =206= 响应里。（[[id:32182a4e-00f6-44d9-82e2-f08d98b59324][章节 4.1]]）

#+BEGIN_QUOTE
The =Content-Range= header field only has meaning when the status code explicitly defines its use. ([[id:7a682301-f05e-4e79-8242-398bbfb57c74][Section 4.2]])
#+END_QUOTE

=Content-Range= 头字段仅用在那些有确切定义它的使用方式的状态码中才有意义。（[[id:7a682301-f05e-4e79-8242-398bbfb57c74][章节 4.2]]）

#+BEGIN_QUOTE
This specification introduces a Range Unit Registry. ([[id:c7bd6955-92e0-4665-a775-766ad3133ac0][Section 5.1]])
#+END_QUOTE

本规范引进了一份《范围单位登记表》。（[[id:c7bd6955-92e0-4665-a775-766ad3133ac0][章节 5.1]]）

#+BEGIN_QUOTE
multipart/byteranges can consist of a single part. ([[id:d0f2a428-d1ab-49fd-9ac2-531946ecac25][Appendix A]])
#+END_QUOTE

multipart/byteranges 能够由单个部分来组成。（[[id:d0f2a428-d1ab-49fd-9ac2-531946ecac25][附录 A]]）

* 附录 C：引进的 ABNF / Appendix C. Imported ABNF
:PROPERTIES:
:ID:       47a9d902-5e79-48a6-b335-dae2828bbde5
:END:

#+BEGIN_QUOTE
The following core rules are included by reference, as defined in [[https://tools.ietf.org/html/rfc5234#appendix-B.1][Appendix B.1]] of [RFC5234]: =ALPHA= (letters), =CR= (carriage return), =CRLF= (CR LF), =CTL= (controls), =DIGIT= (decimal 0-9), =DQUOTE= (double quote), =HEXDIG= (hexadecimal 0-9/A-F/a-f), =LF= (line feed), =OCTET= (any 8-bit sequence of data), =SP= (space), and =VCHAR= (any visible US-ASCII character).
#+END_QUOTE

本规范引用了以下定义在[[https://tools.ietf.org/html/rfc5234#appendix-B.1][【RFC5234】附录 B.1]] 中的核心规则：=ALPHA= （字母）、=CR= （回车符）、=CRLF= （回车换行符）、=CTL= （控制字符）、=DIGIT= （十进制数字 0-9）、=DQUOTE= （双引号）、=HEXDIG= （十六进制数字 0-9/A-F/a-f）、=HTAB= （水平制表符）、=LF= （换行符）、=OCTET= （八位组字节）、=SP= （空格）以及 =VCHAR= （【USASCII】可见字符）。

#+BEGIN_QUOTE
Note that all rules derived from token are to be compared case-insensitively, like =range-unit= and =acceptable-ranges=.
#+END_QUOTE

需要注意的是衍生自[[ruby:token][名称标记]]所有规则都是以不区分大小写的方式进行比较的，像 [[id:6d7d656a-9741-4193-abd3-60f2f2b3a11a][range-unit]] 和 [[id:cf601084-e3af-41bc-9ff7-8f903ca59fa8][acceptable-ranges]]。

#+BEGIN_QUOTE
The rules below are defined in [[[file:RFC7230.org][RFC7230]]]:
#+END_QUOTE

以下规则定义在【[[file:RFC7230.org][RFC7230]]】中：

#+BEGIN_SRC text
  OWS        = <OWS, see [RFC7230], Section 3.2.3>
  token      = <token, see [RFC7230], Section 3.2.6>
#+END_SRC

#+BEGIN_QUOTE
The rules below are defined in other parts:
#+END_QUOTE

以下规则定义在其他部分中：

#+BEGIN_SRC text
  HTTP-date  = <HTTP-date, see [RFC7231], Section 7.1.1.1>
  entity-tag = <entity-tag, see [RFC7232], Section 2.3>
#+END_SRC

* 附录 D：ABNF 集合 / Appendix D. Collected ABNF
:PROPERTIES:
:ID:       89bbf73a-99bb-4124-88c1-b860a26b1f77
:END:

#+BEGIN_QUOTE
In the collected ABNF below, list rules are expanded as per [[id:f8234cb5-154d-4daf-82fd-ed54ac75cf8b][Section 1.2]] of [RFC7230].
#+END_QUOTE

下列 ABNF 规则集合中，列表规则是在[[id:f8234cb5-154d-4daf-82fd-ed54ac75cf8b][【RFC7230】章节 1.2]] 所扩充的。

#+BEGIN_SRC text
  Accept-Ranges = acceptable-ranges

  Content-Range = byte-content-range / other-content-range

  HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>

  If-Range = entity-tag / HTTP-date

  OWS = <OWS, see [RFC7230], Section 3.2.3>

  Range = byte-ranges-specifier / other-ranges-specifier

  acceptable-ranges = ( *( "," OWS ) range-unit *( OWS "," [ OWS
   range-unit ] ) ) / "none"

  byte-content-range = bytes-unit SP ( byte-range-resp /
   unsatisfied-range )
  byte-range = first-byte-pos "-" last-byte-pos
  byte-range-resp = byte-range "/" ( complete-length / "*" )
  byte-range-set = *( "," OWS ) ( byte-range-spec /
   suffix-byte-range-spec ) *( OWS "," [ OWS ( byte-range-spec /
   suffix-byte-range-spec ) ] )
  byte-range-spec = first-byte-pos "-" [ last-byte-pos ]
  byte-ranges-specifier = bytes-unit "=" byte-range-set
  bytes-unit = "bytes"

  complete-length = 1*DIGIT

  entity-tag = <entity-tag, see [RFC7232], Section 2.3>

  first-byte-pos = 1*DIGIT

  last-byte-pos = 1*DIGIT

  other-content-range = other-range-unit SP other-range-resp
  other-range-resp = *CHAR
  other-range-set = 1*VCHAR
  other-range-unit = token
  other-ranges-specifier = other-range-unit "=" other-range-set

  range-unit = bytes-unit / other-range-unit

  suffix-byte-range-spec = "-" suffix-length
  suffix-length = 1*DIGIT

  token = <token, see [RFC7230], Section 3.2.6>

  unsatisfied-range = "*/" complete-length
#+END_SRC

* Index

- 2
  - 206 Partial Content (status code)  4.1, 5.2, B
- 4
  - 416 Range Not Satisfiable (status code)  4.4, 5.2
- A
  - Accept-Ranges header field  2, 2.3, 5.1.2, 5.3
- B
  - BCP13  5.4, 8.2
  - BCP90  5.3, 8.2
- C
  - Content-Range header field  2, 4.2, 4.4, 5.3, B
- G
  - Grammar  
    - Accept-Ranges  2.3
    - acceptable-ranges  2.3
    - byte-content-range  4.2
    - byte-range  4.2
    - byte-range-resp  4.2
    - byte-range-set  2.1
    - byte-range-spec  2.1
    - byte-ranges-specifier  2.1
    - bytes-unit  2, 2.1
    - complete-length  4.2
    - Content-Range  4.2
    - first-byte-pos  2.1
    - If-Range  3.2
    - last-byte-pos  2.1
    - other-content-range  4.2
    - other-range-resp  4.2
    - other-range-unit  2, 2.2
    - Range  3.1
    - range-unit  2
    - ranges-specifier  2.1
    - suffix-byte-range-spec  2.1
    - suffix-length  2.1
    - unsatisfied-range  4.2
- I
  - If-Range header field  3.1, 3.2, 5.3
- M
  - Media Type  
    - multipart/byteranges  5.4.1, A
    - multipart/x-byteranges  A
  - multipart/byteranges Media Type  5.4.1, A
  - multipart/x-byteranges Media Type  A
- R
  - Range header field  2, 3.1, 4.1, 4.4, 5.3, B
  - RFC2046  8.1, A, A
    - Section 5.1  A
  - RFC2119  1.1, 8.1
  - RFC2616  8.2
  - RFC5226  5.1.1, 8.2
    - Section 4.1  5.1.1
  - RFC5234  1.2, 8.1, C
    - Appendix B.1  C
  - RFC7230  1.1, 1.2, 6, 7, 8.1, C, C, C, D
    - Section 1.2  D
    - Section 2.5  1.1
    - Section 3.2.3  C
    - Section 3.2.6  C
    - Section 7  1.2
    - Section 10  7
  - RFC7231  2.1, 6, 8.1, C
    - Section 3  2.1
    - Section 7.1.1.1  C
  - RFC7232  3.1, 3.2, 3.2, 3.2, 4.3, 8.1, C
    - Section 2.1  4.3
    - Section 2.2.2  3.2, 3.2
    - Section 2.3  C
    - Section 2.3.2  3.2
  - RFC7234  4.1, 8.1
    - Section 4.2.2  4.1

* Authors' Addresses

#+BEGIN_EXAMPLE
  Roy T. Fielding (editor)
  Adobe Systems Incorporated
  345 Park Ave
  San Jose, CA 95110
  USA
  Email: fielding@gbiv.com
  URI: http://roy.gbiv.com/
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  Yves Lafon (editor)
  World Wide Web Consortium
  W3C / ERCIM
  2004, rte des Lucioles
  Sophia-Antipolis, AM 06902
  France
  Email: ylafon@w3.org
  URI: http://www.raubacapeu.net/people/yves/
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  Julian F. Reschke (editor)
  greenbytes GmbH
  Hafenweg 16
  Muenster, NW 48155
  Germany
  Email: julian.reschke@greenbytes.de
  URI: http://greenbytes.de/tech/webdav/
#+END_EXAMPLE
