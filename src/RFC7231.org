#+FILETAGS: :note:rfc:
#+TITLE: RFC7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
#+SELECT_TAGS: export
#+OPTIONS: toc:5 ^:{} H:6 num:0
#+UNNUMBERED: t
#+bind: org-export-publishing-directory "./docs"

#+BEGIN_EXPORT html
<a class="github-repo" href="https://github.com/duoani/RFC7230.zh-cn">
  <svg height="18" width="18" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
  <span>View Repo</span>
</a>
#+END_EXPORT

#+BEGIN_EXPORT html
<a href="https://github.com/duoani/RFC7230.zh-cn">
  <img alt="" src="https://img.shields.io/github/license/duoani/RFC7230.zh-cn.svg?style=social"/>
</a>
<a href="https://github.com/duoani/RFC7230.zh-cn">
  <img src="https://img.shields.io/github/stars/duoani/RFC7230.zh-cn.svg?style=social&label=Stars"/>
</a>
#+END_EXPORT

#+BEGIN_SRC text
  Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
  Request for Comments: 7231                                         Adobe
  Obsoletes: 2616                                          J. Reschke, Ed.
  Updates: 2817                                                 greenbytes
  Category: Standards Track                                      June 2014
  ISSN: 2070-1721
#+END_SRC

* 摘要 / Abstract
#+BEGIN_QUOTE
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.
#+END_QUOTE

超文本传输协议（HTTP）是一种[[ruby:stateless][无状态]]的应用层协议，适用于分布式、协作式的超文本信息系统。本文档定义了 HTTP/1.1 报文的语义，引申为[[ruby:request%20methods][请求方法]]、[[ruby:request%20header%20fields][请求报头域]]、[[ruby:response%20status%20codes][响应状态码]]、[[ruby:response%20header%20fields][响应报头域]]，连同报文的[[ruby:payload][有效载荷]]（元数据以及报文正文内容）以及[[ruby:content%20negotiation][内容协商]]的机制。

* 备忘录状态 / Status of This Memo
This is an Internet Standards Track document.

This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.

Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7231.

* 版权声明 / Copyright Notice
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.

This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.

* 1. 引言 / Introduction
#+BEGIN_QUOTE
Each Hypertext Transfer Protocol (HTTP) message is either a request or a response. A server listens on a connection for a request, parses each message received, interprets the message semantics in relation to the identified request target, and responds to that request with one or more response messages. A client constructs request messages to communicate specific intentions, examines received responses to see if the intentions were carried out, and determines how to interpret the results. This document defines HTTP/1.1 request and response semantics in terms of the architecture defined in [RFC7230].
#+END_QUOTE

每一个超文本传输协议（HTTP）报文要不是一个请求，要不就是一个响应。服务器监听某个连接的请求，[[ruby:parse][解析]]每个其接收到的报文，[[ruby:interpret][解释]]报文内关于请求目标的语义，最后使用一个或多个响应报文来回应该请求。客户端构建请求报文来传达特定的意图，检查接收到的响应来观察其意图是否得到贯彻执行，并确定如何去[[ruby:interpret][解释]]该结果。本文档依据[[file:RFC7230.org][【RFC7230】]]所定义的架构，定义了 HTTP/1.1 请求和响应的语义。

#+BEGIN_QUOTE
HTTP provides a uniform interface for interacting with a resource ([[id:304453f4-a250-4f73-b82c-2825a0bda464][Section 2]]), regardless of its type, nature, or implementation, via the manipulation and transfer of representations ([[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][Section 3]]).
#+END_QUOTE

HTTP 提供了一种统一的接口来对[[ruby:resource][资源]]（[[id:304453f4-a250-4f73-b82c-2825a0bda464][章节 2]]）进行交互，而不必理会资源的类型、性质或者[[ruby:implementation][实现]]，具体是经由[[ruby:representations][表示方法]]（[[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][章节 3]]）的操作和传输的方式来实现的。

#+BEGIN_QUOTE
HTTP semantics include the intentions defined by each request method ([[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][Section 4]]), extensions to those semantics that might be described in request header fields ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]), the meaning of status codes to indicate a machine-readable response ([[id:5a69d0cc-628c-4897-a089-45f906b94a92][Section 6]]), and the meaning of other control data and resource metadata that might be given in response header fields ([[id:30e7b781-4a14-4519-abb9-63ec43516b98][Section 7]]).
#+END_QUOTE

HTTP 的语义包含了每个[[ruby:request%20method][请求方法]]所定义的意图（[[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][章节 4]]）、[[ruby:request%20header%20fields][请求报头域]]对这些语义的扩展（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）、[[ruby:status%20codes][状态码]]的含义（用于指定一种机器可阅读的响应，[[id:5a69d0cc-628c-4897-a089-45f906b94a92][章节 6]]）、以及出现在[[ruby:response%20header%20fields][响应报头域]]里的其他控制数据和资源元数据的含义（[[id:30e7b781-4a14-4519-abb9-63ec43516b98][章节 7]]）。

#+BEGIN_QUOTE
This document also defines representation metadata that describe how a payload is intended to be interpreted by a recipient, the request header fields that might influence content selection, and the various selection algorithms that are collectively referred to as "content negotiation" ([[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][Section 3.4]]).
#+END_QUOTE

本文档还定义了以下内容：描述打算让接收端怎样[[ruby:interpret][解释]]一个[[ruby:payload][有效载荷]]的[[ruby:representation%20metadata][资源的表示元数据]]、可能影响[[ruby:content%20selection][内容选择]]的请求报头域、统称为“[[ruby:content%20negotiation][内容协商]]”的各种选择算法（[[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][章节 3.4]]）。

** 1.1. 一致性和错误处理 / Conformance and Error Handling
#+BEGIN_QUOTE
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[[https://tools.ietf.org/html/rfc2119][RFC2119]]].
#+END_QUOTE

关键词 *[[ruby:MUST][必须]]*、*[[ruby:MUST%20NOT][禁止]]*、*[[ruby:REQUIRED][要求]]*、*[[ruby:SHALL][必须]]*、*[[ruby:SHALL%20NOT][禁止]]*、*[[ruby:SHOULD][应该]]*、*[[ruby:SHOULD%20NOT][不应当]]*、*[[ruby:RECOMMENDED][推荐]]*、*[[ruby:MAY][可以]]* 和 *[[ruby:OPTIONAL][可选]]* 的意义与【[[https://tools.ietf.org/html/rfc2119][RFC2119]]】一致。

#+BEGIN_QUOTE
Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].
#+END_QUOTE

关于错误处理的一致性标准以及注意事项已在[[id:A0441F72-9799-4667-9477-1E05885946A1][【RFC7230】章节 2.5]] 中定义了。

** 1.2. 句法标记 / Syntax Notation
#+BEGIN_QUOTE
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [[[https://tools.ietf.org/html/rfc5234][RFC5234]]] with a list extension, defined in [[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][Section 7]] of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix C describes rules imported from other documents. Appendix D shows the collected grammar with all list operators expanded to standard ABNF notation.
#+END_QUOTE

本规范使用了扩展巴科斯范式（ABNF）标记法【[[https://tools.ietf.org/html/rfc5234][RFC5234]]】，另外，出于定义的紧凑性的考虑，本规范对 ABNF 规则进行了扩展（见[[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][【RFC7230】章节 7]]），允许使用一个 =#= 操作符（类似于 =*= 操作符，指代“重复”）来定义一种以逗号分隔的列表。

#+BEGIN_QUOTE
This specification uses the terms "character", "character encoding scheme", "charset", and "protocol element" as they are defined in [[[https://tools.ietf.org/html/rfc6365][RFC6365]]].
#+END_QUOTE

本规范使用了术语“[[ruby:character][字符]]”、“[[ruby:character%20encoding%20scheme][字符编码方案]]”、“[[ruby:charset][字符集]]”、“[[ruby:protocol%20element][协议元素]]”，其定义见[[https://tools.ietf.org/html/rfc6365][【RFC6365】]]。

* 2. 资源 / Resources
:PROPERTIES:
:ID:       304453f4-a250-4f73-b82c-2825a0bda464
:END:
The target of an HTTP request is called a "resource". HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources. Each resource is identified by a Uniform Resource Identifier (URI), as described in [[id:9c45ae18-46b0-4acb-a478-3d3e9a3748ab][Section 2.7]] of [RFC7230].

HTTP 请求的目标，称为“[[ruby:resource][资源]]”。HTTP 并不限制一个资源的性质，它仅仅定义了一个可以用于对资源进行交互的接口。每一个资源都被一个[[ruby:Uniform%20Resource%20Identifier][统一资源标识符（URI）]]所标识，见[[id:9c45ae18-46b0-4acb-a478-3d3e9a3748ab][【RFC7230】章节 2.7]]。

When a client constructs an HTTP/1.1 request message, it sends the target URI in one of various forms, as defined in ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]). When a request is received, the server reconstructs an effective request URI for the target resource ([[id:3265c21d-0d3b-4776-8e28-38278d168779][Section 5.5]] of [RFC7230]).

当客户端[[ruby:construct][构建]]一个 HTTP/1.1 请求报文的时候，它将某种形式的[[ruby:target%20URI][目标 URI]] 包含在报文中，见[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]。当服务器接收到一个请求的时候，它将[[ruby:reconstruct][重新构建]]出一个[[ruby:effective%20request%20URI][有效请求 URI]]（见[[id:3265c21d-0d3b-4776-8e28-38278d168779][【RFC7230】章节 5.5]]）来定位[[ruby:target%20resource][目标资源]]。

One design goal of HTTP is to separate resource identification from request semantics, which is made possible by vesting the request semantics in the request method ([[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][Section 4]]) and a few request-modifying header fields ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]). If there is a conflict between the method semantics and any semantic implied by the URI itself, as described in Section 4.2.1, the method semantics take precedence.

HTTP 的设计目标之一是将[[ruby:resource%20identification][资源识别]]与请求语义相分离，使得请求语义全部归属于[[ruby:request%20method][请求方法]]（[[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][章节 4]]）以及几个[[ruby:request-modifying%20header%20fields][请求修饰报头域]]（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）。如果方法语义与 URI 自身所暗含的语义相冲突，正如[[id:2f967e3d-8694-430b-ad06-e748fd39b281][章节 4.2.1]] 所述，优先使用方法语义。

* 3. 资源的表示 / Representations
:PROPERTIES:
:ID:       7dd837af-fd6a-4918-9c62-cf12a4c31522
:END:
#+BEGIN_QUOTE
Considering that a resource could be anything, and that the uniform interface provided by HTTP is similar to a window through which one can observe and act upon such a thing only through the communication of messages to some independent actor on the other side, an abstraction is needed to represent ("take the place of") the current or desired state of that thing in our communications. That abstraction is called a representation [REST].
#+END_QUOTE

考虑到[[ruby:resource][资源]]可以是任何事物，而 HTTP 所提供的统一接口类似于一个窗口，在窗口的一边我们能够对该事物进行观察；而要想对该事物采取行动的话，只能通过消息沟通来让窗口另一边的某个独立的动作执行者来完成。因此，在沟通过程中，我们需要一种“抽象”来[[ruby:represent][表示]]（代替）该事物的当前状态或期望状态。而这种“抽象”被称为 [[ruby:representation][资源的表示]]【[[http://roy.gbiv.com/pubs/dissertation/top.htm][REST]]】。

#+BEGIN_QUOTE
译注："representation" 一词源自一种软件架构风格的术语，也就是我们常常听到的 RESTful 风格。[[ruby:representation][资源的表示]]是[[ruby:resource][资源]]的抽象，资源一般是唯一的，而资源的表示方式可以多种多样，例如，一份银行流水账单可以认为是一种资源，它的表示形式可以有 JSON、XML 或者二进制格式等，更详细的介绍可以[[http://roy.gbiv.com/pubs/dissertation/rest_arch_style.htm][查看这里]]。
#+END_QUOTE

#+BEGIN_QUOTE
For the purposes of HTTP, a "representation" is information that is intended to reflect a past, current, or desired state of a given resource, in a format that can be readily communicated via the protocol, and that consists of a set of representation metadata and a potentially unbounded stream of representation data.
#+END_QUOTE

基于 HTTP 的目的，[[ruby:representation][资源的表示]]是一种信息，该信息用于反映某个给定资源的过去、现在、或将来期望的状态。它以一种能够轻易地经由协议进行传达的格式，并由一系列 [[ruby:representation%20metadata][元数据]]以及一个可能是无限大的 [[ruby:representation%20data][数据]]（流）组成。

#+BEGIN_QUOTE
译注："representation" 由 "representation data" 和 "representation metadata" 组成。"representation data"，即资源本身；"representation metadata"，是用来描述 "representation" 的。为了表述的准确，以后将不再对 "representation"、"representation data" 以及 "representation metadata" 进行翻译。
#+END_QUOTE

#+BEGIN_QUOTE
An origin server might be provided with, or be capable of generating, multiple representations that are each intended to reflect the current state of a target resource. In such cases, some algorithm is used by the origin server to select one of those representations as most applicable to a given request, usually based on content negotiation. This "selected representation" is used to provide the data and metadata for evaluating conditional requests [RFC7232] and constructing the payload for 200 (OK) and 304 (Not Modified) responses to GET ([[id:698bab73-07b1-4349-8a03-5a4a89d966d8][Section 4.3.1]]).
#+END_QUOTE

[[ruby:origin%20server][源服务器]]可能提供或能够生成多种 representations，每种 representation 旨在反映[[ruby:target%20resource][目标资源]]的当前状态。在这种情况下，源服务器会使用某些算法（通常会基于[[ruby:content%20negotiation][内容协商]]）来选择其中一种对于给定请求来说最适合的 representation。这个“[[ruby:selected%20representation][已选定的 representation]]”是用来为[[ruby:evaluating%20conditional%20requests][评估带条件的请求]]提供数据和元数据，以及为响应给 GET 请求（[[id:698bab73-07b1-4349-8a03-5a4a89d966d8][章节 4.3.1]]）的 =200 (OK)= 和 =304 (Not Modified)= 响应报文构建[[ruby:payload][有效载荷]]。

** 3.1. Representation Metadata
#+BEGIN_QUOTE
Representation header fields provide metadata about the representation. When a message includes a payload body, the representation header fields describe how to interpret the representation data enclosed in the payload body. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the payload body if the same request had been a GET.
#+END_QUOTE

与 representation 相关的报头域提供了 representation 的元数据。当一个[[ruby:message][报文]]包含一个[[ruby:payload%20body][有效载荷]]时，与 representation 相关的报头域描述了如何解释这个包含在有效载荷里的 representation data。在一个回应给 HEAD 请求的响应报文里，与 representation 相关的报头域描述了如果相同的请求是一个 GET 请求的话，将会如何解释这个包含在有效载荷里的 representation data。

#+BEGIN_QUOTE
The following header fields convey representation metadata:
#+END_QUOTE

以下报头域负责传达 representation metadata：

| header Field Name | Defined in...   |
|-------------------+-----------------|
| Content-Type      | [[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][Section 3.1.1.5]] |
| Content-Encoding  | [[id:a10adb00-e955-42a6-8d28-ed6f942db085][Section 3.1.2.2]] |
| Content-Language  | [[id:80f3e8e8-dabb-49b8-b7e6-45f83648a732][Section 3.1.3.2]] |
| Content-Location  | [[id:91650144-4bfc-4362-b628-f96578a5c756][Section 3.1.4.2]] |

*** 3.1.1. 处理 Representation Data / Processing Representation Data
**** 3.1.1.1. 媒体类型 / Media Type
:PROPERTIES:
:ID:       bc05d462-378f-4743-a1ee-543e01064a09
:END:
#+BEGIN_QUOTE
HTTP uses Internet media types [[[https://tools.ietf.org/html/rfc2046][RFC2046]]] in the =Content-Type= ([[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][Section 3.1.1.5]]) and =Accept= ([[id:95575604-c3d4-48d6-a061-325bd7798970][Section 5.3.2]]) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with each context in which it is received.
#+END_QUOTE

为了提供开放、可扩展的[[ruby:data%20typing][数据分类]]和[[ruby:type%20negotiation][类型协商]]，HTTP 在 =Content-Type= （[[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][章节 3.1.1.5]]）和 =Accept= （[[id:95575604-c3d4-48d6-a061-325bd7798970][章节 5.3.2]]）报头域中使用[[ruby:Internet%20media%20types][互联网媒体类型]][[https://tools.ietf.org/html/rfc2046][【RFC2046】]]。媒体类型定义了数据的格式及其各种处理模型，即如何根据接收数据的各个场景来处理该数据。

#+BEGIN_SRC text
  media-type = type "/" subtype *( OWS ";" OWS parameter )
  type       = token
  subtype    = token
#+END_SRC

#+BEGIN_QUOTE
The =type/subtype= *MAY* be followed by parameters in the form of =name=value= pairs.
#+END_QUOTE

=type/subtype= 后面 *可以* 跟着键值对 =name=value= 形式的多个参数。

#+BEGIN_SRC text
  parameter      = token "=" ( token / quoted-string )
#+END_SRC

#+BEGIN_QUOTE
The =type=, =subtype=, and =parameter name= tokens are case-insensitive. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name. The presence or absence of a parameter might be significant to the processing of a media-type, depending on its definition within the media type registry.
#+END_QUOTE

上面 ABNF 列出的规则里，=type=、=subtype= 以及 =parameter= 的 =name= 这三个 token（标记）是不区分大小写的。=parameter= 的 =value= 不一定区分大小写，取决于 =parameter= 的 =name= 的语义。一个 =parameter= 的出现与否可能会对一个媒体类型的处理有重要意义，取决于该 =parameter= 在[[ruby:media%20type%20registry][媒体类型注册表]]里的定义。

#+BEGIN_QUOTE
A parameter value that matches the token production can be transmitted either as a token or within a quoted-string. The quoted and unquoted values are equivalent. For example, the following examples are all equivalent, but the first is preferred for consistency:
#+END_QUOTE

如果 =parameter= 的 =value= 符合 [[id:d0012483-93a3-44cf-b019-29e12725d94a][token]] 的语法规则的话，那么，它既可以直接作为标记来传输，也可以用在[[ruby:quoted-string][双引号字符串]]里。使用双引号包裹与否都是等价的。例如，以下例子都是等价的，但是为了一致性，应优先使用第一种：

#+BEGIN_QUOTE
译注：token，标记、记号，编程语言中的变量名、常量名就是 token，token 在 ABNF 中有明确的定义，它的命名不能出现某些特殊字符，详情见[[id:d0012483-93a3-44cf-b019-29e12725d94a][【RFC7230】章节 3.2.6]]。
#+END_QUOTE

#+BEGIN_EXAMPLE
  text/html;charset=utf-8
  text/html;charset=UTF-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
#+END_EXAMPLE

#+BEGIN_QUOTE
Internet media types ought to be registered with IANA according to the procedures defined in [[[https://tools.ietf.org/html/rfc6838][BCP13]]].
#+END_QUOTE

应该按照定义在[[https://tools.ietf.org/html/rfc6838][【BCP13】]]的流程，将[[ruby:Internet%20media%20types][互联网媒体类型]]注册在 IANA 里。

#+BEGIN_QUOTE
*Note:* Unlike some similar constructs in other header fields, media type parameters do not allow whitespace (even "bad" whitespace) around the "=" character.
#+END_QUOTE

*注意：* 不像其他报头域里的某些类似结构，媒体类型的参数不允许在 "=" 两边带有空格（即使是 [[id:f26527b6-d15c-4967-97e3-acc669609481][BWS]] 也不允许）。

**** 3.1.1.2. 字符集 / Charset
#+BEGIN_QUOTE
HTTP uses charset names to indicate or negotiate the character encoding scheme of a textual representation [[[https://tools.ietf.org/html/rfc2978][RFC6365]]]. A charset is identified by a case-insensitive token.
#+END_QUOTE

HTTP 使用[[ruby:charset%20names][字符集名称]]来指定或协商一个文本类型的 representation 的[[ruby:character%20encoding%20scheme][字符编码方案]]【[[https://tools.ietf.org/html/rfc6365][RFC6365]]】。字符集由一个不区分大小写的 token 来指定。

#+BEGIN_SRC text
  charset = token
#+END_SRC

#+BEGIN_QUOTE
Charset names ought to be registered in the IANA "Character Sets" registry (<http://www.iana.org/assignments/character-sets>) according to the procedures defined in [RFC2978].
#+END_QUOTE

应该按照定义在[[https://tools.ietf.org/html/rfc2978][【RFC2978】]]的流程，将[[ruby:charset%20names][字符集名称]]注册在 IANA 的 "Character Sets" 注册表里。

**** 3.1.1.3. 规范化和文本缺省 / Canonicalization and Text Defaults
#+BEGIN_QUOTE
Internet media types are registered with a canonical form in order to be interoperable among systems with varying native encoding formats. Representations selected or transferred via HTTP ought to be in canonical form, for many of the same reasons described by the Multipurpose Internet Mail Extensions (MIME) [[[https://tools.ietf.org/html/rfc2045][RFC2045]]]. However, the performance characteristics of email deployments (i.e., store and forward messages to peers) are significantly different from those common to HTTP and the Web (server-based information services). Furthermore, MIME's constraints for the sake of compatibility with older mail transfer protocols do not apply to HTTP (see [[id:84208afd-e458-4f40-97cc-2e9535523797][Appendix A]]).
#+END_QUOTE

[[ruby:Internet%20media%20types][互联网媒体类型]]是使用一种[[ruby:canonical%20form][规范形式]]来注册的，以便于在具有不同本地编码格式的系统之间能够相互操作。经由 HTTP 来选择或传输的 representations 应该使用规范形式，其原因已经在[[ruby:Multipurpose%20Internet%20Mail%20Extensions][多用途互联网邮件扩展]]（MIME）【[[https://tools.ietf.org/html/rfc2045][RFC2045]]】里描述过了。但是，电子邮件调度（即存储和转发报文到其他对方）的性能特征跟在 HTTP 和 Web（其于服务器的信息服务）中常见的调度有明显的区别。而且，在 MIME 里为了兼容旧的邮件传输协议所设计的约束并不适用于 HTTP（见[[id:84208afd-e458-4f40-97cc-2e9535523797][附录 A]]）。

#+BEGIN_QUOTE
译注：canonical form (or normal form, or standard form) 的解释见 [[https://en.wikipedia.org/wiki/Canonical_form][wikipedia: Canonical form]]。
#+END_QUOTE

#+BEGIN_QUOTE
MIME's canonical form requires that media subtypes of the "text" type use =CRLF= as the text line break. HTTP allows the transfer of text media with plain =CR= or =LF= alone representing a line break, when such line breaks are consistent for an entire representation. An HTTP sender *MAY* generate, and a recipient *MUST* be able to parse, line breaks in text media that consist of =CRLF=, bare =CR=, or bare =LF=. In addition, text media in HTTP is not limited to charsets that use octets 13 and 10 for =CR= and =LF=, respectively. This flexibility regarding line breaks applies only to text within a representation that has been assigned a "text" media type; it does not apply to "multipart" types or HTTP elements outside the payload body (e.g., header fields).
#+END_QUOTE

MIME 的规范形式要求文本（"text"）类型媒体的子类型使用 =CRLF= 来作为换行符。HTTP 允许文本类型媒体单独使用 =CR= 或者 =LF= 来表示一个换行符，只要求所使用的换行符在整个 representation 中是统一的。HTTP 发送端 *可以* 在文本类型媒体中生成由 =CRLF=、或者单纯是 =CR=、或者单纯是为 =LF= 组成的换行符。HTTP 接收端 *必须* 能够解析文本类型媒体中的由 =CRLF=、或者单纯是 =CR=、或者单纯是 =LF= 组成的换行符。而且，在 HTTP 里的文本类型媒体并不限于使用 13 作为 =CR=，10 作为 =LF= 的字符集。这种对于换行符的灵活性仅适用于一个声明为 "text" 媒体类型的 representation 以内的文本，它并不适用于 "multipart" 类型或者有效载荷以外的 HTTP 元素。

#+BEGIN_QUOTE
If a representation is encoded with a content-coding, the underlying data ought to be in a form defined above prior to being encoded.
#+END_QUOTE

如果一个 representation 使用了一种[[ruby:content-coding][内容编码值]]来编码，[[ruby:underlying%20data][基础数据]] 应该在编码之前处于上述定义的那种规范形式。

**** 3.1.1.4. Multipart 类型 / Multipart Types
MIME provides for a number of "multipart" types — encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in [[https://tools.ietf.org/html/rfc2046#section-5.1.1][Section 5.1.1]] of [RFC2046], and include a =boundary= parameter as part of the media type value. The message body is itself a protocol element; a sender *MUST* generate only =CRLF= to represent line breaks between body parts.

MIME 提供了大量的 "multipart" 类型——在单独一个[[ruby:message%20body][报文正文]]里封装了一个或多个 representations。所有 multipart 类型共享一个通用的句法（见[[https://tools.ietf.org/html/rfc2046#section-5.1.1][【RFC2046】章节 5.1.1]]），并且包含一个 =boundary= 参数作为媒体类型的值的一部分。报文正文本身是一个协议元素，发送端 *必须* 在报文正文的各个[[ruby:parts][分部]]之间仅生成 =CRLF= 来表示换行符。

#+BEGIN_QUOTE
译注：multipart 允许在一个报文正文里包含多个 representation，每个 representation 之间使用 =boundary= 所指定的定界符来分隔，这样就使得报文正文被分割为多个分部，分部与分部之间的内容仍然只能使用 =CRLF= 作为换行符。multipart 的一个例子可以参考[[https://tools.ietf.org/html/rfc2049#page-15][【RFC2049】附录 A]]。
#+END_QUOTE

HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the payload. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in [[[https://tools.ietf.org/html/rfc2388][RFC2388]]], and the "multipart/byteranges" type is defined by this specification for use in some =206 (Partial Content)= responses [[[https://tools.ietf.org/html/rfc7233][RFC7233]]].

HTTP [[ruby:message%20framing][报文分帧]] 并不会使用 multipart 的 =boundary= 作为报文正文长度的一个标识符，虽然它可能被[[ruby:implementations][实现]]用于生成或处理有效载荷。例如，"multipart/form-data" 类型通常用于在一个请求里携带表单数据，如【[[https://tools.ietf.org/html/rfc2388][RFC2388]]】所述。"multipart/byteranges" 类型是由本规范所定义的，用在某些 =206 (Partial Content)= 响应里【[[https://tools.ietf.org/html/rfc7233][RFC7233]]】。

**** 3.1.1.5. Content-Type
:PROPERTIES:
:ID:       fcfdf1e4-f733-4305-9ad4-761271a3dd69
:END:
#+BEGIN_QUOTE
The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by =Content-Encoding= are decoded.
#+END_QUOTE

=Content-Type= 报头域指明了它所关联的 representation 的媒体类型。所述“关联的 representation”，要不是包含在报文有效载荷里的 representation，要不是已选定的 representation，由报文语义所决定。=Content-Type= 所指定的媒体类型定义了 representation 的数据格式以及期望该数据被接收端如何处理，在该报文的语义范围之内，在依照 =Content-Encoding= 里的所有内容编码进行解码之后。

#+BEGIN_SRC text
  Content-Type = media-type
#+END_SRC

#+BEGIN_QUOTE
Media types are defined in [[id:bc05d462-378f-4743-a1ee-543e01064a09][Section 3.1.1.1]]. An example of the field is
#+END_QUOTE

媒体类型定义在[[id:bc05d462-378f-4743-a1ee-543e01064a09][章节 3.1.1.1]]。以下是 =Content-Type= 报头域的一个例子：

#+BEGIN_SRC text
  Content-Type: text/html; charset=ISO-8859-4
#+END_SRC

#+BEGIN_QUOTE
A sender that generates a message containing a payload body *SHOULD* generate a =Content-Type= header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a =Content-Type= header field is not present, the recipient *MAY* either assume a media type of "application/octet-stream" ([RFC2046], [[https://tools.ietf.org/html/rfc2046#section-4.5.1][Section 4.5.1]]) or examine the data to determine its type.
#+END_QUOTE

发送端在生成包含有一个有效载荷的报文的时候，*应当* 在该报文里生成一个 =Content-Type= 报头域，除非它并不知道应该对有效载荷内的 representation 的指定哪一种媒体类型。如果没有出现 =Content-Type= 报头域，接收端 *可以* 要不假定为 "application/octet-stream" 媒体类型（[[https://tools.ietf.org/html/rfc2046#section-4.5.1][【RFC2046】章节 4.5.1]]），要不检查该数据来确定它的媒体类型。

#+BEGIN_QUOTE
In practice, resource owners do not always properly configure their origin server to provide the correct =Content-Type= for a given representation, with the result that some clients will examine a payload's content and override the specified type. Clients that do so risk drawing incorrect conclusions, which might expose additional security risks (e.g., "privilege escalation"). Furthermore, it is impossible to determine the sender's intent by examining the data format: many data formats match multiple media types that differ only in processing semantics. Implementers are encouraged to provide a means of disabling such "content sniffing" when it is used.
#+END_QUOTE

实际上，[[ruby:resource%20owners][资源所有者]]并不总是能恰当地配置它们的源服务器来为一个给定的 representation 提供正确的 =Content-Type=，出于这种原因，某些客户端会检查有效载荷的内容然后[[ruby:override][重写]]指定的类型。但是，客户端这样做可能会得出错误的论断，从而可能会暴露出额外的安全风险（例如，[[ruby:privilege%20escalation][特权提升]]）。而且，通过检查数据格式是不可能确定发送端的真正意图的，这是由于某些数据格式能够匹配多种媒体类型，而仅在语义处理会有所不同。鼓励实现者提供一种方法，当启用这种方法的时候可以禁用上述这种“[[ruby:content%20sniffing][内容嗅探]]”。

#+BEGIN_QUOTE
译注：特权提升的详细介绍见 [[https://en.wikipedia.org/wiki/Privilege_escalation][Wikipedia: Privilege escalation]] 或者 [[https://zh.wikipedia.org/wiki/%25E7%2589%25B9%25E6%259D%2583%25E6%258F%2590%25E5%258D%2587][维基百科（中文）]]。
#+END_QUOTE

*** 3.1.2. 为压缩或完整性而编码 / Encoding for Compression or Integrity
**** 3.1.2.1. Content Codings
#+BEGIN_QUOTE
Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.
#+END_QUOTE

content coding 的值指明了一种已经或能够应用到一个 representation 的[[ruby:encoding%20transformation][编码转换]]。content coding 主要用来允许在没有丢失 representation 之前的媒体类型的身份以及没有丢失信息的情况下，对该 representation 进行压缩或者进行其他方式的转换。representation 常常被存储为[[ruby:code%20form][编码过的形式]]，然后将其直接进行传输，最后仅到达最终接收端才会进行解码。

#+BEGIN_QUOTE
译文：本译文将 "encoding" 翻译为“编码”，为了与之区分，不会对 "content coding" 进行翻译（实际上是我不知道怎么翻译才好，意会，意会）。
#+END_QUOTE

#+BEGIN_SRC text
  content-coding   = token
#+END_SRC

#+BEGIN_QUOTE
All content-coding values are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as defined in [[id:87f2ed30-a48b-4c31-a181-8e3a33ba1080][Section 8.4]]. They are used in the =Accept-Encoding= ([[id:a8fcc101-3782-4ed0-aec0-561b933e6a5f][Section 5.3.4]]) and =Content-Encoding= ([[id:a10adb00-e955-42a6-8d28-ed6f942db085][Section 3.1.2.2]]) header fields.
#+END_QUOTE

所有 =content-coding= 的值都是不区分大小写的，并且应该注册到 "HTTP Content Coding Registry" 注册表里，如[[id:87f2ed30-a48b-4c31-a181-8e3a33ba1080][章节 8.4]] 所述。它们用在 =Accept-Encoding= （[[id:a8fcc101-3782-4ed0-aec0-561b933e6a5f][章节 5.3.4]]）和 =Content-Encoding= （[[id:a10adb00-e955-42a6-8d28-ed6f942db085][章节 3.1.2.2]]）报头域里。

#+BEGIN_QUOTE
The following content-coding values are defined by this specification:
- compress (and x-compress): See [[id:a785a05f-6fdc-44d8-9343-3a66a49cb655][Section 4.2.1]] of [RFC7230].
- deflate: See [[id:fa7b432f-071b-4e26-9d2c-8fc1b95b6b64][Section 4.2.2]] of [RFC7230].
- gzip (and x-gzip): See [[id:d1579c8b-312c-414b-b421-960669b0d389][Section 4.2.3]] of [RFC7230].
#+END_QUOTE

本规范定义了以下 =content-coding= 值：
- compress（以及 x-compress）：见[[id:a785a05f-6fdc-44d8-9343-3a66a49cb655][【RFC7230】章节 4.2.1]]。
- deflate：见[[id:fa7b432f-071b-4e26-9d2c-8fc1b95b6b64][【RFC7230】章节4.2.2]]。
- gzip（以及 x-gzip）：[[id:d1579c8b-312c-414b-b421-960669b0d389][【RFC7230】见章节 4.2.3]]。

**** 3.1.2.2. Content-Encoding
:PROPERTIES:
:ID:       a10adb00-e955-42a6-8d28-ed6f942db085
:END:
#+BEGIN_QUOTE
The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the =Content-Type= header field. =Content-Encoding= is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
#+END_QUOTE

=Content-Encoding= 报头域指明了已经对 representation 应用了哪些突破其固有的媒体类型的 content codings，因此得知，为了获得 =Content-Type= 报头域所提及的那种媒体类型的数据，需要应用哪一种解码机制。=Content-Encoding= 主要用来允许在没有丢失 representation 之前的媒体类型的身份的情况下，对一个 representation 的数据进行压缩。

#+BEGIN_SRC text
  Content-Encoding = 1#content-coding
#+END_SRC

#+BEGIN_QUOTE
An example of its use is
#+END_QUOTE

它的用法见下面这个例子：

#+BEGIN_EXAMPLE
  Content-Encoding: gzip
#+END_EXAMPLE

#+BEGIN_QUOTE
If one or more encodings have been applied to a representation, the sender that applied the encodings *MUST* generate a =Content-Encoding= header field that lists the content codings in the order in which they were applied. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
#+END_QUOTE

如果对一个 representation 应用了一种或多种编码，应用这些编码的发送端 *必须* 生成一个 =Content-Encoding= 报头域，以它们被应用的先后顺序来一一列出对应的 content codings。如果某种编码需要附带额外的参数信息的话，可以由其他未在本规范上定义过的报头域来提供。

#+BEGIN_QUOTE
Unlike =Transfer-Encoding= ([[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][Section 3.3.1]] of [RFC7230]), the codings listed in =Content-Encoding= are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.
#+END_QUOTE

不像 =Transfer-Encoding= （[[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][【RFC7230】章节 3.3.1]]），列在 =Content-Encoding= 报头域上的 codings 是 representation 的特性。representation 是依据其编码过的形式来进行定义的，所有其他关于 representation 的元数据是对该形式进行描述的，除非在元数据的定义中另有注明。

#+BEGIN_QUOTE
If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in =Content-Encoding= even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of =Content-Type= or =Content-Encoding=, since some user agents will behave differently in their handling of each response (e.g., open a "Save as ..." dialog instead of automatic decompression and rendering of content).
#+END_QUOTE

如果媒体类型包含有一种[[ruby:inherent%20encoding][固有的编码]]，例如一种一直是压缩过的数据格式，那么，这种编码不要在 =Content-Encoding= 里重申，哪怕它恰巧与其中一个 content codings 的算法一致。这种 content coding 只会在以下这种情况下才需要在 =Content-Encoding= 列出：出于某些怪异的原因，需要应用该 content coding 两次才能形成正确的 representation。同样，原服务器可能选择将该同样的数据作为 multiple representations 来发布，其区别仅在于 coding 是作为 Content-Type 的一部分还是作为 Content-Encoding 的一部分 ，这是因为某些用户代理处理各个响应的行为会有所不同（例如，打开一个“另存为...”对话框，而不是自动解缩并渲染内容）。

#+BEGIN_QUOTE
An origin server *MAY* respond with a status code of =415 (Unsupported Media Type)= if a representation in the request message has a content coding that is not acceptable.
#+END_QUOTE

如果请求报文里的某个 representation 应用了服务器不支持的 content coding，源服务器 *可以* 以 =415 (Unsupported Media Type)= 作为响应。

*** 3.1.3. 受众语言 / Audience Language
**** 3.1.3.1. 语言标签 / Language Tags
#+BEGIN_QUOTE
A language tag, as defined in [[[https://tools.ietf.org/html/rfc5646][RFC5646]]], identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.
#+END_QUOTE

正如【[[https://tools.ietf.org/html/rfc5646][RFC5646]]】所定义，[[ruby:language%20tag][语言标签]]标识了一种人类出于交流信息的目的而通过说、写或其他方式来传达的自然语言。计算机语言被明确排除在外。

#+BEGIN_QUOTE
HTTP uses language tags within the =Accept-Language= and =Content-Language= header fields. =Accept-Language= uses the broader =language-range= production defined in Section 5.3.5, whereas =Content-Language= uses the =language-tag= production defined below.
#+END_QUOTE

HTTP 在 =Accept-Language= 和 =Content-Language= 报头域里使用语言标签。=Accept-Language= 使用了更广义的 =language-range= 规则（定义在章节 5.3.5），而 =Content-Language= 使用了 =language-tag=，其定义如下：

#+BEGIN_SRC text
  language-tag = <Language-Tag, see [RFC5646], Section 2.1>
#+END_SRC

#+BEGIN_QUOTE
A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada). Whitespace is not allowed within a language tag. Example tags include:
#+END_QUOTE

#+BEGIN_EXAMPLE
  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
#+END_EXAMPLE

#+BEGIN_QUOTE
See [RFC5646] for further information.
#+END_QUOTE

**** 3.1.3.2. Content-Language
:PROPERTIES:
:ID:       80f3e8e8-dabb-49b8-b7e6-45f83648a732
:END:
#+BEGIN_QUOTE
The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.
#+END_QUOTE

#+BEGIN_SRC text
  Content-Language = 1#language-tag
#+END_SRC

#+BEGIN_QUOTE
Language tags are defined in Section 3.1.3.1. The primary purpose of Content-Language is to allow a user to identify and differentiate representations according to the users' own preferred language. Thus, if the content is intended only for a Danish-literate audience, the appropriate field is
#+END_QUOTE

#+BEGIN_EXAMPLE
  Content-Language: da
#+END_EXAMPLE

#+BEGIN_QUOTE
If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
#+END_QUOTE

#+BEGIN_QUOTE
Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for
#+END_QUOTE

#+BEGIN_EXAMPLE
  Content-Language: mi, en
#+END_EXAMPLE

#+BEGIN_QUOTE
However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include "en".
#+END_QUOTE

#+BEGIN_QUOTE
Content-Language MAY be applied to any media type — it is not limited to textual documents.
#+END_QUOTE

*** 3.1.4. Identification
**** 3.1.4.1. Identifying a Representation
#+BEGIN_QUOTE
When a complete or partial representation is transferred in a message payload, it is often desirable for the sender to supply, or the recipient to determine, an identifier for a resource corresponding to that representation.
#+END_QUOTE

#+BEGIN_QUOTE
For a request message:
- If the request has a Content-Location header field, then the sender asserts that the payload is a representation of the resource identified by the Content-Location field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification). The information might still be useful for revision history links.
- Otherwise, the payload is unidentified.
#+END_QUOTE

#+BEGIN_QUOTE
For a response message, the following rules are applied in order until a match is found:
1. If the request method is GET or HEAD and the response status code is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not Modified), the payload is a representation of the resource identified by the effective request URI (Section 5.5 of [RFC7230]).
2. If the request method is GET or HEAD and the response status code is 203 (Non-Authoritative Information), the payload is a potentially modified or enhanced representation of the target resource as provided by an intermediary.
3. If the response has a Content-Location header field and its field-value is a reference to the same URI as the effective request URI, the payload is a representation of the resource identified by the effective request URI.
4. If the response has a Content-Location header field and its field-value is a reference to a URI different from the effective request URI, then the sender asserts that the payload is a representation of the resource identified by the Content-Location field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification).
5. Otherwise, the payload is unidentified.
#+END_QUOTE
**** 3.1.4.2. Content-Location
:PROPERTIES:
:ID:       91650144-4bfc-4362-b628-f96578a5c756
:END:
#+BEGIN_QUOTE
The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a 200 (OK) response would contain the same representation that is enclosed as payload in this message.
#+END_QUOTE

#+BEGIN_SRC text
  Content-Location = absolute-URI / partial-URI
#+END_SRC

#+BEGIN_QUOTE
The =Content-Location= value is not a replacement for the effective Request URI (Section 5.5 of [RFC7230]). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in Section 4 of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.
#+END_QUOTE

#+BEGIN_QUOTE
If =Content-Location= is included in a 2xx (Successful) response message and its value refers (after conversion to absolute form) to a URI that is the same as the effective request URI, then the recipient MAY consider the payload to be a current representation of that resource at the time indicated by the message origination date. For a GET (Section 4.3.1) or HEAD (Section 4.3.2) request, this is the same as the default semantics when no Content-Location is provided by the server. For a state-changing request like PUT (Section 4.3.4) or POST (Section 4.3.3), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.
#+END_QUOTE

#+BEGIN_QUOTE
If =Content-Location= is included in a 2xx (Successful) response message and its field-value refers to a URI that differs from the effective request URI, then the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.
#+END_QUOTE

- For a response to a GET or HEAD request, this is an indication that the effective request URI refers to a resource that is subject to content negotiation and the Content-Location field-value is a more specific identifier for the selected representation.
- For a 201 (Created) response to a state-changing method, a Content-Location field-value that is identical to the Location field-value indicates that this payload is a current representation of the newly created resource.
- Otherwise, such a Content-Location indicates that this payload is a representation reporting on the requested action's status and that the same report is available (for future access with GET) at the given URI. For example, a purchase transaction made via a POST request might include a receipt document as the payload of the 200 (OK) response; the Content-Location field-value provides an identifier for retrieving a copy of that same receipt in the future.

#+BEGIN_QUOTE
A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.
#+END_QUOTE

#+BEGIN_QUOTE
An origin server that receives a Content-Location field in a request message MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server MUST NOT use such context information to alter the request semantics.
#+END_QUOTE

#+BEGIN_QUOTE
For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.
#+END_QUOTE

** 3.2. Representation Data
#+BEGIN_QUOTE
The representation data associated with an HTTP message is either provided as the payload body of the message or referred to by the message semantics and the effective request URI. The representation data is in a format and encoding defined by the representation metadata header fields.
#+END_QUOTE

#+BEGIN_QUOTE
The data type of the representation data is determined via the header fields Content-Type and Content-Encoding. These define a two-layer, ordered encoding model:
#+END_QUOTE

#+BEGIN_SRC text
  representation-data := Content-Encoding( Content-Type( bits ) )
#+END_SRC

** 3.3. Payload Semantics
Some HTTP messages transfer a complete or partial representation as the message "payload". In some cases, a payload might contain only the associated representation's header fields (e.g., responses to HEAD) or only some part(s) of the representation data (e.g., the 206 (Partial Content) status code).

The purpose of a payload in a request is defined by the method semantics. For example, a representation in the payload of a PUT request (Section 4.3.4) represents the desired state of the target resource if the request is successfully applied, whereas a representation in the payload of a POST request (Section 4.3.3) represents information to be processed by the target resource.

In a response, the payload's purpose is defined by both the request method and the response status code. For example, the payload of a 200 (OK) response to GET (Section 4.3.1) represents the current state of the target resource, as observed at the time of the message origination date (Section 7.1.1.2), whereas the payload of the same status code in a response to POST might represent either the processing result or the new state of the target resource after applying the processing. Response messages with an error status code usually contain a payload that represents the error condition, such that it describes the error state and what next steps are suggested for resolving it.

Header fields that specifically describe the payload, rather than the associated representation, are referred to as "payload header fields". Payload header fields are defined in other parts of this specification, due to their impact on message parsing.

| Header Field Name | Defined in...              |
|-------------------+----------------------------|
| Content-Length    | Section 3.3.2 of [RFC7230] |
| Content-Range     | Section 4.2 of [RFC7233]   |
| Trailer           | Section 4.4 of [RFC7230]   |
| Transfer-Encoding | Section 3.3.1 of [RFC7230] |

** 3.4. Content Negotiation
:PROPERTIES:
:ID:       c45cb9ca-1e51-4738-8c43-231e7316ea86
:END:
#+BEGIN_QUOTE
When responses convey payload information, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings. Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver. For this reason, HTTP provides mechanisms for content negotiation.
#+END_QUOTE

#+BEGIN_QUOTE
This specification defines two patterns of content negotiation that can be made visible within the protocol: "proactive", where the server selects the representation based upon the user agent's stated preferences, and "reactive" negotiation, where the server provides a list of representations for the user agent to choose from. Other patterns of content negotiation include "conditional content", where the representation consists of multiple parts that are selectively rendered based on user agent parameters, "active content", where the representation contains a script that makes additional (more specific) requests based on the user agent characteristics, and "Transparent Content Negotiation" ([RFC2295]), where content selection is performed by an intermediary. These patterns are not mutually exclusive, and each has trade-offs in applicability and practicality.
#+END_QUOTE

#+BEGIN_QUOTE
Note that, in all cases, HTTP is not aware of the resource semantics. The consistency with which an origin server responds to requests, over time and over the varying dimensions of content negotiation, and thus the "sameness" of a resource's observed representations over time, is determined entirely by whatever entity or algorithm selects or generates those responses. HTTP pays no attention to the man behind the curtain.
#+END_QUOTE

*** 3.4.1. Proactive Negotiation
#+BEGIN_QUOTE
When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called proactive negotiation (a.k.a., server-driven negotiation). Selection is based on the available representations for a response (the dimensions over which it might vary, such as language, content-coding, etc.) compared to various information supplied in the request, including both the explicit negotiation fields of Section 5.3 and implicit characteristics, such as the client's network address or parts of the User-Agent field.
#+END_QUOTE

#+BEGIN_QUOTE
Proactive negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to a user agent, or when the server desires to send its "best guess" to the user agent along with the first response (hoping to avoid the round trip delay of a subsequent request if the "best guess" is good enough for the user). In order to improve the server's guess, a user agent MAY send request header fields that describe its preferences.
#+END_QUOTE

#+BEGIN_QUOTE
Proactive negotiation has serious disadvantages:
- It is impossible for the server to accurately determine what might be "best" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?);
- Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy;
- It complicates the implementation of an origin server and the algorithms for generating responses to a request; and,
- It limits the reusability of responses for shared caching.
#+END_QUOTE

#+BEGIN_QUOTE
A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a 406 (Not Acceptable) response.
#+END_QUOTE

#+BEGIN_QUOTE
A Vary header field (Section 7.1.4) is often sent in a response subject to proactive negotiation to indicate what parts of the request information were used in the selection algorithm.
#+END_QUOTE

*** 3.4.2. Reactive Negotiation
#+BEGIN_QUOTE
With reactive negotiation (a.k.a., agent-driven negotiation), selection of the best response representation (regardless of the status code) is performed by the user agent after receiving an initial response from the origin server that contains a list of resources for alternative representations. If the user agent is not satisfied by the initial response representation, it can perform a GET request on one or more of the alternative resources, selected based on metadata included in the list, to obtain a different form of representation for that response. Selection of alternatives might be performed automatically by the user agent or manually by the user selecting from a generated (possibly hypertext) menu.
#+END_QUOTE

#+BEGIN_QUOTE
Note that the above refers to representations of the response, in general, not representations of the resource. The alternative representations are only considered representations of the target resource if the response in which those alternatives are provided has the semantics of being a representation of the target resource (e.g., a 200 (OK) response to a GET request) or has the semantics of providing links to alternative representations for the target resource (e.g., a 300 (Multiple Choices) response to a GET request).
#+END_QUOTE

#+BEGIN_QUOTE
A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred. For example, the alternatives listed in responses with the 300 (Multiple Choices) and 406 (Not Acceptable) status codes include information about the available representations so that the user or user agent can react by making a selection.
#+END_QUOTE

#+BEGIN_QUOTE
Reactive negotiation is advantageous when the response would vary over commonly used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage.
#+END_QUOTE

#+BEGIN_QUOTE
Reactive negotiation suffers from the disadvantages of transmitting a list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation. Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed as an extension.
#+END_QUOTE

* 4. Request Methods
:PROPERTIES:
:ID:       e6ec0aa0-3e4d-4367-bffd-423e028210b0
:END:
** 4.1. Overview
** 4.2. Common Method Properties
*** 4.2.1. Safe Methods
:PROPERTIES:
:ID:       2f967e3d-8694-430b-ad06-e748fd39b281
:END:
*** 4.2.2. Idempotent Methods
*** 4.2.3. Cacheable Methods
** 4.3. Method Definitions
*** 4.3.1. GET
:PROPERTIES:
:ID:       698bab73-07b1-4349-8a03-5a4a89d966d8
:END:
*** 4.3.2. HEAD
*** 4.3.3. POST
*** 4.3.4. PUT
*** 4.3.5. DELETE
*** 4.3.6. CONNECT
*** 4.3.7. OPTIONS
*** 4.3.8. TRACE
* 5. Request Header Fields
:PROPERTIES:
:ID:       f8e7b063-496f-473e-95e8-88ec76f21582
:END:
** 5.1. Controls
*** 5.1.1. Expect
*** 5.1.2. Max-Forwards
** 5.2. Conditionals
** 5.3. Content Negotiation
*** 5.3.1. Quality Values
*** 5.3.2. Accept
:PROPERTIES:
:ID:       95575604-c3d4-48d6-a061-325bd7798970
:END:
*** 5.3.3. Accept-Charset
*** 5.3.4. Accept-Encoding
:PROPERTIES:
:ID:       a8fcc101-3782-4ed0-aec0-561b933e6a5f
:END:
*** 5.3.5. Accept-Language
** 5.4. Authentication Credentials
** 5.5. Request Context
*** 5.5.1. Form
*** 5.5.2. Referer
*** 5.5.3. User-Agent
* 6. Response Status Codes
:PROPERTIES:
:ID:       5a69d0cc-628c-4897-a089-45f906b94a92
:END:
** 6.1. Overview of Status Codes
** 6.2. Informational 1xx
*** 6.2.1. 100 Continue
*** 6.2.2. 101 Switching Protocols
** 6.3. Successful 2xx
*** 6.3.1. 200 OK
*** 6.3.2. 201 Created
*** 6.3.3. 202 Accepted
*** 6.3.4. 203 Non-Authoritative Information
*** 6.3.5. 204 No Content
*** 6.3.6. 205 Reset Content
** 6.4. Redirection 3xx
*** 6.4.1. 300 Multiple Choices
*** 6.4.2. 301 Moved Permanently
*** 6.4.3. 302 Found
*** 6.4.4. 303 See Other
*** 6.4.5. 305 Use Proxy
*** 6.4.6. 306 (Unused)
*** 6.4.7. 307 Temporary Redirect
** 6.5. Client Error 4xx
*** 6.5.1. 400 Bad Request
*** 6.5.2. 402 Payment Required
*** 6.5.3. 403 Forbidden
*** 6.5.4. 404 Not Found
*** 6.5.5. 405 Method Not Allowed
*** 6.5.6. 406 Not Acceptable
*** 6.5.7. 408 Request Timeout
*** 6.5.8. 409 Conflict
*** 6.5.9. 410 Gone
*** 6.5.10. 411 Length Required
*** 6.5.11. 413 Payload Too Large
*** 6.5.12. 414 URI Too Long
*** 6.5.13. 415 Unsupported Media Type
*** 6.5.14. 417 Expectation Failed
*** 6.5.15. 426 Upgrade Required
** 6.6 Server Error 5xx
*** 6.6.1. 500 Internal Server Error
*** 6.6.2. 501 Not Implemented
*** 6.6.3. 502 Bad Gateway
*** 6.6.4. 503 Service Unavailable
*** 6.6.5. 504 Gateway Timeout
*** 6.6.6. 505 HTTP Version Not Supported
* 7. Response Header Fields
:PROPERTIES:
:ID:       30e7b781-4a14-4519-abb9-63ec43516b98
:END:
** 7.1. Control Data
*** 7.1.1. Origination Date
*** 7.1.2. Location
*** 7.1.3. Retry-After
*** 7.1.4. Vary
** 7.2. Validator Header Fields
** 7.3. Authentication Challenges
** 7.4. Response Context
*** 7.4.1. Allow
*** 7.4.2. Server
* 8. IANA Considerations
** 8.1. Method Registry
*** 8.1.1. Procedure
*** 8.1.2. Considerations for New Methods
*** 8.1.3. Registrations
** 8.2. Status Code Registry
*** 8.2.1. Procedure
*** 8.2.2. Considerations for New Status Codes
*** 8.2.3. Registrations
** 8.3. Header Field Registry
*** 8.3.1. Considerations for New Header Fields
*** 8.3.2. Registrations
** 8.4. Content Coding Registry
:PROPERTIES:
:ID:       87f2ed30-a48b-4c31-a181-8e3a33ba1080
:END:
*** 8.4.1. Procedure
*** 8.4.2. Registrations
* 9. Security Considerations
** 9.1. Attacks Based on File and Path Names
** 9.2. Attacks Based on Command, Code, or Query Injection
** 9.3. Disclosure of Personal Information
** 9.4. Disclosure of Sensitive Information in URLs
** 9.5. Disclosure of Fragment after Redirects
** 9.6. Disclosure of Product Information
** 9.7. Browser Fingerprinting
* 10. Acknowledgements
* 11. References
** 11.1. Normative References
** 11.2. Informative References
* A. Defferences between HTTP and MIME
:PROPERTIES:
:ID:       84208afd-e458-4f40-97cc-2e9535523797
:END:
** A.1. MIME-VERSION
** A.2. Conversion to Canonical Form
** A.3. Conversion of Date Formats
** A.4. Conversion of Content-Encoding
** A.5. Conversion of Content-Transfer-Encoding
** A.6. MHTML and Line Length Limitations
* B. Changes from RFC 2616
* C. Imported ABNF
* D. Collected ABNF
* Index
* Author' Addresses
