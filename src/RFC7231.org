#+FILETAGS: :note:rfc:
#+TITLE: RFC7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
#+SELECT_TAGS: export
#+OPTIONS: toc:5 ^:{} H:6 num:0
#+UNNUMBERED: t
#+bind: org-export-publishing-directory "./docs"

#+BEGIN_EXPORT html
<a class="github-repo" href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <svg height="18" width="18" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
  <span>View Repo</span>
</a>
#+END_EXPORT

#+BEGIN_EXPORT html
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img alt="" src="https://img.shields.io/github/license/duoani/HTTP-RFCs.zh-cn.svg?style=social"/>
</a>
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img src="https://img.shields.io/github/stars/duoani/HTTP-RFCs.zh-cn.svg?style=social&label=Stars"/>
</a>
#+END_EXPORT

#+BEGIN_SRC text
                                                         PROPOSED STANDARD
                                                              Errata Exist
  Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
  Request for Comments: 7231                                         Adobe
  Obsoletes: 2616                                          J. Reschke, Ed.
  Updates: 2817                                                 greenbytes
  Category: Standards Track                                      June 2014
  ISSN: 2070-1721
#+END_SRC

* 摘要 / Abstract
#+BEGIN_QUOTE
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.
#+END_QUOTE

超文本传输协议（HTTP）是一种[[ruby:stateless][无状态]]的应用层协议，适用于分布式、协作式的超文本信息系统。本文档定义了 HTTP/1.1 消息的语义，引申为[[ruby:request%20methods][请求方法]]、[[ruby:request%20header%20fields][请求头字段]]、[[ruby:response%20status%20codes][响应状态码]]、[[ruby:response%20header%20fields][响应头字段]]，连同消息的[[ruby:payload][有效载荷]]（元数据以及消息体内容）以及[[ruby:content%20negotiation][内容协商]]的机制。

* 备忘录状态 / Status of This Memo
This is an Internet Standards Track document.

This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.

Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7231.

* 版权声明 / Copyright Notice
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.

This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.

* 1. 引言 / Introduction
#+BEGIN_QUOTE
Each Hypertext Transfer Protocol (HTTP) message is either a request or a response. A server listens on a connection for a request, parses each message received, interprets the message semantics in relation to the identified request target, and responds to that request with one or more response messages. A client constructs request messages to communicate specific intentions, examines received responses to see if the intentions were carried out, and determines how to interpret the results. This document defines HTTP/1.1 request and response semantics in terms of the architecture defined in [RFC7230].
#+END_QUOTE

每一个超文本传输协议（HTTP）消息不是一个请求就是一个响应。服务器监听某个连接的请求，[[ruby:parse][解析]]其接收到的每个消息，[[ruby:interpret][解释]]消息内关于请求目标的语义，最后使用一个或多个响应消息来回应该请求。客户端构建请求消息来传达特定的意图，检查接收到的响应来观察其意图是否得到贯彻执行，并确定如何去[[ruby:interpret][解释]]该结果。本文档依据[[file:RFC7230.org][【RFC7230】]]所定义的架构，定义了 HTTP/1.1 请求和响应的语义。

#+BEGIN_QUOTE
HTTP provides a uniform interface for interacting with a resource ([[id:304453f4-a250-4f73-b82c-2825a0bda464][Section 2]]), regardless of its type, nature, or implementation, via the manipulation and transfer of representations ([[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][Section 3]]).
#+END_QUOTE

HTTP 提供了一种统一的接口来对[[ruby:resource][资源]]（[[id:304453f4-a250-4f73-b82c-2825a0bda464][章节 2]]）进行交互，而不必理会资源的类型、性质或者[[ruby:implementation][实现]]，具体是经由对[[ruby:representations][资源的表示形式]]（[[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][章节 3]]）进行操作和传输来实现的。

#+BEGIN_QUOTE
HTTP semantics include the intentions defined by each request method ([[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][Section 4]]), extensions to those semantics that might be described in request header fields ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]), the meaning of status codes to indicate a machine-readable response ([[id:5a69d0cc-628c-4897-a089-45f906b94a92][Section 6]]), and the meaning of other control data and resource metadata that might be given in response header fields ([[id:30e7b781-4a14-4519-abb9-63ec43516b98][Section 7]]).
#+END_QUOTE

HTTP 的语义包含了每个[[ruby:request%20method][请求方法]]所定义的意图（[[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][章节 4]]）、[[ruby:request%20header%20fields][请求头字段]]对这些语义的扩展（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）、[[ruby:status%20codes][状态码]]的含义（用于指定一种机器可阅读的响应，[[id:5a69d0cc-628c-4897-a089-45f906b94a92][章节 6]]）、以及出现在[[ruby:response%20header%20fields][响应头字段]]里的其他控制数据和资源元数据的含义（[[id:30e7b781-4a14-4519-abb9-63ec43516b98][章节 7]]）。

#+BEGIN_QUOTE
This document also defines representation metadata that describe how a payload is intended to be interpreted by a recipient, the request header fields that might influence content selection, and the various selection algorithms that are collectively referred to as "content negotiation" ([[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][Section 3.4]]).
#+END_QUOTE

本文档还定义了以下内容：[[ruby:representation%20metadata][资源的表示形式元数据]]，用于描述打算让接收端怎样[[ruby:interpret][解释]]一个[[ruby:payload][有效载荷]]；可能影响[[ruby:content%20selection][内容选择]]的请求头字段、统称为“[[ruby:content%20negotiation][内容协商]]”的各种选择算法（[[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][章节 3.4]]）。

** 1.1. 一致性和错误处理 / Conformance and Error Handling
#+BEGIN_QUOTE
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[[https://tools.ietf.org/html/rfc2119][RFC2119]]].
#+END_QUOTE

关键词 *[[ruby:MUST][必须]]*、*[[ruby:MUST%20NOT][禁止]]*、*[[ruby:REQUIRED][要求]]*、*[[ruby:SHALL][必须]]*、*[[ruby:SHALL%20NOT][禁止]]*、*[[ruby:SHOULD][应该]]*、*[[ruby:SHOULD%20NOT][不应当]]*、*[[ruby:RECOMMENDED][推荐]]*、*[[ruby:MAY][可以]]* 和 *[[ruby:OPTIONAL][可选]]* 的意义与【[[https://tools.ietf.org/html/rfc2119][RFC2119]]】一致。

#+BEGIN_QUOTE
Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].
#+END_QUOTE

关于错误处理的一致性标准以及注意事项已在[[id:A0441F72-9799-4667-9477-1E05885946A1][【RFC7230】章节 2.5]] 中定义了。

** 1.2. 句法标记 / Syntax Notation
#+BEGIN_QUOTE
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [[[https://tools.ietf.org/html/rfc5234][RFC5234]]] with a list extension, defined in [[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][Section 7]] of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix C describes rules imported from other documents. Appendix D shows the collected grammar with all list operators expanded to standard ABNF notation.
#+END_QUOTE

本规范使用了扩展巴科斯范式（ABNF）标记法【[[https://tools.ietf.org/html/rfc5234][RFC5234]]】，另外，出于定义的紧凑性的考虑，本规范对 ABNF 规则进行了扩展（见[[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][【RFC7230】章节 7]]），允许使用一个 =#= 操作符（类似于 =*= 操作符，指代“重复”）来定义一种以逗号分隔的列表。

#+BEGIN_QUOTE
This specification uses the terms "character", "character encoding scheme", "charset", and "protocol element" as they are defined in [[[https://tools.ietf.org/html/rfc6365][RFC6365]]].
#+END_QUOTE

本规范使用了术语“[[ruby:character][字符]]”、“[[ruby:character%20encoding%20scheme][字符编码方案]]”、“[[ruby:charset][字符集]]”、“[[ruby:protocol%20element][协议元素]]”，其定义见[[https://tools.ietf.org/html/rfc6365][【RFC6365】]]。

* 2. 资源 / Resources
:PROPERTIES:
:ID:       304453f4-a250-4f73-b82c-2825a0bda464
:END:
The target of an HTTP request is called a "resource". HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources. Each resource is identified by a Uniform Resource Identifier (URI), as described in [[id:9c45ae18-46b0-4acb-a478-3d3e9a3748ab][Section 2.7]] of [RFC7230].

HTTP 请求的目标，被称为“[[ruby:resource][资源]]”。HTTP 并不限制一个资源的性质，它仅仅定义了一个可以用来对资源进行交互的接口。每一个资源都被一个[[ruby:Uniform%20Resource%20Identifier][统一资源标识符（URI）]]所标识，见[[id:9c45ae18-46b0-4acb-a478-3d3e9a3748ab][【RFC7230】章节 2.7]]。

When a client constructs an HTTP/1.1 request message, it sends the target URI in one of various forms, as defined in ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]). When a request is received, the server reconstructs an effective request URI for the target resource ([[id:3265c21d-0d3b-4776-8e28-38278d168779][Section 5.5]] of [RFC7230]).

当客户端[[ruby:construct][构建]]一个 HTTP/1.1 请求消息的时候，它将某种形式的[[ruby:target%20URI][目标 URI]] 包含在消息中，见[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]。当服务器接收到一个请求的时候，它将[[ruby:reconstruct][重新构建]]出一个[[ruby:effective%20request%20URI][有效请求 URI]]（见[[id:3265c21d-0d3b-4776-8e28-38278d168779][【RFC7230】章节 5.5]]）来定位[[ruby:target%20resource][目标资源]]。

#+BEGIN_QUOTE
译注：目标 URI 有四种形式：[[ruby:origin-form][原始形式]]、[[ruby:absolute-form][绝对形式]]、[[ruby:authority-form][权威形式]]、[[ruby:asterisk-form][星号形式]]，详情见[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]。
#+END_QUOTE

One design goal of HTTP is to separate resource identification from request semantics, which is made possible by vesting the request semantics in the request method ([[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][Section 4]]) and a few request-modifying header fields ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]). If there is a conflict between the method semantics and any semantic implied by the URI itself, as described in Section 4.2.1, the method semantics take precedence.

HTTP 的设计目标之一是将[[ruby:resource%20identification][资源识别]]与请求语义相分离，使得请求语义全部归属于[[ruby:request%20method][请求方法]]（[[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][章节 4]]）以及几个[[ruby:request-modifying%20header%20fields][请求修饰头字段]]（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）。如果方法语义与 URI 自身所暗含的语义相冲突，正如[[id:2f967e3d-8694-430b-ad06-e748fd39b281][章节 4.2.1]] 所述，优先使用方法语义。

* 3. 资源的表示形式 / Representations
:PROPERTIES:
:ID:       7dd837af-fd6a-4918-9c62-cf12a4c31522
:END:
#+BEGIN_QUOTE
Considering that a resource could be anything, and that the uniform interface provided by HTTP is similar to a window through which one can observe and act upon such a thing only through the communication of messages to some independent actor on the other side, an abstraction is needed to represent ("take the place of") the current or desired state of that thing in our communications. That abstraction is called a representation [REST].
#+END_QUOTE

考虑到[[ruby:resource][资源]]可以是任何事物，而 HTTP 所提供的统一接口类似于一个窗口，在窗口的一边我们能够对该事物进行观察；而要想对该事物采取行动的话，只能通过消息沟通来让窗口另一边的某个独立的动作执行者来完成。因此，在沟通过程中，我们需要一种“抽象”来[[ruby:represent][表示]]（代替）该事物的[[ruby:current%20state][当前状态]]或[[ruby:desired%20state][期望状态]]。而这种“抽象”被称为[[ruby:representation][资源的表示形式]]【[[http://roy.gbiv.com/pubs/dissertation/top.htm][REST]]】。

#+BEGIN_QUOTE
译注：术语 "representation" 一词源自一种软件架构风格的术语—— REST（Representational Style Transfer），也就是我们常常听到的 RESTful 风格。[[ruby:representation][资源的表示形式]]是[[ruby:resource][资源]]的抽象，资源一般是唯一的，而资源的表示形式可以多种多样，例如，一份银行流水账单可以认为是一种资源，按媒体类型来分，它的表示形式可以有 JSON、XML 或者二进制格式等，按时间来分，它的表示形式可以有昨日收支、今日收支、本用收支等，更详细的介绍可以[[http://roy.gbiv.com/pubs/dissertation/rest_arch_style.htm][查看这里]]。
#+END_QUOTE

#+BEGIN_QUOTE
For the purposes of HTTP, a "representation" is information that is intended to reflect a past, current, or desired state of a given resource, in a format that can be readily communicated via the protocol, and that consists of a set of representation metadata and a potentially unbounded stream of representation data.
#+END_QUOTE

基于 HTTP 的目的，[[ruby:representation][资源的表示形式]]是一种信息，该信息用于反映某个给定资源的过去、现在、或将来期望的状态。它以一种能够轻易地经由协议进行传达的格式，并由一系列 [[ruby:representation%20metadata][元数据]]以及一个可能是无限大的 [[ruby:representation%20data][数据]]（流）组成。

#+BEGIN_QUOTE
译注：再强调一次，[[ruby:representation][资源的表示形式]]是资源的一种抽象，反映的是资源的状态，资源一般有多种状态。引用上面提到的银行流水账单的例子，JSON 形式的表示是它的一种状态，它也可以转变为 XML 形式（状态过渡）。每一种状态由一种资源的表示形式来表示，因此，资源与资源的表示形式是一对多的关系。

下文会多次提及到[[ruby:current%20representation][资源的当前表现形式]]，它反映了资源的[[ruby:current%20state][当前状态]]，怎么理解呢？还是拿账单的例子，假设有两个接口，一个接口 A 用来获取今天的总支出，另一个接口 B 用来提交支出。

- 第一次调用接口 A，返回总支出为 50 元，50 元反映了该接口所对应的资源的当前状态；
- 调用接口 B 提交一条支出 5 元的数据，这时数据库新增了一条记录，资源的状态发生改变；
- 每二次调用接口 A，返回总支出为 55 元，55 元反映了该接口所对应的资源的当前状态；

另外，[[ruby:current%20representation][资源的当前表现形式]]也可以同时有多种，可以这样理解：资源的当前状态可以有多种表现形式。例如接口 A 默认返回的是文本类型，但它还有一个参数 =filetype= 可以让接口调用者指定返回的数据类型，例如 JSON，那么，文本类型和 JSON 类型的总支出信息皆为接口 B 所对应的资源的当前表现形式。 
#+END_QUOTE

#+BEGIN_QUOTE
译注：[[ruby:representation][资源的表现形式]]由表现形式的[[ruby:representation%20data][数据]]和[[ruby:representation%20metadata][元数据]]组成。资源的表现形式的数据，即资源本身的数据表示；而资源的表现形式的元数据，是用来描述资源的表现形式（或者描述资源的表现形式元数据自身）的，所以叫作“元数据”。
#+END_QUOTE

#+BEGIN_QUOTE
An origin server might be provided with, or be capable of generating, multiple representations that are each intended to reflect the current state of a target resource. In such cases, some algorithm is used by the origin server to select one of those representations as most applicable to a given request, usually based on content negotiation. This "selected representation" is used to provide the data and metadata for evaluating conditional requests [RFC7232] and constructing the payload for 200 (OK) and 304 (Not Modified) responses to GET ([[id:698bab73-07b1-4349-8a03-5a4a89d966d8][Section 4.3.1]]).
#+END_QUOTE

[[ruby:origin%20server][源服务器]]可能被赋予提供或生成多种[[ruby:representations][资源的表示形式]]的能力，每种表示形式旨在反映[[ruby:target%20resource][目标资源]]的当前状态。在这种情况下，源服务器会使用某些算法（通常会基于[[ruby:content%20negotiation][内容协商]]）来选定其中一种对于给定请求来说是最适合的表现形式。这个“[[ruby:selected%20representation][已选定的表现形式]]”是用来为[[ruby:evaluating%20conditional%20requests][评估条件请求]]提供数据和元数据，以及为响应给 GET 请求（[[id:698bab73-07b1-4349-8a03-5a4a89d966d8][章节 4.3.1]]）的 =200 (OK)= 和 =304 (Not Modified)= 响应消息构建[[ruby:payload][有效载荷]]。

** 3.1. 表示形式元数据 / Representation Metadata
:PROPERTIES:
:ID:       49e0f329-4c0c-4a07-8c8e-666de785c97e
:END:
#+BEGIN_QUOTE
Representation header fields provide metadata about the representation. When a message includes a payload body, the representation header fields describe how to interpret the representation data enclosed in the payload body. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the payload body if the same request had been a GET.
#+END_QUOTE

与表示形式相关的头字段提供了表示形式的元数据。当一个[[ruby:message][消息]]包含一个[[ruby:payload%20body][有效载荷]]时，这些头字段描述了如何解释这个封装在有效载荷内的[[ruby:representation%20data][表示形式数据]]。在一个回应给 HEAD 请求的响应消息里，这些头字段描述了如果相同的请求是一个 GET 请求的话，将会如何解释这个封装在有效载荷内的[[ruby:representation%20data][表示形式数据]]。

#+BEGIN_QUOTE
The following header fields convey representation metadata:
#+END_QUOTE

以下头字段负责传达[[ruby:representation%20metadata][表示形式元数据]]：

| header Field Name | Defined in...   |
|-------------------+-----------------|
| Content-Type      | [[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][Section 3.1.1.5]] |
| Content-Encoding  | [[id:a10adb00-e955-42a6-8d28-ed6f942db085][Section 3.1.2.2]] |
| Content-Language  | [[id:80f3e8e8-dabb-49b8-b7e6-45f83648a732][Section 3.1.3.2]] |
| Content-Location  | [[id:91650144-4bfc-4362-b628-f96578a5c756][Section 3.1.4.2]] |

*** 3.1.1. 处理表示形式数据 / Processing Representation Data
**** 3.1.1.1. 媒体类型 / Media Type
:PROPERTIES:
:ID:       bc05d462-378f-4743-a1ee-543e01064a09
:END:
#+BEGIN_QUOTE
HTTP uses Internet media types [[[https://tools.ietf.org/html/rfc2046][RFC2046]]] in the =Content-Type= ([[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][Section 3.1.1.5]]) and =Accept= ([[id:95575604-c3d4-48d6-a061-325bd7798970][Section 5.3.2]]) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with each context in which it is received.
#+END_QUOTE

为了提供开放、可扩展的[[ruby:data%20typing][数据分类]]和[[ruby:type%20negotiation][类型协商]]，HTTP 在 =Content-Type= （[[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][章节 3.1.1.5]]）和 =Accept= （[[id:95575604-c3d4-48d6-a061-325bd7798970][章节 5.3.2]]）头字段中使用[[ruby:Internet%20media%20types][互联网媒体类型]][[https://tools.ietf.org/html/rfc2046][【RFC2046】]]。媒体类型定义了数据的格式及其各种处理模型，即如何根据接收数据的各个场景来处理该数据。

#+BEGIN_SRC text
  media-type = type "/" subtype *( OWS ";" OWS parameter )
  type       = token
  subtype    = token
#+END_SRC

#+BEGIN_QUOTE
The =type/subtype= *MAY* be followed by parameters in the form of =name=value= pairs.
#+END_QUOTE

=type/subtype= 后面 *可以* 跟着键值对 =name=value= 形式的多个参数。

#+BEGIN_SRC text
  parameter      = token "=" ( token / quoted-string )
#+END_SRC

#+BEGIN_QUOTE
The =type=, =subtype=, and =parameter name= tokens are case-insensitive. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name. The presence or absence of a parameter might be significant to the processing of a media-type, depending on its definition within the media type registry.
#+END_QUOTE

上面 ABNF 列出的规则里，=type=、=subtype= 以及 =parameter= 的 =name= 这三个 token（标记）是不区分大小写的。=parameter= 的 =value= 不一定区分大小写，取决于 =parameter= 的 =name= 的语义。一个 =parameter= 的出现与否可能会对一个媒体类型的处理有重要意义，取决于该 =parameter= 在[[ruby:media%20type%20registry][媒体类型注册表]]里的定义。

#+BEGIN_QUOTE
A parameter value that matches the token production can be transmitted either as a token or within a quoted-string. The quoted and unquoted values are equivalent. For example, the following examples are all equivalent, but the first is preferred for consistency:
#+END_QUOTE

如果 =parameter= 的 =value= 符合 [[id:d0012483-93a3-44cf-b019-29e12725d94a][token]] 的语法规则的话，那么，它既可以直接作为标记来传输，也可以用在[[ruby:quoted-string][双引号字符串]]里。使用双引号包裹与否都是等价的。例如，以下例子都是等价的，但是为了一致性，应优先使用第一种：

#+BEGIN_QUOTE
译注：token，标记、记号，编程语言中的变量名、常量名就是 token，token 在 ABNF 中有明确的定义，它的命名不能出现某些特殊字符，详情见[[id:d0012483-93a3-44cf-b019-29e12725d94a][【RFC7230】章节 3.2.6]]。
#+END_QUOTE

#+BEGIN_EXAMPLE
  text/html;charset=utf-8
  text/html;charset=UTF-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
#+END_EXAMPLE

#+BEGIN_QUOTE
Internet media types ought to be registered with IANA according to the procedures defined in [[[https://tools.ietf.org/html/rfc6838][BCP13]]].
#+END_QUOTE

应该按照[[https://tools.ietf.org/html/rfc6838][【BCP13】]]所定义的流程，将[[ruby:Internet%20media%20types][互联网媒体类型]]注册在 IANA 里。

#+BEGIN_QUOTE
*Note:* Unlike some similar constructs in other header fields, media type parameters do not allow whitespace (even "bad" whitespace) around the "=" character.
#+END_QUOTE

*注意：* 不像其他头字段里的某些类似结构，媒体类型的参数不允许在等号（"="）两边带有空格（即使是 [[id:f26527b6-d15c-4967-97e3-acc669609481][BWS]] 也不允许）。

**** 3.1.1.2. 字符集 / Charset
:PROPERTIES:
:ID:       dc31dd72-3e53-4fb1-b3a6-e6716f61b202
:END:
#+BEGIN_QUOTE
HTTP uses charset names to indicate or negotiate the character encoding scheme of a textual representation [[[https://tools.ietf.org/html/rfc2978][RFC6365]]]. A charset is identified by a case-insensitive token.
#+END_QUOTE

HTTP 使用[[ruby:charset%20names][字符集名称]]来表明或协商一个文本类型的[[ruby:representation][表现形式]]的[[ruby:character%20encoding%20scheme][字符编码方案]]【[[https://tools.ietf.org/html/rfc6365][RFC6365]]】。字符集由一个不区分大小写的[[ruby:token][标记]]来标识。

#+BEGIN_SRC text
  charset = token
#+END_SRC

#+BEGIN_QUOTE
Charset names ought to be registered in the IANA "Character Sets" registry (<http://www.iana.org/assignments/character-sets>) according to the procedures defined in [RFC2978].
#+END_QUOTE

应该按照定义在[[https://tools.ietf.org/html/rfc2978][【RFC2978】]]的流程，将[[ruby:charset%20names][字符集名称]]注册在 IANA 的 "Character Sets" 注册表里。

**** 3.1.1.3. 规范化和文本缺省 / Canonicalization and Text Defaults
#+BEGIN_QUOTE
Internet media types are registered with a canonical form in order to be interoperable among systems with varying native encoding formats. Representations selected or transferred via HTTP ought to be in canonical form, for many of the same reasons described by the Multipurpose Internet Mail Extensions (MIME) [[[https://tools.ietf.org/html/rfc2045][RFC2045]]]. However, the performance characteristics of email deployments (i.e., store and forward messages to peers) are significantly different from those common to HTTP and the Web (server-based information services). Furthermore, MIME's constraints for the sake of compatibility with older mail transfer protocols do not apply to HTTP (see [[id:84208afd-e458-4f40-97cc-2e9535523797][Appendix A]]).
#+END_QUOTE

[[ruby:Internet%20media%20types][互联网媒体类型]]是使用一种[[ruby:canonical%20form][规范形式]]来注册的，以便于在具有不同本地编码格式的系统之间能够相互操作。经由 HTTP 来选择或传输的[[ruby:representations][资源表示形式]]应该使用规范形式，其原因已经在[[ruby:Multipurpose%20Internet%20Mail%20Extensions][多用途互联网邮件扩展]]（MIME）【[[https://tools.ietf.org/html/rfc2045][RFC2045]]】里描述过了。然而，电子邮件调度（即存储和转发消息到其他对方）的性能特征跟在 HTTP 和 Web（其于服务器的信息服务）中通用的性能特征有明显的区别。此外，在 MIME 里为了兼容旧的邮件传输协议所设计的约束并不适用于 HTTP（见[[id:84208afd-e458-4f40-97cc-2e9535523797][附录 A]]）。

#+BEGIN_QUOTE
译注：canonical form (or normal form, or standard form) 的解释见 [[https://en.wikipedia.org/wiki/Canonical_form][wikipedia: Canonical form]]。
#+END_QUOTE

#+BEGIN_QUOTE
MIME's canonical form requires that media subtypes of the "text" type use =CRLF= as the text line break. HTTP allows the transfer of text media with plain =CR= or =LF= alone representing a line break, when such line breaks are consistent for an entire representation. An HTTP sender *MAY* generate, and a recipient *MUST* be able to parse, line breaks in text media that consist of =CRLF=, bare =CR=, or bare =LF=. In addition, text media in HTTP is not limited to charsets that use octets 13 and 10 for =CR= and =LF=, respectively. This flexibility regarding line breaks applies only to text within a representation that has been assigned a "text" media type; it does not apply to "multipart" types or HTTP elements outside the payload body (e.g., header fields).
#+END_QUOTE

MIME 的规范形式要求文本（"text"）类型媒体的子类型使用 =CRLF= 来作为换行符。HTTP 允许文本类型媒体单独使用 =CR= 或者 =LF= 来表示一个换行符，只要求所使用的换行符在整个[[ruby:representation][资源表示形式]]中是统一的。HTTP 发送端 *可以* 在文本类型媒体中生成由 =CRLF=、或者单纯是 =CR=、或者单纯是为 =LF= 组成的换行符。HTTP 接收端 *必须* 能够解析文本类型媒体中的由 =CRLF=、或者单纯是 =CR=、或者单纯是 =LF= 组成的换行符。而且，在 HTTP 里的文本类型媒体并不限于使用 13 作为 =CR=，10 作为 =LF= 的字符集。这种对于换行符的灵活性仅适用于声明为 "text" 媒体类型的[[ruby:representation][表示形式]]以内的文本，它并不适用于 "multipart" 类型，也不适用于有效载荷以外的 HTTP 元素（例如，头字段）。

#+BEGIN_QUOTE
If a representation is encoded with a content-coding, the underlying data ought to be in a form defined above prior to being encoded.
#+END_QUOTE

如果一种[[ruby:representation][表示形式]]使用了一种[[ruby:content-coding][内容编码值]]来编码，[[ruby:underlying%20data][基础数据]]应该在编码之前处于上述定义的那种规范形式。

#+BEGIN_QUOTE
译注："underlying data" 译为基础数据，指的是在编码之前的原始数据。
#+END_QUOTE

**** 3.1.1.4. Multipart 类型 / Multipart Types
MIME provides for a number of "multipart" types — encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in [[https://tools.ietf.org/html/rfc2046#section-5.1.1][Section 5.1.1]] of [RFC2046], and include a =boundary= parameter as part of the media type value. The message body is itself a protocol element; a sender *MUST* generate only =CRLF= to represent line breaks between body parts.

MIME 提供了大量的 "multipart" 类型，即在单独一个[[ruby:message%20body][消息体]]里封装了一个或多个[[ruby:representations][表示形式]]。所有 "multipart" 类型共享一个通用的句法（见[[https://tools.ietf.org/html/rfc2046#section-5.1.1][【RFC2046】章节 5.1.1]]），并且包含一个 =boundary= 参数作为媒体类型的值的一部分。消息体本身就是一个协议元素，发送端 *必须* 在消息体的各个[[ruby:parts][分部]]之间仅生成 =CRLF= 来表示换行符。

#+BEGIN_QUOTE
译注：multipart 允许在一个消息体里包含多个 representation，每个 representation 之间使用 =boundary= 所指定的定界符来分隔，这样就使得消息体被分割为多个分部，分部与分部之间的内容仍然只能使用 =CRLF= 作为换行符。multipart 的一个例子可以参考[[https://tools.ietf.org/html/rfc2049#page-15][【RFC2049】附录 A]]。
#+END_QUOTE

HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the payload. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in [[[https://tools.ietf.org/html/rfc2388][RFC2388]]], and the "multipart/byteranges" type is defined by this specification for use in some =206 (Partial Content)= responses [[[https://tools.ietf.org/html/rfc7233][RFC7233]]].

HTTP [[ruby:message%20framing][消息分帧]] 并不会使用 multipart 的 =boundary= 作为消息体长度的一个标识符，虽然它可能被[[ruby:implementations][实现]]用于生成或处理有效载荷。例如，"multipart/form-data" 类型通常用于在一个请求里携带表单数据，如【[[https://tools.ietf.org/html/rfc2388][RFC2388]]】所述。"multipart/byteranges" 类型是由本规范所定义的，用在某些 =206 (Partial Content)= 响应里【[[https://tools.ietf.org/html/rfc7233][RFC7233]]】。

**** 3.1.1.5. Content-Type
:PROPERTIES:
:ID:       fcfdf1e4-f733-4305-9ad4-761271a3dd69
:END:
#+BEGIN_QUOTE
The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by =Content-Encoding= are decoded.
#+END_QUOTE

=Content-Type= 头字段指明了它所关联的[[ruby:representation][表示形式]]的媒体类型。所述“关联的表示形式”，是封装在消息有效载荷内的表示形式或者[[ruby:selected%20representation][已选定的表示形式]]，由消息语义所决定。 =Content-Type= 所指定的媒体类型定义了[[ruby:representation][表示形式]]的数据格式以及期望该数据被接收端如何处理，在该消息的语义范围之内，在依照 =Content-Encoding= 里的所有内容编码进行解码之后。

#+BEGIN_SRC text
  Content-Type = media-type
#+END_SRC

#+BEGIN_QUOTE
Media types are defined in [[id:bc05d462-378f-4743-a1ee-543e01064a09][Section 3.1.1.1]]. An example of the field is
#+END_QUOTE

媒体类型定义在[[id:bc05d462-378f-4743-a1ee-543e01064a09][章节 3.1.1.1]]。以下是 =Content-Type= 头字段的一个例子：

#+BEGIN_SRC text
  Content-Type: text/html; charset=ISO-8859-4
#+END_SRC

#+BEGIN_QUOTE
A sender that generates a message containing a payload body *SHOULD* generate a =Content-Type= header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a =Content-Type= header field is not present, the recipient *MAY* either assume a media type of "application/octet-stream" ([RFC2046], [[https://tools.ietf.org/html/rfc2046#section-4.5.1][Section 4.5.1]]) or examine the data to determine its type.
#+END_QUOTE

如果发送端所生成的消息包含有一个有效载荷，那么发送端 *应当* 在该消息里生成一个 =Content-Type= 头字段，除非它并不知道应该对封装在有效载荷内的[[ruby:representation][表示形式]]指定哪一种媒体类型。如果没有出现 =Content-Type= 头字段，接收端 *可以* 要不假定为 "application/octet-stream" 媒体类型（[[https://tools.ietf.org/html/rfc2046#section-4.5.1][【RFC2046】章节 4.5.1]]），要不检查该数据来确定它的媒体类型。

#+BEGIN_QUOTE
In practice, resource owners do not always properly configure their origin server to provide the correct =Content-Type= for a given representation, with the result that some clients will examine a payload's content and override the specified type. Clients that do so risk drawing incorrect conclusions, which might expose additional security risks (e.g., "privilege escalation"). Furthermore, it is impossible to determine the sender's intent by examining the data format: many data formats match multiple media types that differ only in processing semantics. Implementers are encouraged to provide a means of disabling such "content sniffing" when it is used.
#+END_QUOTE

实际上，[[ruby:resource%20owners][资源所有者]]并不总是能恰当地配置它们的源服务器来为一个给定的[[ruby:representation][表示形式]]提供正确的 =Content-Type=，出于这种原因，某些客户端会检查有效载荷的内容然后[[ruby:override][重写]]指定的类型。但是，客户端这样做可能会得出错误的论断，从而可能会暴露出额外的安全风险（例如，[[ruby:privilege%20escalation][特权提升]]）。而且，通过检查数据格式是不可能确定发送端的真正意图的，这是由于某些数据格式能够匹配多种媒体类型，而仅在语义处理会有所不同。鼓励实现者提供一种方法，当启用这种方法的时候可以禁用上述这种“[[ruby:content%20sniffing][内容嗅探]]”。

#+BEGIN_QUOTE
译注：特权提升的详细介绍见 [[https://en.wikipedia.org/wiki/Privilege_escalation][Wikipedia: Privilege escalation]] 或者 [[https://zh.wikipedia.org/wiki/%25E7%2589%25B9%25E6%259D%2583%25E6%258F%2590%25E5%258D%2587][维基百科（中文）]]。
#+END_QUOTE

*** 3.1.2. 为压缩或完整性而编码 / Encoding for Compression or Integrity
**** 3.1.2.1. Content Codings
:PROPERTIES:
:ID:       a67acb58-7b0a-49c8-8de4-5dd8a4ab9e61
:END:
#+BEGIN_QUOTE
Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.
#+END_QUOTE

content coding 的值指明了一种已经或能够应用到一个[[ruby:representation][表示形式]]的[[ruby:encoding%20transformation][编码转换]]。content coding 主要用来允许在没有丢失[[ruby:representation][表示形式]]之前的媒体类型的身份以及没有丢失信息的情况下，对该表示形式进行压缩或者进行其他方式的转换。表示形式常常被存储为[[ruby:code%20form][编码过的形式]]，然后将其直接进行传输，最后仅到达最终接收端才会进行解码。

#+BEGIN_QUOTE
译文：本译文将 "encoding" 翻译为“编码”，为了与之区分，不会对 "content coding" 进行翻译（实际上是我不知道怎么翻译才好，意会，意会）。
#+END_QUOTE

#+BEGIN_SRC text
  content-coding   = token
#+END_SRC

#+BEGIN_QUOTE
All content-coding values are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as defined in [[id:87f2ed30-a48b-4c31-a181-8e3a33ba1080][Section 8.4]]. They are used in the =Accept-Encoding= ([[id:a8fcc101-3782-4ed0-aec0-561b933e6a5f][Section 5.3.4]]) and =Content-Encoding= ([[id:a10adb00-e955-42a6-8d28-ed6f942db085][Section 3.1.2.2]]) header fields.
#+END_QUOTE

所有 =content-coding= 的值都是不区分大小写的，并且应该注册到 "HTTP Content Coding Registry" 注册表里，如[[id:87f2ed30-a48b-4c31-a181-8e3a33ba1080][章节 8.4]] 所述。它们用在 =Accept-Encoding= （[[id:a8fcc101-3782-4ed0-aec0-561b933e6a5f][章节 5.3.4]]）和 =Content-Encoding= （[[id:a10adb00-e955-42a6-8d28-ed6f942db085][章节 3.1.2.2]]）头字段里。

#+BEGIN_QUOTE
The following content-coding values are defined by this specification:
- compress (and x-compress): See [[id:a785a05f-6fdc-44d8-9343-3a66a49cb655][Section 4.2.1]] of [RFC7230].
- deflate: See [[id:fa7b432f-071b-4e26-9d2c-8fc1b95b6b64][Section 4.2.2]] of [RFC7230].
- gzip (and x-gzip): See [[id:d1579c8b-312c-414b-b421-960669b0d389][Section 4.2.3]] of [RFC7230].
#+END_QUOTE

本规范定义了以下 =content-coding= 值：
- compress（以及 x-compress）：见[[id:a785a05f-6fdc-44d8-9343-3a66a49cb655][【RFC7230】章节 4.2.1]]。
- deflate：见[[id:fa7b432f-071b-4e26-9d2c-8fc1b95b6b64][【RFC7230】章节4.2.2]]。
- gzip（以及 x-gzip）：[[id:d1579c8b-312c-414b-b421-960669b0d389][【RFC7230】见章节 4.2.3]]。

**** 3.1.2.2. Content-Encoding
:PROPERTIES:
:ID:       a10adb00-e955-42a6-8d28-ed6f942db085
:END:
#+BEGIN_QUOTE
The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the =Content-Type= header field. =Content-Encoding= is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
#+END_QUOTE

=Content-Encoding= 头字段指明了已经对[[ruby:representation][表示形式]]应用了哪些突破其固有的媒体类型的 content codings，因此得知，为了获得 =Content-Type= 头字段所提及的那种媒体类型的数据，需要应用哪一种解码机制。=Content-Encoding= 主要用来允许在没有丢失[[ruby:representation][表示形式]]之前的媒体类型的身份的情况下，对一个[[ruby:representation][表示形式]]的数据进行压缩。

#+BEGIN_SRC text
  Content-Encoding = 1#content-coding
#+END_SRC

#+BEGIN_QUOTE
An example of its use is
#+END_QUOTE

它的用法见下面这个例子：

#+BEGIN_EXAMPLE
  Content-Encoding: gzip
#+END_EXAMPLE

#+BEGIN_QUOTE
If one or more encodings have been applied to a representation, the sender that applied the encodings *MUST* generate a =Content-Encoding= header field that lists the content codings in the order in which they were applied. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
#+END_QUOTE

如果对一个[[ruby:representation][表示形式]]应用了一种或多种编码，应用这些编码的发送端 *必须* 生成一个 =Content-Encoding= 头字段，以它们被应用的先后顺序来一一列出对应的 content codings。如果某种编码需要附带额外的参数信息，可以由其他未在本规范上定义过的头字段来提供。

#+BEGIN_QUOTE
Unlike =Transfer-Encoding= ([[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][Section 3.3.1]] of [RFC7230]), the codings listed in =Content-Encoding= are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.
#+END_QUOTE

不像 =Transfer-Encoding= （[[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][【RFC7230】章节 3.3.1]]），列在 =Content-Encoding= 头字段上的 codings 是[[ruby:representation][表示形式]]的特性。[[ruby:representation][表示形式]]是依据其编码过的形式来进行定义的。除非在元数据的定义中另有注明，所有与表示形式相关的其他元数据皆为对这种编码过的形式进行描述的。通常，[[ruby:representation][表示形式]]仅在渲染呈现或类似的用途之前才会被解码。

#+BEGIN_QUOTE
If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in =Content-Encoding= even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of =Content-Type= or =Content-Encoding=, since some user agents will behave differently in their handling of each response (e.g., open a "Save as ..." dialog instead of automatic decompression and rendering of content).
#+END_QUOTE

如果媒体类型包含有一种[[ruby:inherent%20encoding][固有的编码]]，例如一种总是以压缩方式来表示的数据格式，那么，这种编码不要在 =Content-Encoding= 里重申，哪怕它恰巧与其中一个 content codings 的算法一致。这种 content coding 只会在以下这种情况下才需要在 =Content-Encoding= 列出：出于某些怪异的原因，需要应用该 content coding 两次才能形成正确的[[ruby:representation][表示形式]]。同样，原服务器可能选择将该同样的数据作为[[ruby:multiple%20representations][多种表示形式]]来发布，其区别仅在于 coding 是作为 =Content-Type= 的一部分还是作为 =Content-Encoding= 的一部分 ，这是因为某些用户代理处理各个响应的行为会有所不同（例如，打开一个“另存为...”对话框，而不是自动解缩并渲染内容）。

#+BEGIN_QUOTE
An origin server *MAY* respond with a status code of =415 (Unsupported Media Type)= if a representation in the request message has a content coding that is not acceptable.
#+END_QUOTE

如果请求消息里的[[ruby:representation][表示形式]]应用了服务器不支持的 content coding，源服务器 *可以* 以 =415 (Unsupported Media Type)= 作为响应。

*** 3.1.3. 受众语言 / Audience Language
**** 3.1.3.1. 语言标签 / Language Tags
:PROPERTIES:
:ID:       0a52652d-e5e8-40f9-ba1a-f96c45969b85
:END:
#+BEGIN_QUOTE
A language tag, as defined in [[[https://tools.ietf.org/html/rfc5646][RFC5646]]], identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.
#+END_QUOTE

正如【[[https://tools.ietf.org/html/rfc5646][RFC5646]]】所定义，[[ruby:language%20tag][语言标签]]标识了一种人类出于交流信息的目的而通过说、写或其他方式来传达的自然语言。计算机语言被明确排除在外。

#+BEGIN_QUOTE
HTTP uses language tags within the =Accept-Language= and =Content-Language= header fields. =Accept-Language= uses the broader =language-range= production defined in Section 5.3.5, whereas =Content-Language= uses the =language-tag= production defined below.
#+END_QUOTE

HTTP 在 =Accept-Language= 和 =Content-Language= 头字段里使用语言标签。=Accept-Language= 使用了更广义的 =language-range= 规则（定义在章节 5.3.5），而 =Content-Language= 使用了 =language-tag= 规则，其定义如下：

#+BEGIN_SRC text
  language-tag = <Language-Tag, see [RFC5646], Section 2.1>
#+END_SRC

#+BEGIN_QUOTE
A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada). Whitespace is not allowed within a language tag. Example tags include:
#+END_QUOTE

一个[[ruby:language%20tag][语言标签]]是由一个或多个不区分大小写的子标签组成的，每个子标签之间使用连接符（"-"，"%x2D"）分隔。大多数情况下，一个语言标签包含一个标识了某种关联语系的[[ruby:primary%20language%20subtag][主要语言子标签]]（例如，"en" 代表[[ruby:English][英语]]），另外还可以选择性地在其后面附加一连串的子标签来优化或缩小语言范围（例如，"en-CA" 代表一种[[ruby:Canada][加拿大]]英语）。语言标签里不允许存在空格。语言标签的几个例子如下：

#+BEGIN_EXAMPLE
  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
#+END_EXAMPLE

#+BEGIN_QUOTE
See [[[https://tools.ietf.org/html/rfc5646][RFC5646]]] for further information.
#+END_QUOTE

更多信息见【[[https://tools.ietf.org/html/rfc5646][RFC5616]]】。

**** 3.1.3.2. Content-Language
:PROPERTIES:
:ID:       80f3e8e8-dabb-49b8-b7e6-45f83648a732
:END:
#+BEGIN_QUOTE
The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.
#+END_QUOTE

=Content-Language= 头字段描述了[[ruby:representation][资源表示形式]]的目标受众的（一种或多种）自然语言。需要注意的是，它可能并不等价于用在[[ruby:representation][表示形式]]里的所有语言。

#+BEGIN_SRC text
  Content-Language = 1#language-tag
#+END_SRC

#+BEGIN_QUOTE
Language tags are defined in [[id:0a52652d-e5e8-40f9-ba1a-f96c45969b85][Section 3.1.3.1]]. The primary purpose of =Content-Language= is to allow a user to identify and differentiate representations according to the users' own preferred language. Thus, if the content is intended only for a Danish-literate audience, the appropriate field is
#+END_QUOTE

[[ruby:language%20tag][语言标签]]定义在[[id:0a52652d-e5e8-40f9-ba1a-f96c45969b85][章节 3.1.3.1]] 里。=Content-Language= 的主要目的是让用户能够依据自身的首选语言来标识和区分[[ruby:representation][表示形式]]。所以，如果只想将[[ruby:Danish-literate][懂丹麦语]]的人作为内容的目标受众，那么头字段可以这样设置：

#+BEGIN_EXAMPLE
  Content-Language: da
#+END_EXAMPLE

#+BEGIN_QUOTE
If no =Content-Language= is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
#+END_QUOTE

如果没有指定 =Content-Language= 头字段，那么就默认内容是面向所有语言受众的。这可能意味着发送端并不认为它自已是面向具体任一种自然语言的，或者发送端并不知道它自己打算使用哪一种语言。

#+BEGIN_QUOTE
Multiple languages *MAY* be listed for content that is intended for multiple audiences. For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for
#+END_QUOTE

对于面向多种受众的内容，*可以* 在 =Content-Language= 列出多种语言，多种语言，例如，一份“[[ruby:Treaty%20of%20Waitangi][怀唐伊条约]]”的译文，会同时出现[[ruby:original%20Maori][毛利语原文]]以及英文版本，那么可以这样设置：

#+BEGIN_EXAMPLE
  Content-Language: mi, en
#+END_EXAMPLE

#+BEGIN_QUOTE
However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the =Content-Language= would properly only include "en".
#+END_QUOTE

然而，只因为在一个[[ruby:representation][表示形式]]里出现了多种语言就认为它是打算面向认识多种语言的受众，这是错误的。举个例子，一本面向新手的语言入门读物，就称为《第一堂拉丁语课》吧，是明确打算面向懂英语的读者的，那么，最恰当的做法是 =Content-Language= 只包含 "en"。

#+BEGIN_QUOTE
=Content-Language= *MAY* be applied to any media type — it is not limited to textual documents.
#+END_QUOTE

=Content-Language= 可以应用于任意[[ruby:media%20type][媒体类型]] 的[[ruby:representation][表示形式]]里，也就是说，它并不仅限于[[ruby:textual%20documents][文本类的文档]]。

*** 3.1.4. 标识 / Identification
**** 3.1.4.1. 标识一种表示形式 / Identifying a Representation
#+BEGIN_QUOTE
When a complete or partial representation is transferred in a message payload, it is often desirable for the sender to supply, or the recipient to determine, an identifier for a resource corresponding to that representation.
#+END_QUOTE

当一个完整的或部分的 representation 被传入到一个[[ruby:message%20payload][消息的有效载荷]]里，该 representation 所对应的资源标识符通常交由发送端去提供，或者交由接收端去决定会更好一些。

#+BEGIN_QUOTE
For a request message:
- If the request has a =Content-Location= header field, then the sender asserts that the payload is a representation of the resource identified by the =Content-Location= field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification). The information might still be useful for revision history links.
- Otherwise, the payload is unidentified.
#+END_QUOTE

对于一个请求消息来说：
- *如果* 该请求有一个 =Content-Location= 头字段，意味着发送端[[ruby:assert][断言]]请求消息的有效载荷是某个资源的一个 representation，而该资源是由 =Content-Location= 的值所标识的。但是，除非这种[[ruby:assertion][断言]]能够通过其他途径（本规则并没有定义有什么途径）来验证，否则不能相信该断言。对于修正历史链接，该信息还是有用的。
- *否则*，该请求消息的有效载荷是[[ruby:unidentified][未标识]]的。

#+BEGIN_QUOTE
For a response message, the following rules are applied in order until a match is found:
1. If the request method is GET or HEAD and the response status code is =200 (OK)=, =204 (No Content)=, =206 (Partial Content)=, or =304 (Not Modified)=, the payload is a representation of the resource identified by the effective request URI ([[id:3265c21d-0d3b-4776-8e28-38278d168779][Section 5.5]] of [RFC7230]).
2. If the request method is GET or HEAD and the response status code is =203 (Non-Authoritative Information)=, the payload is a potentially modified or enhanced representation of the target resource as provided by an intermediary.
3. If the response has a =Content-Location= header field and its field-value is a reference to the same URI as the effective request URI, the payload is a representation of the resource identified by the effective request URI.
4. If the response has a =Content-Location= header field and its field-value is a reference to a URI different from the effective request URI, then the sender asserts that the payload is a representation of the resource identified by the =Content-Location= field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification).
5. Otherwise, the payload is unidentified.
#+END_QUOTE

对于一个响应消息来说，以下规则会被按顺序应用，直到匹配其中之一：
1. *如果* 请求方法是 GET 或者 HEAD，且响应状态码是 =200 (OK)=、=204 (No Content)=、=206 (Partial Content)= 或者 =304 (Not Modified)=，那么，响应消息的有效载荷是某个资源的 representation，而该资源是由[[ruby:effective%20request%20URI][有效请求 URI]] 所标识的（[[id:3265c21d-0d3b-4776-8e28-38278d168779][【RFC7230】章节 5.5]]）。
2. *如果* 请求方法是 GET 或者 HEAD，且响应状态码是 =203 (Non-Authoritative Information)=，那么，响应消息的有效载荷是某个资源的 可能已被修改过或增强过的 representation，该 representation 由某个中间人提供。
3. *如果* 响应带有一个 =Content-Location= 头字段并且它的字段值是一个跟[[ruby:effective%20request%20URI][有效请求 URI]] 相同的 URI 引用，那么，响应消息的有效载荷是某个资源的 representation，而该资源是由有效请求 URI 所标识的。
4. *如果* 响应带有一个 =Content-Location= 头字段并且它的字段值是一个跟[[ruby:effective%20request%20URI][有效请求 URI]] 不相同的 URI 引用，那么，发送端断言该有效载荷是某个资源的 representation，而该资源是由 =Content-Location= 的字段值所标识的。但是，除非这种[[ruby:assertion][断言]]能够通过其他途径（本规则并没有定义有什么途径）来验证，否则不能相信该断言。
5. *否则*，该响应消息的有效载荷是未标识的。

**** 3.1.4.2. Content-Location
:PROPERTIES:
:ID:       91650144-4bfc-4362-b628-f96578a5c756
:END:
#+BEGIN_QUOTE
The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a 200 (OK) response would contain the same representation that is enclosed as payload in this message.
#+END_QUOTE

=Content-Location= 头字段是一个 URI，该 URI 可以作为一种标识符来标识与封装在消息的有效载荷内的[[ruby:representation][资源表示形式]]所对应的具体资源。换句话说，如果某个用户代理对这个 URI 执行了 GET 请求，那么会回应一个 =200 (OK)= 响应消息，该响应消息的有效载荷会封装相同的[[ruby:representation][表示形式]]。

#+BEGIN_SRC text
  Content-Location = absolute-URI / partial-URI
#+END_SRC

#+BEGIN_QUOTE
The =Content-Location= value is not a replacement for the effective Request URI ([[id:3265c21d-0d3b-4776-8e28-38278d168779][Section 5.5]] of [RFC7230]). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in [[https://tools.ietf.org/html/rfc2557#section-4][Section 4]] of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.
#+END_QUOTE

=Content-Location= 的值并不是用来替换[[ruby:effective%20request%20URI][有效请求 URI]]（[[id:3265c21d-0d3b-4776-8e28-38278d168779][【RFC7230】章节 5.5]]）的。它是一种[[ruby:representation%20metadata][表示形式元数据]]。它具有与定义在 MIME 的同名头字段（[[https://tools.ietf.org/html/rfc2557#section-4][【RFC2557】章节 4]]）相同的句法和语义。但是，这个头字段出现在一个 HTTP 消息里是具有特殊含义的。

#+BEGIN_QUOTE
If =Content-Location= is included in a =2xx (Successful)= response message and its value refers (after conversion to absolute form) to a URI that is the same as the effective request URI, then the recipient *MAY* consider the payload to be a current representation of that resource at the time indicated by the message origination date. For a GET ([[id:698bab73-07b1-4349-8a03-5a4a89d966d8][Section 4.3.1]]) or HEAD ([[id:d00f1692-2d40-4b09-a634-9c87fce07bc4][Section 4.3.2]]) request, this is the same as the default semantics when no =Content-Location= is provided by the server. For a state-changing request like PUT ([[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][Section 4.3.4]]) or POST ([[id:d672d01b-615b-416a-a750-0442a6901ed0][Section 4.3.3]]), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.
#+END_QUOTE

如果 =Content-Location= 被包含在一个 =2xx (Successful)= 响应消息里，且它的值指向于（在转换为[[ruby:absolute%20form][绝对形式]]之后）一个与有效请求 URI 相同的 URI，那么，接收端 *可以* 将该有效载荷认为是对应资源在特定时间里的[[ruby:current%20representation][当前表示形式]]，所述“特定时间”是指由[[ruby:message%20origination%20date][消息创始日期]]所指定的时间。对于 GET（[[id:698bab73-07b1-4349-8a03-5a4a89d966d8][章节 4.3.1]]）或者 HEAD（[[id:d00f1692-2d40-4b09-a634-9c87fce07bc4][章节 4.3.2]]）请求来说，这与在服务器没有提供 =Content-Location= 头字段的情况下的默认语义相一致。对于类似 PUT（[[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][章节 4.3.4]]）或者 POST（[[id:d672d01b-615b-416a-a750-0442a6901ed0][章节 4.3.3]]）这些会[[ruby:state-changing][改变资源状态]]的请求来说，这意味着服务器的响应包含了这个资源的新的[[ruby:representation][表示形式]]，由此与那些只报告动作方面的信息（例如，“[[ruby:It%20worked!][它生效了！]]”）的[[ruby:representations][表示形式]]作区分。让编辑程序能够在不需要再次发起 GET 请求就可以更新它们的本地副本。

#+BEGIN_QUOTE
If =Content-Location= is included in a =2xx (Successful)= response message and its field-value refers to a URI that differs from the effective request URI, then the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.
- For a response to a GET or HEAD request, this is an indication that the effective request URI refers to a resource that is subject to content negotiation and the =Content-Location= field-value is a more specific identifier for the selected representation.
- For a =201 (Created)= response to a state-changing method, a =Content-Location= field-value that is identical to the =Location= field-value indicates that this payload is a current representation of the newly created resource.
- Otherwise, such a =Content-Location= indicates that this payload is a representation reporting on the requested action's status and that the same report is available (for future access with GET) at the given URI. For example, a purchase transaction made via a POST request might include a receipt document as the payload of the =200 (OK)= response; the =Content-Location= field-value provides an identifier for retrieving a copy of that same receipt in the future.
#+END_QUOTE

如果 =Content-Location= 被包含在一个 =2xx (Successful)= 响应消息里，且它的字段值指向于一个与有效请求 URI 不相同的 URI，那么，源服务器[[ruby:claim][声称]]该 URI 是一个与封装在该有效载荷内的[[ruby:representation][表示形式]]相对应的不同资源的标识符。这种声称只能在这两个标识符具有相同的资源所有者，且该资源所有者不能经由 HTTP 以编程方式来确定的情况下才能被相信。
- 对于回应给 GET 或 HEAD 请求的一个响应，它表明：[[ruby:effective%20request%20URI][有效请求 URI]] 指向到一个服从[[ruby:content%20negotiation][内容协商]]的资源，并且针对[[ruby:selected%20representation][已选定的表示形式]]来说，=Content-Location= 的字段值是一个更加具体的标识符。
- 对于回应给[[ruby:state-changing%20method][会改变资源状态的请求方法]]的一个 =201 (Created)= 响应，如果 =Content-Location= 的字段值与 =Location= 的字段值相同，表明：这个有效载荷是新近被创建的资源的[[ruby:current%20representation][当前表示形式]]。
- 否则，这个 =Content-Location= 表明：这个有效载荷是一个对所请求的动作的状态方面进行报告的 representation，且对于给定的 URI ，同样的报告是可供使用的（用于将来 GET 请求对[[ruby:representation][表示形式]]进行访问）。例如，一个经由 POST 请求而产生的购买交易可能包含一个以一份收款凭据作为 =200 (OK)= 响应的有效载荷，=Content-Location= 的字段值提供了一个标识符，用于将来重新获取这份收款凭据的一个备份。

#+BEGIN_QUOTE
A user agent that sends =Content-Location= in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.
#+END_QUOTE

用户代理在其发送的请求消息里带有 =Content-Location= 是想表达它的字段值里的 URI 指的是用户代理最开始是在哪里获得这个封装在有效载荷内的[[ruby:representation][表示形式]]的内容的（在该用户代理对这个表示形式所作的任何更改之前）。也就是说，该用户代理提供了一种的[[ruby:back%20link][反向链接]][fn:1]来指向于[[ruby:original%20representation][原始表示形式]]的[[ruby:source][来源]]。

#+BEGIN_QUOTE
An origin server that receives a =Content-Location= field in a request message *MUST* treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server *MAY* use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server *MUST NOT* use such context information to alter the request semantics.
#+END_QUOTE

源服务器在一个请求消息中接收到 =Content-Location= 头字段的时候，*必须* 将该头字段的信息作为[[ruby:transitory%20request%20context][暂时的请求上下文]]来对待，而不是作为元数据被逐字保存来成为[[ruby:representation][资源表示形式]]的一部分。源服务器 *可以* 使用该上下文来指导请求的处理，或者将其保存起来留作其他用途，例如，用于[[ruby:source%20links][来源链接]]或[[ruby:versioning%20metadata][元数据的版本管理]]。但是，源服务器 *禁止* 使用这种上下文信息来改变该请求的语义。

#+BEGIN_QUOTE
For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the =Content-Location= cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the =Content-Location= URI.
#+END_QUOTE

例如，如果一个客户端对一个[[ruby:negotiated%20resource][协商过的资源]]发起一个 PUT 请求，并且源服务器接受了这个 PUT（没有经过[[ruby:redirection][重定向]]），那么，资源的新状态预期将与提供自该 PUT 请求的[[ruby:representation][表示形式]]相一致；PUT 请求里的 =Content-Location= 头字段不能当作是一种[[ruby:reverse%20content%20selection%20identifier][反向内容选择标识符]]来仅对协商的[[ruby:representations][表示形式]]中的其中一种进行更新。如果客户端想要后者这种语义，它可以直接对 =Content-Location= 的 URI 应用 PUT 请求。

** 3.2. 表示形式数据 / Representation Data
#+BEGIN_QUOTE
The representation data associated with an HTTP message is either provided as the payload body of the message or referred to by the message semantics and the effective request URI. The representation data is in a format and encoding defined by the representation metadata header fields.
#+END_QUOTE

与 HTTP 消息相关联的[[ruby:representation%20data][表示形式数据]]是被提供作为消息的有效载荷，或者被消息的语义和有效请求 URI 所引用。[[ruby:representation%20data][表示形式数据]]是处于某种由[[ruby:representation%20metadata][表示形式元数据]]相关的头字段所定义的格式和编码之中的。

#+BEGIN_QUOTE
The data type of the representation data is determined via the header fields =Content-Type= and =Content-Encoding=. These define a two-layer, ordered encoding model:
#+END_QUOTE

[[ruby:representation%20data][表示形式数据]]的数据类型是由 =Content-Type= 和 =Content-Encoding= 头字段决定的。它们共同定义了一种[[ruby:two-layer,%20ordered%20encoding%20model][双层的、顺序编码的模型]]：

#+BEGIN_SRC text
  representation-data := Content-Encoding( Content-Type( bits ) )
#+END_SRC

** 3.3. 有效载荷的语义 / Payload Semantics
:PROPERTIES:
:ID:       4c395bab-baa6-4895-b677-5daa1584da6e
:END:
#+BEGIN_QUOTE
Some HTTP messages transfer a complete or partial representation as the message "payload". In some cases, a payload might contain only the associated representation's header fields (e.g., responses to HEAD) or only some part(s) of the representation data (e.g., the =206 (Partial Content)= status code).
#+END_QUOTE

某些 HTTP 消息会传输一个[[ruby:complete][完整的]]或者[[ruby:partial][部分的]][[ruby:representation][资源表示形式]]来作为消息的“[[ruby:payload][有效载荷]]”。在某些情况下，一个有效载荷可能只包含[[ruby:representation][表示形式]]相关的头字段（例如，回应给 HEAD 的响应消息），或者只有表示形式的某（几）部分（例如，=206 (Partial Content)= 状态码）。

#+BEGIN_QUOTE
The purpose of a payload in a request is defined by the method semantics. For example, a representation in the payload of a PUT request ([[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][Section 4.3.4]]) represents the desired state of the target resource if the request is successfully applied, whereas a representation in the payload of a POST request ([[id:d672d01b-615b-416a-a750-0442a6901ed0][Section 4.3.3]]) represents information to be processed by the target resource.
#+END_QUOTE

对于请求消息里的有效载荷，其目的是由[[ruby:request%20method%20semantics][请求方法的语义]]来定义的。例如，在一个 PUT 请求（[[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][章节 4.3.4]]）的有效载荷内的[[ruby:representation][资源表示形式]]代表如果成功执行该请求以后，[[ruby:target%20resource][目标资源]]的预期的状态。而一个 POST 请求（[[id:d672d01b-615b-416a-a750-0442a6901ed0][章节 4.3.3]]）的有效载荷内的表示形式代表交由目标资源来处理的信息。

#+BEGIN_QUOTE
In a response, the payload's purpose is defined by both the request method and the response status code. For example, the payload of a =200 (OK)= response to GET ([[id:698bab73-07b1-4349-8a03-5a4a89d966d8][Section 4.3.1]]) represents the current state of the target resource, as observed at the time of the message origination date ([[id:5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1][Section 7.1.1.2]]), whereas the payload of the same status code in a response to POST might represent either the processing result or the new state of the target resource after applying the processing. Response messages with an error status code usually contain a payload that represents the error condition, such that it describes the error state and what next steps are suggested for resolving it.
#+END_QUOTE

在一个响应消息里，有效载荷的目的是由[[ruby:request%20method][请求方法]]和[[ruby:reponse%20status%20code][响应状态码]]两者共同来定义的。例如，一个回应给 GET 请求（[[id:698bab73-07b1-4349-8a03-5a4a89d966d8][章节 4.3.1]]）的 =200 (OK)= 响应消息表示在[[ruby:message%20origination%20date][消息创始日期]]（[[id:5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1][章节 7.1.1.2]]）所观察到的[[ruby:target%20resource][目标资源]]的目前状态。而一个回应给 POST 请求的 =200 (OK)= 响应消息可能表示：或者是在应用该请求以后的处理结果，或者是在应用该请求以后目标资源的新状态。带有一个错误状态码的响应消息通常会包含一个表示该错误条件的有效载荷，以描述错误状态以及如何解决错误的下一步建议。

#+BEGIN_QUOTE
Header fields that specifically describe the payload, rather than the associated representation, are referred to as "payload header fields". Payload header fields are defined in other parts of this specification, due to their impact on message parsing.
#+END_QUOTE

专门用于描述有效载荷（而不是描述它所关联的[[ruby:representation][表示形式]]）的头字段，被称为“[[ruby:payload%20header%20fields][有效载荷头字段]]”。有效载荷头字段被定义在本规范的其他部分中，由它们对[[ruby:message%20parsing][消息解析]]的影响来决定。

#+BEGIN_QUOTE
译注：有效载荷头字段并不是说这些头字段在有效载荷里，它们依然被放置在[[ruby:header%20section][消息头部]]里。
#+END_QUOTE

| Header Field Name | Defined in...              |
|-------------------+----------------------------|
| Content-Length    | [[id:7b3e90b9-3ae5-402b-922c-2342d361c79f][Section 3.3.2]] of [RFC7230] |
| Content-Range     | [[https://tools.ietf.org/html/rfc7233][Section 4.2]] of [RFC7233]   |
| Trailer           | [[id:5ecf5800-1004-4acb-ba25-8772abdecd5a][Section 4.4]] of [RFC7230]   |
| Transfer-Encoding | [[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][Section 3.3.1]] of [RFC7230] |

** 3.4. 内容协商 / Content Negotiation
:PROPERTIES:
:ID:       c45cb9ca-1e51-4738-8c43-231e7316ea86
:END:
#+BEGIN_QUOTE
When responses convey payload information, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings. Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver. For this reason, HTTP provides mechanisms for content negotiation.
#+END_QUOTE

响应在传达有效载荷信息的时候，无论是表达成功还是失败，源服务器通常会有多种不同的方式来表示该信息，例如，以不同的格式、语言或编码来表示。同样，不同的用户或用户代理可能有不同的能力、特性或者偏好，会影响到源服务器。也就是说，在所有可用的[[ruby:representations][表示形式]]中，究竟响应哪一种[[ruby:representation][表示形式]]才是最合适的。出于上述原因，HTTP 提供了[[ruby:content%20negotiation][内容协商]]的机制。

#+BEGIN_QUOTE
This specification defines two patterns of content negotiation that can be made visible within the protocol: "proactive", where the server selects the representation based upon the user agent's stated preferences, and "reactive" negotiation, where the server provides a list of representations for the user agent to choose from. Other patterns of content negotiation include "conditional content", where the representation consists of multiple parts that are selectively rendered based on user agent parameters, "active content", where the representation contains a script that makes additional (more specific) requests based on the user agent characteristics, and "Transparent Content Negotiation" ([[[https://tools.ietf.org/html/rfc2295][RFC2295]]]), where content selection is performed by an intermediary. These patterns are not mutually exclusive, and each has trade-offs in applicability and practicality.
#+END_QUOTE

本规范定义了两种内容协商的模式，使之能够在协议里可见：“[[ruby:proactive][主动型]]”和“[[ruby:reactive][响应式]]”。对于主动型内容协商，服务器会依据用户代理申明的偏好来选择 representation。对于响应式内容协商，服务会提供一系列的[[ruby:representations][表示形式]]供用户代理选择。其他的内容协商的模式包括：“[[ruby:conditional%20content][条件内容]]”，[[ruby:representation][表示形式]]由多个部分组成，源服务器基于用户代理的参数来选择性地渲染各个部分；“[[ruby:active%20content][活动内容]]”，[[ruby:representation][表示形式]]含有一个脚本，该脚本可以基于用户代理的特性来生成额外的（更加具体的）请求；“[[ruby:Transparent%20Content%20Negotiation][透明内容协商]]”（【[[https://tools.ietf.org/html/rfc2295][RFC2295]]】），由一个中间人来执行内容选择。这些模式不是[[ruby:mutually%20exclusive][互斥的]]，每种都有其[[ruby:applicability][适应性]]和[[ruby:practicality][实用性]]。

#+BEGIN_QUOTE
Note that, in all cases, HTTP is not aware of the resource semantics. The consistency with which an origin server responds to requests, over time and over the varying dimensions of content negotiation, and thus the "sameness" of a resource's observed representations over time, is determined entirely by whatever entity or algorithm selects or generates those responses. HTTP pays no attention to the man behind the curtain.
#+END_QUOTE

需要注意的是，不管什么情况下，HTTP 都不知道资源的语义。源服务器响应给请求所遵循的一致性，随着时间和内容协商的不同维度的变化，因然一个资源所观察到的各个[[ruby:representations][表示形式]]随着时间所表现出的“相同性”，是完全取决于实体还是算法，选择还是生成了什么响应。HTTP 并不在意幕后的人物。

*** 3.4.1. 主动型协商 / Proactive Negotiation
:PROPERTIES:
:ID:       c1d92ed4-69d5-4575-88c2-090534949ccf
:END:
#+BEGIN_QUOTE
When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called proactive negotiation (a.k.a., server-driven negotiation). Selection is based on the available representations for a response (the dimensions over which it might vary, such as language, content-coding, etc.) compared to various information supplied in the request, including both the explicit negotiation fields of Section 5.3 and implicit characteristics, such as the client's network address or parts of the =User-Agent= field.
#+END_QUOTE

用户代理发送包含内容协商的偏好信息的请求到服务器，让服务器的某个算法来选择[[ruby:preferred%20representation][首选的表示形式]]，称之为[[ruby:proactive%20negotiation][主动型协商]]（也称[[ruby:server-driven%20negotiation][服务器驱动型协商]]）。这种选择是基于可供响应使用的[[ruby:representations][表示形式]]（维度有很多，例如语言、内容编码等），对比多种由请求提供的信息，包括显式协商头字段（章节 5.3）和隐式特性两者，例如客户端的网络地址或者 =User-Agent= 头字段的部分信息。

#+BEGIN_QUOTE
Proactive negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to a user agent, or when the server desires to send its "best guess" to the user agent along with the first response (hoping to avoid the round trip delay of a subsequent request if the "best guess" is good enough for the user). In order to improve the server's guess, a user agent *MAY* send request header fields that describe its preferences.
#+END_QUOTE

主动型协商适用于以下情况：当难以向用户代理描述清楚服务器的选择算法（如何从[[ruby:available%20representations][可使用的表现形式]] 之中选择最佳的一个）；或者当服务器倾向于在发送第一个响应到用户代理的时候就附带上它的“[[ruby:best%20guess][最佳猜测]]”（希望如果该“最佳猜测”对于该用户来说已经足够好的话，就能够避免后续请求的[[ruby:round%20trip%20delay][往返延时]]）。为了提升服务器猜测的准确性，用户代理 *可以* 在其发送的请求消息中包含某些头字段来描述自身的[[ruby:preferences][偏好]]。

#+BEGIN_QUOTE
Proactive negotiation has serious disadvantages:
- It is impossible for the server to accurately determine what might be "best" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?);
- Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy;
- It complicates the implementation of an origin server and the algorithms for generating responses to a request; and,
- It limits the reusability of responses for shared caching.
#+END_QUOTE

主动型协商有以下严重的弊端：
- 对于任何给定的用户，要让服务器精准确定什么才是“[[ruby:best%20representation][最佳表示形式]]”是不可能的，这是因为这需要全面了解用户代理的[[ruby:capabilities][功能]]及其对响应的[[ruby:intended%20use][使用意图]]（例如，用户是否想在屏幕上浏览或者将其打印成纸质的？）；
- 让用户代理在每次请求里都要描述自身的能力是非常[[ruby:inefficient][低效的]]（假定只有一小部分响应带有[[ruby:multiple%20representations][多个表示形式]]），而且对用户的隐私有潜在风险；
- 复杂化了源服务器的实现和生成响应给到请求的算法；
- 限制了[[ruby:shared%20caching][共享缓存]]的[[ruby:reusability][复用性]]。

#+BEGIN_QUOTE
A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a =406 (Not Acceptable)= response.
#+END_QUOTE

用户代理不能信赖主动型协商的[[ruby:preferences][预设]]会一直被遵循，这是因为源服务器可能没有对所请求的资源实现主动型协商，或者认为发送一个并不符合用户代理的偏好的响应比发送一个 =406 (Not Acceptable)= 响应要好。

#+BEGIN_QUOTE
A =Vary= header field ([[id:ca7f8781-b183-4563-a90a-b9b7ad4f1032][Section 7.1.4]]) is often sent in a response subject to proactive negotiation to indicate what parts of the request information were used in the selection algorithm.
#+END_QUOTE

=Vary= 头字段（[[id:ca7f8781-b183-4563-a90a-b9b7ad4f1032][章节 7.1.4]]）通常用来指明主动型协商的选择算法会用到请求信息的哪些部分。

*** 3.4.2. 响应式协商 / Reactive Negotiation
#+BEGIN_QUOTE
With reactive negotiation (a.k.a., agent-driven negotiation), selection of the best response representation (regardless of the status code) is performed by the user agent after receiving an initial response from the origin server that contains a list of resources for alternative representations. If the user agent is not satisfied by the initial response representation, it can perform a GET request on one or more of the alternative resources, selected based on metadata included in the list, to obtain a different form of representation for that response. Selection of alternatives might be performed automatically by the user agent or manually by the user selecting from a generated (possibly hypertext) menu.
#+END_QUOTE

使用[[ruby:reactive%20negotiation][响应式协商]]（也称[[ruby:agent-driven%20negotiation][代理驱动型协商]]），选择哪一个作为响应的[[ruby:best%20representation][最佳表示形式]]（且不论[[ruby:response%20status%20code][响应状态码]]）是由用户代理在接收到一个来自源服务器的[[ruby:initial%20response][初始响应]]之后执行的。这个初始响应会包含[[ruby:alternative%20representations][备选的表示形式]]的一个列表。如果用户代理不满意初始响应的表示形式，它可以（基于包含在上述列表中的元数据来）选择向一个或多个备选表示形式所对应的 URI 发起 GET 请求来获得其得的表示形式。选择哪一种备选表示形式可能是由用户代理自动执行，也可能是由用户从一个生成好的菜单（也许是超文本）里手动选择。

#+BEGIN_QUOTE
Note that the above refers to representations of the response, in general, not representations of the resource. The alternative representations are only considered representations of the target resource if the response in which those alternatives are provided has the semantics of being a representation of the target resource (e.g., a =200 (OK)= response to a GET request) or has the semantics of providing links to alternative representations for the target resource (e.g., a =300 (Multiple Choices)= response to a GET request).
#+END_QUOTE

需要注意的是，上述指的是响应的表示形式，通常来说，并不是指资源的表示形式。如果提供那些[[ruby:alternative%20representations][备选表示形式]]的响应带有如下语义：成为目标资源的一种表示形式（例如，一个回应给 GET 请求的 =200 (OK)= 响应）；或者提供链接到该目标资源的备选表示形式（例如，一个回应给 GET 请求的 =300 (Multiple Choices)= 响应），那么，备选表示形式仅考虑目标资源的表示形式。

#+BEGIN_QUOTE
A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred. For example, the alternatives listed in responses with the =300 (Multiple Choices)= and =406 (Not Acceptable)= status codes include information about the available representations so that the user or user agent can react by making a selection.
#+END_QUOTE

服务器可能选择不发送一个初始表示形式，而是只发送[[ruby:list%20of%20alternatives][备选列表]]，从而表明：它首选由用户代理来执行的响应式协商。例如，列在带有 =300 (Multiple Choices)= 和 =406 (Not Acceptable)= 状态码的响应里的[[ruby:alternatives][备选物]]，包含了关于[[ruby:available%20representations][可用的表示形式]]的信息以便用户或用户代理作出选择。

#+BEGIN_QUOTE
Reactive negotiation is advantageous when the response would vary over commonly used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage.
#+END_QUOTE

响应式协商适用于以下情况：当响应会随常用维度（例如类型、语言、编码等）而变化；当源服务器无法通过检测请求而确定用户代理的能力；当使用[[ruby:public%20caches][公共缓存]]来分发服务器的负载和降低网络使用。

#+BEGIN_QUOTE
Reactive negotiation suffers from the disadvantages of transmitting a list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation. Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed as an extension.
#+END_QUOTE

响应式协商存在以下缺点：需要传递备选列表到用户代理，并且需要另一个请求来获得一种备选表示形式。
在消息头部里传递备选列表势必会导致[[ruby:degrades%20user-perceived%20latency][用户观感延时的降级]]。而且，本规范并没有定义用于支持自动选择的机制，但它也没有阻止这样一种机制发展成为扩展。

#+BEGIN_QUOTE
译注：[[https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation][MDN web docs]] 里对内容协商有更详细的描述。
#+END_QUOTE

* 4. 请求方法 / Request Methods
:PROPERTIES:
:ID:       e6ec0aa0-3e4d-4367-bffd-423e028210b0
:END:
** 4.1. 概况 / Overview
#+BEGIN_QUOTE
The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.
#+END_QUOTE

请求方法的[[ruby:token][标记]]是请求语义的主要来源，它指明了客户端发起这次请求的目的以及它期望什么作为成功结果。

#+BEGIN_QUOTE
The request method's semantics might be further specialized by the semantics of some header fields when present in a request ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]) if those additional semantics do not conflict with the method. For example, a client can send conditional request header fields ([[id:b21923d5-a8f9-4560-8592-92fd9a098bf4][Section 5.2]]) to make the requested action conditional on the current state of the target resource ([[[https://tools.ietf.org/html/rfc7232][RFC7232]]]).
#+END_QUOTE

请求方法的语义可能由于某些请求头字段（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）的出现而被[[ruby:further%20specialized][进一步深化]]，如果这些头字段的语义与方法的语义并不冲突的话。例如，客户端能够发送[[ruby:conditional%20request%20header%20fields][条件请求头字段]]（[[id:b21923d5-a8f9-4560-8592-92fd9a098bf4][章节 5.2]]）以使对目标资源的当前状态的请求动作[[ruby:conditional][带有条件]]（【[[https://tools.ietf.org/html/rfc7232][RFC7232]]】）。

#+BEGIN_SRC text
  method = token
#+END_SRC

#+BEGIN_QUOTE
HTTP was originally designed to be usable as an interface to distributed object systems. The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics. The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names.
#+END_QUOTE

HTTP 最初是被设计为用来作为[[ruby:distributed%20object%20systems][分布式对象系统]]的一种接口。请求方法被设想为向某个目标资源应用语义，这就跟在某个被标识的对象上执行某个已定义的方法会应用相应的语义一样。[[ruby:method%20tokens][方法标记]]是区分大小写的，这是因为它可能用作一种区分方法名称大小写的网关，来对[[ruby:object-based%20systems][基于对象的系统]]进行访问。

#+BEGIN_QUOTE
Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST]. Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.
#+END_QUOTE

不同于分布式对象，在 HTTP 里，[[ruby:standardized%20request%20methods][标准请求方法]]不是[[ruby:resource-specific][资源特定的]]，这是因为提供统一接口是为了在基于网络的系统中有更好的可见性和复用（【[[http://roy.gbiv.com/pubs/dissertation/top.htm][REST]]】）。一旦定义了标准化的方法，那么，当它被应用到任意资源的时候，它都应该具有同等的语义，虽然每种资源会自己决定是否实现或者允许这些语义。

#+BEGIN_QUOTE
This specification defines a number of standardized methods that are commonly used in HTTP, as outlined by the following table. By convention, standardized methods are defined in all-uppercase US-ASCII letters.
#+END_QUOTE

本规范定义了若干常用在 HTTP 里的标准方法，见下表的概括。按照惯例，标准方法是定义为纯大写的 US-ASCII 字母。

| 方法    | 描述                                                   | 章节  |
|---------+--------------------------------------------------------+-------|
| GET     | 传输目标资源的一种当前表示形式                         | [[id:698bab73-07b1-4349-8a03-5a4a89d966d8][4.3.1]] |
| HEAD    | 与 GET 相同，除了仅传输状态行和消息头部                  | [[id:d00f1692-2d40-4b09-a634-9c87fce07bc4][4.3.2]] |
| POST    | 对请求有效载荷执行特定资源的处理                       | [[id:d672d01b-615b-416a-a750-0442a6901ed0][4.3.3]] |
| PUT     | 使用请求有效载荷来替换目标资源的所有当前表示形式       | [[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][4.3.4]] |
| DELETE  | 删除目标资源的所有当前表示形式                         | [[id:9e649fa9-0f7f-40d0-adef-8af6a6f62e80][4.3.5]] |
| CONNECT | 与目标资源所标识的服务器建立隧道                       | [[id:630ab908-5d8e-400b-bed4-f6973b8c1549][4.3.6]] |
| OPTIONS | 描述关于目标资源的通信选项                             | [[id:f659b35f-7510-4961-ad3a-3ab1b312a681][4.3.7]] |
| TRACE   | 执行一种沿着目标资源的路径的消息 loop-back 测试 | [[id:bdc9e3b4-bac3-46c5-9319-31f7f4d6469d][4.3.8]] |

#+BEGIN_QUOTE
All general-purpose servers *MUST* support the methods GET and HEAD. All other methods are OPTIONAL.
#+END_QUOTE

所有通用服务器 *必须* 支持 GET 和 HEAD 方法。所有其他方法都是 *可选的*。

#+BEGIN_QUOTE
Additional methods, outside the scope of this specification, have been standardized for use in HTTP. All such methods ought to be registered within the "Hypertext Transfer Protocol (HTTP) Method Registry" maintained by IANA, as defined in [[id:193d7ad5-9c6d-4bf7-98f1-6984a42af639][Section 8.1]].
#+END_QUOTE

超出本规范所定义的额外方法，它们在 HTTP 的使用方式已经被标准化。应该把所有这些方法注册在由 IANA 维护的 "Hypertext Transfer Protocol (HTTP) Method Registry" 注册表中，其定义见[[id:193d7ad5-9c6d-4bf7-98f1-6984a42af639][章节 8.1]]。

#+BEGIN_QUOTE
The set of methods allowed by a target resource can be listed in an =Allow= header field ([[id:f8577773-512f-4d68-8f5d-444368db7c29][Section 7.4.1]]). However, the set of allowed methods can change dynamically. When a request method is received that is unrecognized or not implemented by an origin server, the origin server *SHOULD* respond with the =501 (Not Implemented)= status code. When a request method is received that is known by an origin server but not allowed for the target resource, the origin server *SHOULD* respond with the =405 (Method Not Allowed)= status code.
#+END_QUOTE

被[[ruby:target%20resource][目标资源]]所允许的方法集可以列在 =Allow= 头字段内（[[id:f8577773-512f-4d68-8f5d-444368db7c29][章节 7.4.1]]）。然而，目标资源可以动态改变其允许哪些方法。当源服务器接收到一个[[ruby:unrecognized][不能识别]]或自身[[ruby:not%20implemented][未实现的]]请求方法时，源服务器 *应当* 以 =501 (Not Implemented)= 作为响应。当服务器接收到一个能够识别但目标资源不允许的请求方法时，源服务器 *应当* 以 =405 (Method Not Allowed)= 作为响应。

** 4.2. 公共方法属性 / Common Method Properties
*** 4.2.1. 安全方法 / Safe Methods
:PROPERTIES:
:ID:       2f967e3d-8694-430b-ad06-e748fd39b281
:END:
#+BEGIN_QUOTE
Request methods are considered "safe" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.
#+END_QUOTE

如果请求方法所定义的语义本质上是[[ruby:read-only][只读]]的，那么，这种请求方法可以认为是“[[ruby:safe][安全的]]”。例如，在向源服务器的某个目标资源应用某个[[ruby:safe%20method][安全方法]]以后，客户端既[[ruby:not%20request][没有请求（要求）]]也[[ruby:not%20expect][没有期望]]源服务器有任何状态的变化。同样，安全方法的合理使用并不希望对源服务器造成任何损害、财产损失、或者异常负担。

#+BEGIN_QUOTE
This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server. Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account.
#+END_QUOTE

安全方法的这种定义并不妨碍将其[[ruby:implement][实现]]为一种可能包含有害行为的方法，表现为不完全只读，或者当执行某个安全方法时会引起[[ruby:side%20effects][副作用]]。然而，重要的是，客户端并没有请求（要求）服务器执行额外的行为，并且不能因此而追究客户端的责任。例如，大多数服务器在完成每个响应的时候，会附加上请求信息到访问日志文件里面，而不管这是什么请求方法，这就被认为是安全的，哪怕日志存储可能变满导致服务器崩溃。同样，在网站上发起一个安全的请求来进行广告甄选，通常会有广告账号记账的副作用（即产生广告费用的消耗）。

#+BEGIN_QUOTE
Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
#+END_QUOTE

本规范所定义的请求方法中，定义为安全的方法有：GET、HEAD、OPTIONS 和 TRACE。

#+BEGIN_QUOTE
The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm. In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content.
#+END_QUOTE

之所有要区分方法是否安全，是为了可以放心地开启[[ruby:automated%20retrieval%20processes][自动检索程序]]（[[ruby:spider][爬虫]]）和[[ruby:cache%20performance%20optimization][缓存性能优化]]（[[ruby:pre-fetching][预取]]）而不需要担心引起问题。再者，它让用户代理在处理可能不受信任的内容的时候，能够对非安全方法的自动使用实施适当的约束。

#+BEGIN_QUOTE
A user agent *SHOULD* distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.
#+END_QUOTE

当呈现潜在的请求动作给用户的时候，用户代理 *应当* 区分好安全与非安全的方法，以便在这种请求动作被执行之前，用户能够意识到这是一种不安全的动作。

#+BEGIN_QUOTE
When a resource is constructed such that parameters within the effective request URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as "page?do=delete". If the purpose of such a resource is to perform an unsafe action, then the resource owner *MUST* disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.
#+END_QUOTE

构建一个资源，使在[[ruby:effective%20request%20URI][有效请求 URI]] 里的参数会影响到的请求动作选择，那么，确保该动作是否符合请求方法的语义是资源所有者的责任。例如，[[ruby:Web-based%20content%20editing%20software][基于网站的内容编辑软件]]常常会在[[ruby:query%20parameters][查询参数]]里使用某些动作，如 "page?do=delete"。如果这种资源的目的是为执行一个[[ruby:unsafe%20action][非安全的动作]]，那么，当使用一个[[ruby:safe%20request%20method][安全的请求方法]]来访问该资源的时候，资源所有者 *必须* 禁用或者拒绝该动作。否则的话，当[[ruby:automated%20processes][自动程序]]出于某种目的（为了链接维护，预取，生成搜索索引等）来对每个 URI 执行一个 GET 的时候，会导致不好的副作用。

#+BEGIN_QUOTE
译注：请求方法是否是安全的，其关注点在于该方法是否有改变资源的状态，而不是平常我们认为的安全性或保密性的概念。只要执行该请求方法后，资源的状态没有被改变，那么这个请求方法就是安全的（哪怕可能会导致数据泄漏、黑客入侵、硬件爆炸等），否则就是不安全的。换句话说，安全的请求方法都是“只读”的，并不会对资源造成任何“写入”，类似于编程语言中 Getter 的概念。
#+END_QUOTE

*** 4.2.2. 幂等方法 / Idempotent Methods
#+BEGIN_QUOTE
A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.
#+END_QUOTE

当执行多次相同的请求，与单次这样的请求，对服务器的预期效果是一样的，那么，该请求方法被认为是“[[ruby:idempotent][幂等的]]”。本规范所定义的请求方法中，幂等方法有：PUT、DELETE 以及所有[[id:2f967e3d-8694-430b-ad06-e748fd39b281][安全请求方法]]。

#+BEGIN_QUOTE
译注：也就是说，幂等的方法共有GET、HEAD、PUT、DELETE、OPTIONS 和 TRACE。
#+END_QUOTE

#+BEGIN_QUOTE
Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request.
#+END_QUOTE

跟安全的定义类似，请求方法的幂等性只适用于用户究竟请求到了什么，而服务器可以自由地单独记录每个请求的日志，保持一份版本管理历史，或者为每个幂等请求实现其他非幂等的副作用等等。

#+BEGIN_QUOTE
Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response. For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request. It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.
#+END_QUOTE

之所以要区分请求方法的幂等与否，是因为如果在客户端能够读取服务器的响应之前发生了通信失败，请求可以被自动重复发送（见[[id:0ca97f51-efc7-43d2-ab52-d998a92423e5][【RFC7230】6.3.1]]）。例如，如果客户端发送一个 PUT 请求，同时，之前建立好的连接在客户端接收到任何响应之前就被关闭了，那么，客户端可以建立一个新的连接并重试该幂等请求。客户端知道重复该请求会有相同的预期效果，即使原来的请求已经成功了。

*** 4.2.3. 可缓存方法 / Cacheable Methods
#+BEGIN_QUOTE
Request methods can be defined as "cacheable" to indicate that responses to them are allowed to be stored for future reuse; for specific requirements see [[[https://tools.ietf.org/html/rfc7234][RFC7234]]]. In general, safe methods that do not depend on a current or authoritative response are defined as cacheable; this specification defines GET, HEAD, and POST as cacheable, although the overwhelming majority of cache implementations only support GET and HEAD.
#+END_QUOTE

请求方法可以被定义为“[[ruby:cacheable][可缓存的]]”来指明：回应给它们的响应能够被保存起来，用于将来的复用，更具体的要求见【[[https://tools.ietf.org/html/rfc7234][RFC7234]]】。通常，不依赖某个[[ruby:current%20response][当前响应]]或[[ruby:authoritative%20response][权威响应]]的安全方法，就是[[ruby:cacheable][可缓存的]]方法。本规范定义了 GET、HEAD 和 POST 作为可缓存的方法，虽然绝大多数的[[ruby:cache%20implementations][缓存实现]]仅仅支持 GET 和 HEAD。

** 4.3. 方法的定义 / Method Definitions
*** 4.3.1. GET
:PROPERTIES:
:ID:       698bab73-07b1-4349-8a03-5a4a89d966d8
:END:
#+BEGIN_QUOTE
The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.
#+END_QUOTE

GET 方法请求获得目标资源的一种[[ruby:current%20selected%20representation][当前选定的表示形式]]。GET 是信息获取的主要途径，同时，它也是几乎所有[[ruby:performance%20optimizations][性能优化]]的重点。因此，当人们谈及经由 HTTP 来获取某些可标识的信息的时候，他们一般指的是发起一个 GET 请求。

#+BEGIN_QUOTE
It is tempting to think of resource identifiers as remote file system pathnames and of representations as being a copy of the contents of such files. In fact, that is how many resources are implemented (see [[id:9195be98-bd4e-40ae-a5a0-6af920044f02][Section 9.1]] for related security considerations). However, there are no such limitations in practice. The HTTP interface for a resource is just as likely to be implemented as a tree of content objects, a programmatic view on various database records, or a gateway to other information systems. Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly. Regardless, only the origin server needs to know how each of its resource identifiers corresponds to an implementation and how each implementation manages to select and send a current representation of the target resource in a response to GET.
#+END_QUOTE

我们很容易想到将[[ruby:resource%20identifiers][资源标识]]符作为远程文件系统的路径名称，以及将[[ruby:representations][表示形式]]作为这些远程文件的内容的一种拷贝。事件上，这也是许多资源的实现方式（安全相关注意事项见[[id:9195be98-bd4e-40ae-a5a0-6af920044f02][章节 9.1]]）。然而，实际上资源并没有被限制为只有这一种实现方式。资源的 HTTP 接口也有可能被实现为一种[[ruby:content%20object%20tree][内容对象树]][fn:2]、一种基于各种数据库记录的可编程视图、一种到其他信息系统的网关等等。甚至当 URI 的映射机制被捆绑到一种文件系统上，也可以将源服务器配置为将文件连同请求一起作为执行的输入，而输出结果则作为[[ruby:representation][表示形式]]并发送给请求，而不是直接传输文件本身。无论如何，只有源服务器需要了解它的每个资源标识符如何对应到某种实现上，以及每种实现如何在回应到 GET 的响应里达成选择和发送目标资源的某种[[ruby:current%20representation][当前表示形式]]。

#+BEGIN_QUOTE
A client can alter the semantics of GET to be a "range request", requesting transfer of only some part(s) of the selected representation, by sending a =Range= header field in the request ([[[https://tools.ietf.org/html/rfc7233][RFC7233]]]).
#+END_QUOTE

客户端能够将 GET 的语义改变为一种“[[ruby:range%20request][范围请求]]”，通过在其发送的请求消息中带有一个 =Range= 头字段，来实现只对[[ruby:selected%20representation][已选定的表示形式]]中的某（几）部分进行请求传输（【[[https://tools.ietf.org/html/rfc7233][RFC7233]]】）。

#+BEGIN_QUOTE
A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.
#+END_QUOTE

在 GET 请求消息里的有效载荷是没有定义任何语义的，如果在 GET 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

#+BEGIN_QUOTE
The response to a GET request is cacheable; a cache *MAY* use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the =Cache-Control= header field ([[https://tools.ietf.org/html/rfc7234#section-5.2][Section 5.2]] of [RFC7234]).
#+END_QUOTE

回应给 GET 请求的响应是[[ruby:cacheable][可缓存的]]，[[ruby:cache][缓存]] *可以* 使用它来满足随后的 GET 和 HEAD 请求，除非 =Cache-Control= 头字段另有指定（[[https://tools.ietf.org/html/rfc7234#section-5.2][【RFC7234】章节 5.2]]）。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET][MDN]] 的总结：
The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
- Request has body :: No
- Successful response has body :: Yes
- Safe :: Yes
- Idempotent :: Yes
- Cacheable :: Yes
- Allowed in HTML forms :: Yes
#+END_QUOTE

*** 4.3.2. HEAD
:PROPERTIES:
:ID:       d00f1692-2d40-4b09-a634-9c87fce07bc4
:END:
The HEAD method is identical to GET except that the server *MUST NOT* send a message body in the response (i.e., the response terminates at the end of the header section). The server *SHOULD* send the same header fields in response to a HEAD request as it would have sent if the request had been a GET, except that the payload header fields ([[id:4c395bab-baa6-4895-b677-5daa1584da6e][Section 3.3]]) *MAY* be omitted. This method can be used for obtaining metadata about the selected representation without transferring the representation data and is often used for testing hypertext links for validity, accessibility, and recent modification.

HEAD 方法几乎与 GET 方法等价，除了服务器 *禁止* 在回应 HEAD 请求的响应消息里带有[[ruby:message%20body][消息体]]（也就是说，响应消息在[[ruby:header%20section][消息头部]]之后就结束了）。服务器回应给 GET 请求的响应消息里带有什么头字段，回应给 HEAD 请求的响应消息里就 *应当* 带有什么头字段，除了[[ruby:payload%20header%20fields][有效载荷头字段]]（[[id:4c395bab-baa6-4895-b677-5daa1584da6e][章节 3.3]]） *可以* 被忽略以外。HEAD 方法能够用于在不需要传输[[ruby:representation%20data][表示形式数据]]的情况下获取[[ruby:selected%20representation][已选定的表示形式]]（[[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][章节 3]]） 相关的元数据。同时，它也常用于测试[[ruby:hypertext%20links][超链接]]的正确性、可访问性和最近是否有修改。

A payload within a HEAD request message has no defined semantics; sending a payload body on a HEAD request might cause some existing implementations to reject the request.

在 HEAD 请求消息里的有效载荷是没有定义任何语义的，如果在 HEAD 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

The response to a HEAD request is cacheable; a cache *MAY* use it to satisfy subsequent HEAD requests unless otherwise indicated by the =Cache-Control= header field ([[https://tools.ietf.org/html/rfc7234#section-5.2][Section 5.2]] of [RFC7234]). A HEAD response might also have an effect on previously cached responses to GET; see [[https://tools.ietf.org/html/rfc7234#section-4.3.5][Section 4.3.5]] of [RFC7234].

回应给 HEAD 请求的响应是[[ruby:cacheable][可缓存的]]，[[ruby:cache][缓存]] *可以* 使用它来满足随后的 HEAD 请求，除非 =Cache-Control= 头字段另有指定（[[https://tools.ietf.org/html/rfc7234#section-5.2][【RFC7234】章节 5.2]]）。HEAD 响应还可能影响到之前已缓存的 GET 响应，见[[https://tools.ietf.org/html/rfc7234#section-4.3.5][【RFC7234】章节 4.3.5]]。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD][MDN]] 的总结：

- Request has body :: No
- Successful response has body :: No
- Safe :: Yes
- Idempotent :: Yes
- Cacheable :: Yes
- Allowed in HTML forms :: No
#+END_QUOTE

*** 4.3.3. POST
:PROPERTIES:
:ID:       d672d01b-615b-416a-a750-0442a6901ed0
:END:
#+BEGIN_QUOTE
The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others):

- Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;
- Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;
- Creating a new resource that has yet to be identified by the origin server; and
- Appending data to a resource's existing representation(s).
#+END_QUOTE

POST 方法请求目标资源按照资源自身的具体语义来处理封装在请求消息里的[[ruby:representation][表示形式]]。例如，POST 是用于以下（或其他）功能。

- 为某个数据处理进程提供[[ruby:a%20block%20of%20data][数据块]]，例如某个 HTML 表单的域；
- 发表一个消息到某个电子公告栏、新闻组、邮件列表、博客或者类似的文章组里；
- 创建一种还没有被源服务器所标识的新的资源；以及
- 附加数据到某个资源的现有[[ruby:representation(s)][表示形式]]中。

#+BEGIN_QUOTE
An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification might be received in a response to POST (the exceptions being =206 (Partial Content)=, =304 (Not Modified)=, and =416 (Range Not Satisfiable)=).
#+END_QUOTE

源服务器根据 POST 请求的处理结果来选择一种恰当的状态码来指明响应的语义，几乎所有本规范定义的状态码都可以用在回应给 POST 的响应里，除了 =206 (Partial Content)=、=304 (Not Modified)= 以及 =416 (Range Not Satisfiable)= 是例外。

#+BEGIN_QUOTE
If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server *SHOULD* send a =201 (Created)= response containing a =Location= header field that provides an identifier for the primary resource created ([[id:bc2baf29-0bf6-4816-865c-3d33f5fe38e3][Section 7.1.2]]) and a representation that describes the status of the request while referring to the new resource(s).
#+END_QUOTE

如果一个或多个资源在源服务器上被创建，来作为对成功处理某个 POST 请求的结果，那么，源服务器 *应当* 发送一个 =201 (Created)= 响应，且该响应需带有一个 =Location= 头字段来提供一种标识符，来对应被创建的主要资源（[[id:bc2baf29-0bf6-4816-865c-3d33f5fe38e3][章节 7.1.2]]）；以及需要包含一种[[ruby:representation][表示形式]]，来描述当引用新资源的时候请求的状态。

#+BEGIN_QUOTE
Responses to POST requests are only cacheable when they include explicit freshness information (see [[https://tools.ietf.org/html/rfc7234#section-4.2.1][Section 4.2.1]] of [RFC7234]). However, POST caching is not widely implemented. For cases where an origin server wishes the client to be able to cache the result of a POST in a way that can be reused by a later GET, the origin server *MAY* send a =200 (OK)= response containing the result and a =Content-Location= header field that has the same value as the POST's effective request URI ([[id:91650144-4bfc-4362-b628-f96578a5c756][Section 3.1.4.2]]).
#+END_QUOTE

回应给 POST 请求的响应，仅当它们包含明确的[[ruby:freshness%20information][新鲜信息]]时，才是[[ruby:cacheable][可缓存的]]（见[[https://tools.ietf.org/html/rfc7234#section-4.2.1][【RFC7234】章节 4.2.1]]）。然而，对 POST 响应的缓存并没有被广泛实现。如果源服务器希望客户端以一种之后的 GET 能够复用的方式使客户端能够缓存 POST 的结果，面对这种情况，源服务器 *可以* 发送一个 =200 (OK)= 响应来包含该结果，并且，该响应还需带有与该 POST 的有效请求 URI 相同的值的一个 =Content-Location= 头字段（[[id:91650144-4bfc-4362-b628-f96578a5c756][章节 3.1.4.2]]）。

#+BEGIN_QUOTE
If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server *MAY* redirect the user agent to that resource by sending a =303 (See Other)= response with the existing resource's identifier in the =Location= field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.
#+END_QUOTE

如果处理某个 POST 请求的结果等价于某个现有资源的某种[[ruby:representation][表示形式]]的话，源服务器 *可以* 发送一个 =303 (See Other)= 响应到用户代理，同时，响应里带有 =Location= 头字段，其值为该现有资源的标识符，让用户代理进行重定向。这样做的好处是可以向用户代理提供一种资源标识符，以及可以通过一种更适合缓存共享的方法来传输[[ruby:representation][表示形式]]，但坏处是可能需要一个额外的请求，如果用户代理还没有缓存过该[[ruby:representation][表示形式]]的话。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST][MDN]] 的总结：

The HTTP POST method sends data to the server. The type of the body of the request is indicated by the Content-Type header.

- Request has body :: Yes
- Successful response has body :: Yes
- Safe :: No
- Idempotent :: No
- Cacheable :: Only if freshness information is included
- Allowed in HTML forms :: Yes
#+END_QUOTE

*** 4.3.4. PUT
:PROPERTIES:
:ID:       28f69be8-26e9-4dd7-930e-7c683d7bcf8a
:END:
#+BEGIN_QUOTE
The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload. A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.
#+END_QUOTE

PUT 方法请求源服务器使用封装在请求消息有效载荷内的[[ruby:representation][表示形式]]所定义的状态，来[[ruby:create][新建]]或[[ruby:replace][替换]]目标资源的状态。如果向目标资源[[ruby:successful%20PUT%20request][成功 PUT]] 了一个给定的[[ruby:representation][表示形式]]，那么我们可以认为，对相同目标资源的后续 GET 请求将会被回应一个 =200 (OK)= 响应，同时响应会携带一个（与之前 PUT 的表示形式）等价的表示形式。然而，不能保证这种状态的改变能够被客户端所观察到，这是因为在源服务器接收到任何来自该客户端的后续的 GET 请求之前，目标资源就可能被按照其他用户代理并行地执行动作，也有可能受到源服务器的动态处理。对 PUT 请求的[[ruby:successful%20response][成功响应]]，仅仅意味着在源服务器处理该请求的时候，用户代理达成了它的意图。

#+BEGIN_QUOTE
If the target resource does not have a current representation and the PUT successfully creates one, then the origin server *MUST* inform the user agent by sending a =201 (Created)= response. If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server *MUST* send either a =200 (OK)= or a =204 (No Content)= response to indicate successful completion of the request.
#+END_QUOTE

如果目标资源并没有[[ruby:current%20representation][当前表示形式]]，并且 PUT 成功地创建了一种表示形式，那么，源服务器 *必须* 回应一个 =201 (Created)= 响应来告知用户代理。如果目标资源已有一种[[ruby:current%20representation][当前表示形式]]，并且该表示形式的状态被封装在 PUT 请求内的表示形式成功地更改了，那么，源服务器 *必须* 回应一个 =200 (OK)= 或者一个 =204 (No Content)= 来指明请求已经成功完成了。

#+BEGIN_QUOTE
译注：由此可见，PUT 会改变 representation 的状态，因此，它不是一个[[ruby:safe%20method][安全方法]]。而 PUT 是一个[[ruby:idempotent%20method][幂等方法]]，由上述可知，多次相同的 PUT 请求与一次 PUT 请求对[[ruby:representation][表示形式]]的影响是一样的。试想一下，一个 PUT 请求，试图将用户 A 的年龄值更新为 18，无论发送一次还是多次这样的请求，用户 A 的年龄值最终依然是 18。
#+END_QUOTE

#+BEGIN_QUOTE
An origin server *SHOULD* ignore unrecognized header fields received in a PUT request (i.e., do not save them as part of the resource state).
#+END_QUOTE

源服务器 *应当* 忽略掉接收自某个 PUT 请求的[[ruby:unrecognized%20header%20fields][未识别的头字段]]（也就是说，不要保存它们作为资源状态的一部分）。

#+BEGIN_QUOTE
An origin server *SHOULD* verify that the PUT representation is consistent with any constraints the server has for the target resource that cannot or will not be changed by the PUT. This is particularly important when the origin server uses internal configuration information related to the URI in order to set the values for representation metadata on GET responses. When a PUT representation is inconsistent with the target resource, the origin server *SHOULD* either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The =409 (Conflict)= or =415 (Unsupported Media Type)= status codes are suggested, with the latter being specific to constraints on =Content-Type= values.
#+END_QUOTE

源服务器 *应当* 校验 PUT 的[[ruby:representation][表示形式]]是否符合服务器对目标资源的任何[[ruby:constraints][约束]]，确保它们不能或不会被 PUT 所改变。当源服务器使用与 URI 相关联的内部配置信息来对回应给 GET 的响应的[[ruby:representation][表示形式]]的元数据设置值的时候，这种校验是非常重要的。当一个 PUT 请求内的表示形式不符合[[ruby:target%20resource][目标资源]]的约束时，源服务器 *应当* 要不[[ruby:transform][转换]]这个表示形式或者改变资源的配置以使其符合约束条件；要不回应一种恰当的错误消息，包含足够的信息来解释为什么该表示形式并不合适。建议使用 =409 (Conflict)= 或者 =415 (Unsupported Media Type)= 状态码，而对于后者（=415 (Unsupported Media Type)=），带有 =Content-Type= 头字段以指定具体的约束类型。

#+BEGIN_QUOTE
For example, if the target resource is configured to always have a =Content-Type= of "text/html" and the representation being PUT has a =Content-Type= of "image/jpeg", the origin server ought to do one of:

- reconfigure the target resource to reflect the new media type;
- transform the PUT representation to a format consistent with that of the resource before saving it as the new resource state; or,
- reject the request with a =415 (Unsupported Media Type)= response indicating that the target resource is limited to "text/html", perhaps including a link to a different resource that would be a suitable target for the new representation.

#+END_QUOTE

例如，如果目标资源被配置为总是带有一个 "text/html" 的 =Content-Type=，并且 PUT 请求内的[[ruby:representation][表示形式]]带有一个 "image/jpeg" 的 =Content-Type=，那么，源服务器的行为应该是以下其中之一：

- 将目标资源重新配置以体现该种新的媒体类型；
- 在保存 PUT 请求的[[ruby:representation][表示形式]]作为目标资源的新状态之前，先将其[[ruby:transform][转换]]为一种符合资源约束的格式；或者
- 回应一个 =415 (Unsupported Media Type)= 响应来拒绝该请求并指明目标资源被限定为 "text/html"，响应内可能还包含一条[[ruby:link][链接]]，该链接指向到其他可能适用于该请求目标的资源。

#+BEGIN_QUOTE
HTTP does not define exactly how a PUT method affects the state of an origin server beyond what can be expressed by the intent of the user agent request and the semantics of the origin server response. It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP. It does not define how resource state is "stored", nor how such storage might change as a result of a change in resource state, nor how the origin server translates resource state into representations. Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server.
#+END_QUOTE

HTTP 并没有定义 PUT 方法究竟是如何影响源服务器的状态的，是因为这超出了用户代理的请求意图以及源服务器的响应语义所能表达的。HTTP 并没有定义[[ruby:resource][资源]]究竟是什么，在任何意义上，这超出了由 HTTP 所提供的接口所能表达的。HTTP 并没有定义[[ruby:resource%20state][资源的状态]]是被如何“[[ruby:stored][存储]]”的，也没有定义资源状态上的改变会导致这种存储如何改变，也没有定义源服务器是如何将资源的状态[[ruby:translate][翻译]]成[[ruby:representations][资源的表示]]的。一般而言，在资源接口后面的所有实现细节都被服务器有意地隐藏起来。

#+BEGIN_QUOTE
An origin server *MUST NOT* send a validator header field ([[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][Section 7.2]]), such as an =ETag= or =Last-Modified= field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the body (i.e., the resource's new representation data is identical to the representation data received in the PUT request) and the validator field value reflects the new representation. This requirement allows a user agent to know when the representation body it has in memory remains current as a result of the PUT, thus not in need of being retrieved again from the origin server, and that the new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 5.2).
#+END_QUOTE

源服务器 *禁止* 在回应给 PUT 的[[ruby:successful%20response][成功响应]]里带有任何[[ruby:validator%20header%20field][验证器头字段]]（[[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][章节 7.2]]），例如 =ETag= 或者 =Last-Modified= 头字段，除非请求的[[ruby:representation%20data][表示形式数据]]是保存在没有经过任何[[ruby:transformation][编码转换]]的消息体（有效载荷）里（也就是说，响应内的新的[[ruby:representation%20data][表示形式数据]]是等价于接收自 PUT 请求内的[[ruby:representation%20data][表示形式数据]]），并且该验证器头字段反映的是新的表示形式。上述这种要求让用户代理能够知道这个在自己内存中的表示形式在什么时间内可以[[ruby:remain%20current][保持最新（保持为 current 状态）]]，由此知道其是否仍然可以继续作为 PUT 请求的结果而不需要从源服务器上再次获取，以及在响应内接收到的新验证器能够被用于将来的[[ruby:conditional%20requests][条件请求]]以避免新[[ruby:accidental%20overwrite][意外覆盖]]（章节 5.2）。

#+BEGIN_QUOTE
译注：未经过任何编码转换的[[ruby:message%20body][消息体]]等价于[[ruby:payload%20body][有效载荷体]]，见[[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][【RFC7230】章节 3.3.1]]。
#+END_QUOTE

#+BEGIN_QUOTE
The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation. The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the target resource. Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.
#+END_QUOTE

POST 与 PUT 两者的根本区别在于它们对封装的[[ruby:representation][表示形式]]的不同意图。POST 所请求目标资源是意图依据该资源自身的语义来[[ruby:handle][处置]]请求内的表示形式。而在 PUT 请求内的表示形式是定义为替换目标资源的状态的。因此，PUT 的意图是[[ruby:idempotent][幂等的]]且对[[ruby:intermediaries][中间人]]是[[ruby:visible][可见的]]，虽然只有源服务器了解其确切的作用。

#+BEGIN_QUOTE
Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, *SHOULD* be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server *MUST* send an appropriate =3xx (Redirection)= response; the user agent *MAY* then make its own decision regarding whether or not to redirect the request.
#+END_QUOTE

PUT 请求的[[ruby:proper%20interpretation][合理解释]]是相信用户代理是知道哪个目标才是它所期望的。一种为客户端选择恰当的 URI 的服务，在接收到一种[[ruby:state-changing%20request][会引起状态变化的请求]]以后，*应当* 被实现为使用 POST 方法而不是 PUT 方法。如果源服务器不将 PUT 所请求的状态改变到目标资源上，而是希望将其应用到另外一个不同的资源上，例如当资源被迁移到另一个不同的 URI 上了，那么，源服务器 *必须* 回应一个恰当的 =3xx (Redirection)= 响应给用户代理，然后，用户代理 *可以* 自行决定是否对请求进行[[ruby:redirect][重定向]]。

#+BEGIN_QUOTE
A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying "the current version" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on "the current version" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.
#+END_QUOTE

应用到[[ruby:target%20resource][目标资源]]的 PUT 请求可能会对其他资源带来[[ruby:side%20effects][副作用]]。例如，一篇文章可能会有一个用于标识“[[ruby:the%20current%20version][当前版本]]”（是一种资源）的 URI，独立于其他每一个标识特定版本的 URIs，不同的资源在某处共享同一种状态来作为“当前版本”所对应的资源。成功地向“当前版本”这个 URI 发起了一个 PUT 请求以后，可能除了改变目标资源的状态之外，还会创建额外一个“新版本”的资源，而且还有可能需要添加链接到关联的资源之中。 

#+BEGIN_QUOTE
An origin server that allows PUT on a given target resource *MUST* send a =400 (Bad Request)= response to a PUT request that contains a =Content-Range= header field ([[https://tools.ietf.org/html/rfc7233#section-4.2][Section 4.2]] of [RFC7233]), since the payload is likely to be partial content that has been mistakenly PUT as a full representation. Partial content updates are possible by targeting a separately identified resource with state that overlaps a portion of the larger resource, or by using a different method that has been specifically defined for partial updates (for example, the PATCH method defined in [[[https://tools.ietf.org/html/rfc5789][RFC5789]]]).
#+END_QUOTE

对于允许向给定目标资源发送 PUT 请求的源服务器来说，如果某个 PUT 请求包含有一个 =Content-Range= 头字段（[[https://tools.ietf.org/html/rfc7233#section-4.2][【RFC7233】章节 4.2]]），源服务器 *必须* 向该请求回应一个 =400 (Bad Request)= 响应，这是因为该请求的[[ruby:payload][有效载荷]]很有可能只是[[ruby:partial%20content][部分内容]]而被错误地当作一个完整的 representation。[[ruby:partial%20content%20updates][部分内容的更新]]很可能是通过使用[[ruby:larger%20resource][大型资源]]的一部分相重叠的状态来定位一个单独标识的资源，或者通过使用另外一种被定义为专门用于[[ruby:partial%20updates][部分更新]]的方法（例如，定义于【[[https://tools.ietf.org/html/rfc5789][RFC5789]]】里的 PATCH 方法）。

#+BEGIN_QUOTE
Responses to the PUT method are not cacheable. If a successful PUT request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see Section 4.4 of [RFC7234]).
#+END_QUOTE

回应给 PUT 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。如果一个[[ruby:successful%20PUT%20request][成功的 PUT 请求]]穿过一个[[ruby:cache][缓存]]，而该缓存已经存储（缓存）了该 PUT 请求的有效请求 URI 所对应的一个或多个响应（也就是说，缓存命中了这个 PUT 请求），那么这些已存储的（已缓存的）响应将会[[ruby:be%20invalidated][被失效]]（见【RFC7234】章节 4.4）。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT][MDN]] 的总结：

The HTTP PUT request method creates a new resource or replaces a representation of the target resource with the request payload.

The difference between PUT and POST is that PUT is idempotent: calling it once or several times successively has the same effect (that is no side effect), where successive identical POST may have additional effects, like passing an order several times.

- Request has body :: Yes
- Successful response has body :: No
- Safe :: No
- Idempotent :: Yes
- Cacheable :: No
- Allowed in HTML forms :: No
#+END_QUOTE

*** 4.3.5. DELETE
:PROPERTIES:
:ID:       9e649fa9-0f7f-40d0-adef-8af6a6f62e80
:END:
#+BEGIN_QUOTE
The DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the =rm= command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.
#+END_QUOTE

DELETE 方法请求源服务器移除[[ruby:target%20resource][目标资源]]与它[[ruby:current%20functionality][当前的功能]]之间的关联。实际上，该方法与 UNIX 中的 =rm= 命令非常类似，DELETE 表达了一种作用在映射到源服务器的 URI 之上的删除操作，而不是表达一种删除之前相关联的信息的期望。

#+BEGIN_QUOTE
If the target resource has one or more current representations, they might or might not be destroyed by the origin server, and the associated storage might or might not be reclaimed, depending entirely on the nature of the resource and its implementation by the origin server (which are beyond the scope of this specification). Likewise, other implementation aspects of a resource might need to be deactivated or archived as a result of a DELETE, such as database or gateway connections. In general, it is assumed that the origin server will only allow DELETE on resources for which it has a prescribed mechanism for accomplishing the deletion.
#+END_QUOTE

如果目标资源有一个或多个[[ruby:current%20representations][当前表示形式]]，它们可能会也可能不会被源服务器所销毁，另外，它们所关联的存储可能会也可能不会被回收，这完全取决于资源的性质以及服务器对资源的[[ruby:implementation][实现]]（已经超出了本规范的范畴）。同样，还可能需要去[[ruby:deactivate][失效]]或[[ruby:archive][归档]]资源实现的其他方面，来作为一个 DELETE 操作的结果，比如数据库或者网关连接。总之，我们假设源服务器只会允许对这些资源进行 DELETE：具有某种规定机制来完成删除操作的资源。

#+BEGIN_QUOTE
Relatively few resources allow the DELETE method — its primary use is for remote authoring environments, where the user has some direction regarding its effect. For example, a resource that was previously created using a PUT request, or identified via the =Location= header field after a =201 (Created)= response to a POST request, might allow a corresponding DELETE request to undo those actions. Similarly, custom user agent implementations that implement an authoring function, such as revision control clients using HTTP for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository.
#+END_QUOTE

相对较少的资源会允许 DELETE 方法，它主要应用在用户会有某些关于它的影响效果的指导的[[ruby:remote%20authoring%20environments][远程编辑环境]]中。例如，在以前使用一个 PUT 请求来创建好的某个资源，或者是在回应给 POST 请求的一个 =201 (Created)= 响应以后，该响应里的 =Location= 头字段所标识的某个资源，可能会允许使用一个对应的 DELETE 请求来[[ruby:undo][撤消]]这些动作。类似的，实现某种[[ruby:authoring%20function][编辑方法]]的[[ruby:custom%20user%20agent%20implementations][定制的用户代理实现]]，比如使用 HTTP 来进行远程操作的[[ruby:revision%20control%20clients][版本管理客户端]]，可能会基于“服务器的 [[ruby:URI%20space][URI 空间]]是经过精心设计来对应某个版本仓库”的这种假设来使用 DELETE。

#+BEGIN_QUOTE
译注：URI space 参考【[[https://tools.ietf.org/html/rfc5785][RFC5785]]】Defining Well-Known Uniform Resource Identifiers (URIs)
#+END_QUOTE

#+BEGIN_QUOTE
If a DELETE method is successfully applied, the origin server *SHOULD* send a =202 (Accepted)= status code if the action will likely succeed but has not yet been enacted, a =204 (No Content)= status code if the action has been enacted and no further information is to be supplied, or a =200 (OK)= status code if the action has been enacted and the response message includes a representation describing the status.
#+END_QUOTE

如果成功执行了一次 DELETE 方法，如果该动作可能会成功但确定的结果还未[[ruby:enacted][出现]]，源服务器 *应当* 回应一个 =202 (Accepted)= 响应；如果该动作的结果已经出现了并且服务器不会再提供更多的信息，*应当* 回应一个 =204 (No Content)= 响应；或者如果该动作的结果已经出现了并且响应会包含一个[[ruby:representation][表示形式]]来描述资源的状态，该响应的状态码 *应当* 是 =200 (OK)= 。

#+BEGIN_QUOTE
A payload within a DELETE request message has no defined semantics; sending a payload body on a DELETE request might cause some existing implementations to reject the request.
#+END_QUOTE

在 DELETE 请求里的[[ruby:payload][有效载荷]]并没有定义任何的语义，如果在 DELETE 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

#+BEGIN_QUOTE
Responses to the DELETE method are not cacheable. If a DELETE request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see [[https://tools.ietf.org/html/rfc7234#section-4.4][Section 4.4]] of [RFC7234]).
#+END_QUOTE

回应给 DELETE 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。如果一个 DELETE 请求穿过一个[[ruby:cache][缓存]]，而该缓存已经存储（缓存）了该 DELETE 请求的有效请求 URI 所对应的一个或多个响应（也就是说，缓存命中了这个 DELETE 请求），那么这些已存储的（已缓存的）响应将会[[ruby:be%20invalidated][被失效]]（见[[https://tools.ietf.org/html/rfc7234#section-4.4][【RFC7234】章节 4.4]]）。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE][MDN]] 的总结：

The HTTP DELETE request method deletes the specified resource.

- Request has body :: May
- Successful response has body :: May
- Safe :: No
- Idempotent :: Yes
- Cacheable :: No
- Allowed in HTML forms :: No
#+END_QUOTE

*** 4.3.6. CONNECT
:PROPERTIES:
:ID:       630ab908-5d8e-400b-bed4-f6973b8c1549
:END:
#+BEGIN_QUOTE
The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed. Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security, [[[https://tools.ietf.org/html/rfc5246][RFC5246]]]).
#+END_QUOTE

CONNECT 方法请求让对方（接收端）与[[ruby:request-target][请求目标]]所标识的源服务器[[ruby:establish][建立]]一个[[ruby:tunnel][隧道]]，并且如果建立成功以后，将接收端的行为限制为双向[[ruby:blind%20forwarding][盲目转发]]数据包，直到隧道被关闭为止。隧道常常用于创建一种穿越一个或多个[[ruby:proxies][代理]]的[[ruby:end-to-end][端到端]]的[[ruby:virtual%20connection][虚拟连接]]，然后能够安全使用 TLS（Transport Layer Security，【[[https://tools.ietf.org/html/rfc5246][RFC5246]]】）。

#+BEGIN_QUOTE
译注：需要注意的是，并不是 CONNECT 请求的发送端与源服务器建立隧道，而是 CONNECT 接收端与源服务器建立隧道，这个要清楚。
#+END_QUOTE

#+BEGIN_QUOTE
CONNECT is intended only for use in requests to a proxy. An origin server that receives a CONNECT request for itself *MAY* respond with a =2xx (Successful)= status code to indicate that a connection is established. However, most origin servers do not implement CONNECT.
#+END_QUOTE

CONNECT 只能用在向代理发送的请求里。源服务器接收到一个发送给它自己的 CONNECT 请求时，*可以* 回应一个 =2xx (Successful)= 状态码来表明：连接已被建立好。但是，大多数源服务器并没有[[ruby:implement][实现]] CONNECT。

#+BEGIN_QUOTE
A client sending a CONNECT request *MUST* send the authority form of request-target ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]); i.e., the request-target consists of only the host name and port number of the tunnel destination, separated by a colon. For example,
#+END_QUOTE

发送 CONNECT 请求的客户端 *必须* 以 authority-form（权威形式）的形式来发送[[ruby:request-target][请求目标]]（[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]），也就是说，请求目标仅由隧道终点的[[ruby:host%20name][主机名称]]以及[[ruby:port%20number][端口号]]组成，以冒号分隔。例如：

#+BEGIN_EXAMPLE
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80

#+END_EXAMPLE

#+BEGIN_QUOTE
译注：上例是有一个[[ruby:blank%20line][空行]]的，表示[[ruby:header%20section][消息头部]]结束，消息结构的更多详情见[[id:6e9516fa-cde2-4693-b1e1-e763776d3186][【RFC7230】章节 3]]。
#+END_QUOTE

#+BEGIN_QUOTE
The recipient proxy can establish a tunnel either by directly connecting to the request-target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy. Any =2xx (Successful)= response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the blank line that concludes the successful response's header section; data received after that blank line is from the server identified by the request-target. Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.
#+END_QUOTE

作为接收端的[[ruby:proxy][代理]]能够通过以下方式建立一个隧道：直接连接到请求目标；或者，如果该代理被配置为使用另一个代理的话，转发该 CONNECT 请求到下一个[[ruby:inbound%20proxy][入站代理]]。任何 =2xx (Successful)= 响应都表明：发送端（以及所有入站代理）将会在成功响应的[[ruby:header%20section][消息头部]]末尾的空行（该空行表示消息头部结束）以后，马上切换为[[ruby:tunnel%20mode][隧道模式]]，而在这个空行之后所接收到的数据，是来自由[[ruby:request%20target][请求目标]]所标识的源服务器的。其他任何不是表示成功的响应则表明这个隧道还没有形成，该连接仍然受到 HTTP 支配（而不是由隧道所扩展的协议来支配，例如 TLS）。

#+BEGIN_QUOTE
这里涉及到 HTTP 的消息结构和参与的多种角色，如果对这些概念还不够熟悉的话，请先浏览【[[file:RFC7230.org][RFC7230]]】里的章节 2 和 3。
#+END_QUOTE

#+BEGIN_QUOTE
A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary *MUST* attempt to send any outstanding data that came from the closed side to the other side, close both connections, and then discard any remaining data left undelivered.
#+END_QUOTE

当[[ruby:tunnel%20intermediary][隧道中间人]]检测到隧道两端都已关闭了连接的时候，隧道被关闭。中间人 *必须* 尝试发送所有[[ruby:outstanding%20data][未偿付的数据]]，从被关闭的一端发送到另一端，然后关闭两端的连接，最后丢弃掉任何还[[ruby:undelivered][未投递出去]]的数据。

#+BEGIN_QUOTE
Proxy authentication might be used to establish the authority to create a tunnel. For example,
#+END_QUOTE

[[ruby:proxy%20authentication][代理认证]]可能被用来[[ruby:establish%20authority][确立权威]]来创建一个隧道，例如：

#+BEGIN_EXAMPLE
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=

#+END_EXAMPLE

#+BEGIN_QUOTE
There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic. For example, a CONNECT to a request-target of "example.com:25" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support CONNECT *SHOULD* restrict its use to a limited set of known ports or a configurable whitelist of safe request targets.
#+END_QUOTE

向任意的服务器建立隧道会有严重的风险，特别是当隧道的终点是一个不作为[[ruby:Web%20traffic][网站流量]]的 TCP [[ruby:well-known%20port][知名端口]]或者[[ruby:reserved%20port][保留端口]]的时候。例如，请求目标为 "example.com:25" 的 CONNECT 请求会建议代理连接到用于 SMTP 流量的保留端口上，如果允许这样做，就会欺骗代理去[[ruby:relaying][中转]]垃圾邮件。因此，支持 CONNECT 的代理 *应当* 将 CONNECT 的使用限制到一个已知的有限的端口集合上，或者一个安全的可配置的请求目标白名单上。

#+BEGIN_QUOTE
A server *MUST NOT* send any =Transfer-Encoding= or =Content-Length= header fields in a =2xx (Successful)= response to CONNECT. A client *MUST* ignore any =Content-Length= or =Transfer-Encoding= header fields received in a successful response to CONNECT.
#+END_QUOTE

服务器 *禁止* 在一个回应给 CONNECT 的 =2xx (Successful)= 响应中带有任何 =Transfer-Encoding= 或者 =Content-Length= 头字段。客户端 *必须* 在其接收到的回应给 CONNECT 的成功响应里，忽略掉任何 =Content-Length= 或者 =Transfer-Encoding= 头字段。

#+BEGIN_QUOTE
A payload within a CONNECT request message has no defined semantics; sending a payload body on a CONNECT request might cause some existing implementations to reject the request.
#+END_QUOTE

在 CONNECT 请求消息里的有效载荷是没有定义任何语义的，如果在 CONNECT 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

#+BEGIN_QUOTE
Responses to the CONNECT method are not cacheable.
#+END_QUOTE

回应给 CONNECT 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT][MDN]] 的总结：

The HTTP CONNECT method method starts two-way communications with the requested resource. It can be used to open a tunnel.

For example, the CONNECT method can be used to access websites that use SSL (HTTPS). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.

CONNECT is a hop-by-hop method.

- Request has body :: No
- Successful response has body :: Yes
- Safe :: No
- Idempotent :: No
- Cacheable :: No
- Allowed in HTML forms :: No
#+END_QUOTE

*** 4.3.7. OPTIONS
:PROPERTIES:
:ID:       f659b35f-7510-4961-ad3a-3ab1b312a681
:END:
#+BEGIN_QUOTE
The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action.
#+END_QUOTE

OPTIONS 方法请求获得可用于目标资源的[[ruby:communication%20options][通信选项]]的有关信息，这些信息是在源服务器或者介于客户端和源服务器之间的中间人上的。本方法让客户端在没有对资源执行相关动作的情况下，就可以确定与资源有关的选项和（或者）要求，或者服务器的功能。

#+BEGIN_QUOTE
An OPTIONS request with an asterisk ("*") as the request-target ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]) applies to the server in general rather than to a specific resource. Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof).
#+END_QUOTE

如果要向服务器执行 OPTIONS 请求，一般是使用一个星号（"*"），而不是一个具体的资源，来作为请求目标（[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]）。这是因为服务器的通信选项一般依赖于资源，"*" 请求仅作为方法的一种 "ping" 或者“空操作” 时才有用处，除了让客户端可以去测试服务器的功能以外，它并没有做任何其他事情。例如，用它来测试一个代理是否遵循 HTTP/1.1 规范。

#+BEGIN_QUOTE
If the request-target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.
#+END_QUOTE

如果请求目标不是使用[[ruby:asterisk-form][星号形式]]，那么，OPTIONS 请求所应用到的选项是可用在与目标资源通信的。

#+BEGIN_QUOTE
A server generating a successful response to OPTIONS *SHOULD* send any header fields that might indicate optional features implemented by the server and applicable to the target resource (e.g., =Allow=), including potential extensions not defined by this specification. The response payload, if any, might also describe the communication options in a machine or human-readable representation. A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP. A server *MUST* generate a =Content-Length= field with a value of "0" if no payload body is to be sent in the response.
#+END_QUOTE

服务器在向 OPTIONS 生成一个成功响应的时候，*应当* 带有所有可能指明以下信息的头字段：由服务器所实现的可选功能，并且这些可选功能是可作用于目标资源的（例如，=Allow=）。这些头字段还应当包括那些未定义在本规范里的扩展头字段，如果有的话。如果响应里包含有效载荷，那么还可能描述了机器的通信选项，或者供人类阅读的[[ruby:representation][表示形式]]的通信选项。对于这样一种表示形式，本规范并没有定义一种标准格式，但可能会在将来的 HTTP 扩展中进行定义。服务器 *禁止* 生成带有一个 "0" 值的 =Content-Length= 头字段，如果该响应没有包含有效载荷的话。

#+BEGIN_QUOTE
A client *MAY* send a =Max-Forwards= header field in an OPTIONS request to target a specific recipient in the request chain (see [[id:4c0e6435-a276-48fb-8cb8-32b8ef5a2780][Section 5.1.2]]). A proxy *MUST NOT* generate a =Max-Forwards= header field while forwarding a request unless that request was received with a =Max-Forwards= field.
#+END_QUOTE

客户端 *可以* 在一个 OPTIONS 请求中带有一个 =Max-Forwards= 头字段，以便在请求链路中对一个具体的接收端进行定位（见[[id:4c0e6435-a276-48fb-8cb8-32b8ef5a2780][章节 5.1.2]]）。代理 *禁止* 在转发请求的时候生成一个 =Max-Forwards= 头字段，除非该请求本身已带有一个 =Max-Forwards= 头字段。

#+BEGIN_QUOTE
A client that generates an OPTIONS request containing a payload body *MUST* send a valid =Content-Type= header field describing the representation media type. Although this specification does not define any use for such a payload, future extensions to HTTP might use the OPTIONS body to make more detailed queries about the target resource.
#+END_QUOTE

客户端生成一个 OPTIONS 请求的时候，如果该请求包含一个有效载荷，那么，该请求 *必须* 带有一个有效的 =Content-Type= 头字段来描述[[ruby:representation][表示形式]]的媒体类型。虽然本规范并没有对这样一种有效载荷的用途进行过任何定义，但将来的 HTTP 扩展中可能会使用 OPTIONS 请求的消息体来携带目标资源有关的更细致的查询信息。

#+BEGIN_QUOTE
Responses to the OPTIONS method are not cacheable.
#+END_QUOTE

回应给 OPTIONS 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS][MDN]] 的总结：

The HTTP OPTIONS method is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.

- Request has body :: No
- Successful response has body :: Yes
- Safe :: Yes
- Idempotent :: Yes
- Cacheable :: No
- Allowed in HTML forms :: No
#+END_QUOTE

*** 4.3.8. TRACE
:PROPERTIES:
:ID:       bdc9e3b4-bac3-46c5-9319-31f7f4d6469d
:END:
#+BEGIN_QUOTE
The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request *SHOULD* reflect the message received, excluding some fields described below, back to the client as the message body of a =200 (OK)= response with a =Content-Type= of "message/http" ([[id:44492A0E-8B7F-46EC-890D-317BC32E2228][Section 8.3.1]] of [RFC7230]). The final recipient is either the origin server or the first server to receive a =Max-Forwards= value of zero (0) in the request ([[id:4c0e6435-a276-48fb-8cb8-32b8ef5a2780][Section 5.1.2]]).
#+END_QUOTE

TRACE 方法请求一个远程的、应用层的请求消息[[ruby:loop-back][回路]]。请求链路中的[[ruby:final%20recipient][最终接收端]] *应当* 原样[[ruby:reflect][反映]]它所接收到的消息，排除掉下文所述的那些头字段，作为一个带有值为 "message/http"（[[id:44492A0E-8B7F-46EC-890D-317BC32E2228][【RFC7230】章节 8.3.1]]）的 =Content-Type= 的 =200 (OK)= 响应的消息体，最后返回给客户端。最终接收端指的是源服务器，或者是在请求链路中第一个接收到 Max-Forwards 值为 0 的请求消息的服务器（[[id:4c0e6435-a276-48fb-8cb8-32b8ef5a2780][章节 5.1.2]]）。

#+BEGIN_QUOTE
A client *MUST NOT* generate header fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials [[[file:RFC7235.org][RFC7235]]] or cookies [[[https://tools.ietf.org/html/rfc6265][RFC6265]]] in a TRACE request. The final recipient of the request *SHOULD* exclude any request header fields that are likely to contain sensitive data when that recipient generates the response body.
#+END_QUOTE

客户端 *禁止* 在一个 TRACE 请求里生成以下这种头字段：包含有[[ruby:sensitive%20data][敏感数据]]的，并且这些敏感数据有可能会被响应[[ruby:disclosed][暴露]]出来的。例如，用户代理在一个 TRACE 请求里包含有存放在本地的[[ruby:user%20credentials][用户证书]]【[[file:RFC7235.org][RFC7235]]】或者 cookies【[[https://tools.ietf.org/html/rfc6265][RFC6265]]】，这种做法是非常愚蠢的。请求的[[ruby:final%20recipient][最终接收端]]在生成响应正文的时候，*应当* 排除掉任何有可能包含敏感数据的请求头字段。

#+BEGIN_QUOTE
TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the =Via= header field ([[id:4a38d632-e412-4122-8ae5-0d58ab8f3d6a][Section 5.7.1]] of [RFC7230]) is of particular interest, since it acts as a trace of the request chain. Use of the =Max-Forwards= header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
#+END_QUOTE

TRACE 让客户端能够观察到请求链路的另一端将会接收到什么数据，并且让客户端可以使用这些数据来测试或者诊断信息。在这些数据之中，=Via= 头字段（[[id:4a38d632-e412-4122-8ae5-0d58ab8f3d6a][【RFC7230】章节 5.7.1]]）的值是特别让人感兴趣的数据之一，这是因为它记录了请求链路的轨迹。使用 =Max-Forwards= 头字段可以让客户端对请求链路的长度进行限制，这对测试一条代理链路是否在无限循环转发消息是非常有用的。

#+BEGIN_QUOTE
A client *MUST NOT* send a message body in a TRACE request.
#+END_QUOTE

客户端 *禁止* 在一个 TRACE 请求里带有一个消息体。

#+BEGIN_QUOTE
Responses to the TRACE method are not cacheable.
#+END_QUOTE

回应给 TRACE 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。

#+BEGIN_QUOTE
译注：来自 [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE][MDN]] 的总结：

The HTTP TRACE method performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.

The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a Content-Type of message/http. The final recipient is either the origin server or the first server to receive a Max-Forwards value of 0 in the request.

- Request has body :: No
- Successful response has body :: No
- Safe :: No
- Idempotent :: Yes
- Cacheable :: No
- Allowed in HTML forms :: No
#+END_QUOTE

* 5. 请求头字段 / Request Header Fields
:PROPERTIES:
:ID:       f8e7b063-496f-473e-95e8-88ec76f21582
:END:

#+BEGIN_QUOTE
A client sends request header fields to provide more information about the request context, make the request conditional based on the target resource state, suggest preferred formats for the response, supply authentication credentials, or modify the expected request processing. These fields act as request modifiers, similar to the parameters on a programming language method invocation.
#+END_QUOTE

客户端发送[[ruby:request%20header%20fields][请求头字段]]来提供更多关于请求上下文的信息，基于目标资源的状态来使请求[[ruby:conditional][带有条件]]，提议响应的[[ruby:preferred%20formats][首选格式]]，提供认证凭证，或者更改预期的请求处理。这些头字段充当请求的[[ruby:modifiers][修饰符]]，类似于一门编程语言中参与函数调用的参数一样。

** 5.1. 控制 / Controls

#+BEGIN_QUOTE
Controls are request header fields that direct specific handling of the request.
#+END_QUOTE

控制相关的请求头字段的作用是指导请求的具体处理。

| Header Field Name | Defined in...            |
|-------------------+--------------------------|
| Cache-Control     | [[id:03c2dad4-a6d2-4d3c-b087-d08717bf09ec][Section 5.2]] of [RFC7234] |
| Expect            | [[id:0b0cea12-0af7-47f1-8908-2afc48ce3fb2][Section 5.1.1]]            |
| Host              | [[id:f6cd08fd-597f-4b1d-98ad-a1730125abdc][Section 5.4]] of [RFC7230] |
| Max-Forwards      | [[id:4c0e6435-a276-48fb-8cb8-32b8ef5a2780][Section 5.1.2]]            |
| Pragma            | [[id:8414ec2d-e5b5-4f9c-8160-c354c12b7504][Section 5.4]] of [RFC7234] |
| Range             | [[id:a70b4aaa-f776-4d5b-a31d-60d1ad16d85e][Section 3.1]] of [RFC7233] |
| TE                | [[id:2BA944C9-6215-4B88-8F5F-D5CACA865191][Section 4.3]] of [RFC7230] |

*** 5.1.1. Expect
:PROPERTIES:
:ID:       0b0cea12-0af7-47f1-8908-2afc48ce3fb2
:END:

#+BEGIN_QUOTE
The "Expect" header field in a request indicates a certain set of behaviors (expectations) that need to be supported by the server in order to properly handle this request. The only such expectation defined by this specification is 100-continue.
#+END_QUOTE

请求消息里的 =Expect= 头字段指明了一个确定的[[ruby:behaviors][行为]]（[[ruby:expectations][期望]]）集合，这些期望需要通过服务器的支持来实现，以使得这个请求得以妥善处理。=100-continue= 是仅有的由本规范所定义的期望。

#+BEGIN_SRC text
  Expect  = "100-continue"
#+END_SRC

#+BEGIN_QUOTE
The =Expect= field-value is case-insensitive.
#+END_QUOTE

=Expect= 的值是不区分大小写的。

#+BEGIN_QUOTE
A server that receives an =Expect= field-value other than =100-continue= *MAY* respond with a =417 (Expectation Failed)= status code to indicate that the unexpected expectation cannot be met.
#+END_QUOTE

如果服务器接收到一个带有 =Expect= 头字段的请求，但其字段值并不是 =100-continue=，那么，服务器 *可以* 回应一个 =417 (Expectation Failed)= 状态的响应来指明不能遇到[[ruby:unexpected%20expectation][意料之外的期望]]（也就是说，服务器仅能处理 =100-continue= 这种期望）。

#+BEGIN_QUOTE
A =100-continue= expectation informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a =100 (Continue)= interim response if the request-line and header fields are not sufficient to cause an immediate success, redirect, or error response. This allows the client to wait for an indication that it is worthwhile to send the message body before actually doing so, which can improve efficiency when the message body is huge or when the client anticipates that an error is likely (e.g., when sending a state-changing method, for the first time, without previously verified authentication credentials).
#+END_QUOTE

=100-continue= 这个期望向接收端告知了这样一个信息：客户端即将在本次请求中发送一个（假定是很大的）消息体，如果之前所发送的请求行以及头字段不足以引起一个立即成功、重定向或者错误响应的时候，它希望能够从接收端那里接收到一个 =100 (Continue)= 的[[ruby:interim%20response][过渡响应]]，让客户端在真正要发送这个消息体之前，可以等待服务器的指示来确认是否有必要发送这个消息体。当消息体的体积巨大，或者客户端预见到可能出现错误（例如，当首次发送一个[[ruby:state-changing%20method][会改变资源状态的请求方法]]的时候没有预先校验认证凭证）的时候，这样做可以提高效率。

#+BEGIN_QUOTE
译注：[[ruby:interim%20response][过渡响应]]是相对于[[ruby:final%20response][最终响应]]来说的。过渡响应即所有 =1xx= 状态码的响应，所有非 =1xx= 状态码的响应都是最终响应。
#+END_QUOTE

#+BEGIN_QUOTE
For example, a request that begins with
#+END_QUOTE

例如，请求消息的起始内容如下：

#+BEGIN_EXAMPLE
  PUT /somewhere/fun HTTP/1.1
  Host: origin.example.com
  Content-Type: video/h264
  Content-Length: 1234567890987
  Expect: 100-continue

#+END_EXAMPLE

#+BEGIN_QUOTE
allows the origin server to immediately respond with an error message, such as =401 (Unauthorized)= or =405 (Method Not Allowed)=, before the client starts filling the pipes with an unnecessary data transfer.
#+END_QUOTE

这个请求让源服务器可以在客户端向管道连接里填充不必要的数据流之前，立即响应一个错误消息，比如 =401 (Unauthorized)= 或者 =405 (Method Not Allowed)=。

#+BEGIN_QUOTE
Requirements for clients:

- A client *MUST NOT* generate a =100-continue= expectation in a request that does not include a message body.
- A client that will wait for a =100 (Continue)= response before sending the request message body *MUST* send an =Expect= header field containing a =100-continue= expectation.
- A client that sends a =100-continue= expectation is not required to wait for any specific length of time; such a client *MAY* proceed to send the message body even if it has not yet received a response. Furthermore, since =100 (Continue)= responses cannot be sent through an HTTP/1.0 intermediary, such a client *SHOULD NOT* wait for an indefinite period before sending the message body.
- A client that receives a =417 (Expectation Failed)= status code in response to a request containing a =100-continue= expectation *SHOULD* repeat that request without a =100-continue= expectation, since the =417= response merely indicates that the response chain does not support expectations (e.g., it passes through an HTTP/1.0 server).
#+END_QUOTE

对于客户端的要求：

- 客户端 *禁止* 在一个没有[[ruby:message%20body][消息体]]的请求里生成一个 =100-continue= 期望。
- 客户端在发送请求的消息体之前，如果打算等待服务器的 =100 (Continue)=，*必须* 发送一个包含 =100-continue= 期望的 =Expect= 头字段。
- 客户端在发送了一个 =100-continue= 期望以后，并不要求去等待任意具体的时长。这时候客户端甚至 *可以* 在未接收到任何响应的情况下就开始发送消息体。再者，由于 =100 (Continue)= 响应不能经由一个 HTTP/1.0 中间人来转发，因此，这种情况下的客户端 *不应当* 在发送消息体之前无限期地等待。
- 客户端接收到一个 =417 (Expectation Failed)= 状态码的响应，该响应是回应给一个包含 =100-continue= 期望的请求的，这时候，客户端 *应当* 再次发起这个请求，但这次请求不会再带有 =100-continue= 期望，这是因为这个 =417= 响应只不过是表明：该[[ruby:response%20chain][响应链路]]并不支持期望（比如，它经过一个 HTTP/1.0 服务器）。

#+BEGIN_QUOTE
译注：HTTP/1.0 并没有定义任何 =1xx= 的状态码，所以不支持在 HTTP/1.0 上使用 =100-continue=。
#+END_QUOTE

#+BEGIN_QUOTE
Requirements for servers:

- A server that receives a =100-continue= expectation in an HTTP/1.0 request *MUST* ignore that expectation.
- A server *MAY* omit sending a =100 (Continue)= response if it has already received some or all of the message body for the corresponding request, or if the framing indicates that there is no message body.
- A server that sends a =100 (Continue)= response *MUST* ultimately send a final status code, once the message body is received and processed, unless the connection is closed prematurely.
- A server that responds with a final status code before reading the entire message body *SHOULD* indicate in that response whether it intends to close the connection or continue reading and discarding the request message (see [[id:5051d9ad-6b2e-45b0-be58-42b9dce34b89][Section 6.6]] of [RFC7230]).
#+END_QUOTE

对于服务器的要求：

- 当服务器接收到一个 HTTP/1.0 的请求，并且该请求包含一个 =100-continue= 期望的时候，服务器 *必须* 忽略掉这个期望。
- 如果服务器已经接收到部分或全部消息体；或者消息分帧表明这个请求并没有消息体，那么，服务器 *可以* 省略发送一个 =100 (Continue)= 响应到对应的请求上。
- 服务器发送了一个 =100 (Continue)= 响应，一旦接收到并处理完消息体以后，*必须* 发送一个[[ruby:final%20status%20code][最终状态码]]，除非连接被过早地关闭了。
- 如果服务器在读取完整个消息体之前就响应了一个最终状态码，那么，服务器 *应当* 在该响应里表明：它是打算关闭这个连接呢，还是继续读取和丢弃这个请求消息（见[[id:5051d9ad-6b2e-45b0-be58-42b9dce34b89][【RFC7230】章节 6.6]]）？

#+BEGIN_QUOTE
An origin server *MUST*, upon receiving an HTTP/1.1 (or later) request-line and a complete header section that contains a =100-continue= expectation and indicates a request message body will follow, either send an immediate response with a final status code, if that status can be determined by examining just the request-line and header fields, or send an immediate =100 (Continue)= response to encourage the client to send the request's message body. The origin server *MUST NOT* wait for the message body before sending the =100 (Continue)= response.
#+END_QUOTE

源服务器 *必须* 依据：所接收到的 HTTP/1.1（或更新的）[[ruby:request-line][请求行]]，以及包含有一个 =100-continue= 期望并表明随后将会有一个请求消息体到来的完整的[[ruby:header%20section][消息头部]]，来决定：是立即发送一个带有最终状态码的响应呢，如果该状态仅仅通过检测请求行和头字段就可以确定到的话；还是立即发送一个 =100 (Continue)= 响应来[[ruby:encourage][促使]]客户端去发送该请求的消息体呢？源服务器在发送 =100 (Continue)= 响应之前 *禁止* 等待消息体。

#+BEGIN_QUOTE
A proxy *MUST*, upon receiving an HTTP/1.1 (or later) request-line and a complete header section that contains a =100-continue= expectation and indicates a request message body will follow, either send an immediate response with a final status code, if that status can be determined by examining just the request-line and header fields, or begin forwarding the request toward the origin server by sending a corresponding request-line and header section to the next inbound server. If the proxy believes (from configuration or past interaction) that the next inbound server only supports HTTP/1.0, the proxy *MAY* generate an immediate =100 (Continue)= response to encourage the client to begin sending the message body.
#+END_QUOTE

代理 *必须* 依据：依据所接收到的 HTTP/1.1（或更新的）[[ruby:request-line][请求行]]，以及包含有一个 =100-continue= 期望并表明随后将会有一个请求消息体到来的完整的[[ruby:header%20section][消息头部]]，来决定：是立即发送一个带有最终状态码的响应呢，如果该状态仅仅通过检测请求行和头字段就可以确定到的话；还是开始通过发送一个对应的请求行和消息头部到下一个[[ruby:inbound%20server][入站服务器]]，来沿着源服务器的方向转发这个请求呢？如果这个代理（依据本地配置或者过去的交互）相信下一个入站服务器仅支持 HTTP/1.0 的话，这个代理 *可以* 立即生成一个 =100 (Continue)= 响应来促使客户端开始发送该请求的消息体。

#+BEGIN_QUOTE
译注：入站、出站的概念见[[id:e2d9bed8-d6ca-4b5d-ab4a-6b2b2576393e][【RFC7230】章节 2.3]]。
#+END_QUOTE

#+BEGIN_QUOTE
*Note:* The =Expect= header field was added after the original publication of HTTP/1.1 [RFC2068] as both the means to request an interim =100 (Continue)= response and the general mechanism for indicating must-understand extensions. However, the extension mechanism has not been used by clients and the must-understand requirements have not been implemented by many servers, rendering the extension mechanism useless. This specification has removed the extension mechanism in order to simplify the definition and processing of =100-continue=.
#+END_QUOTE

注意：=Expect= 头字段早在 HTTP/1.1 规范的第一版【RFC2068】时就已经被引入，当时它是有两个作用的：一是用于请求一个 =100 (Continue)= 过渡响应，二是作为一种通用机制来表明：这是一种“[[ruby:must-understand][必须理解]]”的[[ruby:extensions][扩展]]。但是，这种扩展机制并没有得到客户端的应用，而且这个所谓的“必须理解”的要求也没有得到很多服务器的实现，致使这种扩展机制变得[[ruby:useless][无用]]。本规范已经移除了这种扩展机制以简化 =100-continue= 的定义和处理。

*** 5.1.2. Max-Forwards
:PROPERTIES:
:ID:       4c0e6435-a276-48fb-8cb8-32b8ef5a2780
:END:

#+BEGIN_QUOTE
The "Max-Forwards" header field provides a mechanism with the TRACE ([[id:bdc9e3b4-bac3-46c5-9319-31f7f4d6469d][Section 4.3.8]]) and OPTIONS ([[id:f659b35f-7510-4961-ad3a-3ab1b312a681][Section 4.3.7]]) request methods to limit the number of times that the request is forwarded by proxies. This can be useful when the client is attempting to trace a request that appears to be failing or looping mid-chain.
#+END_QUOTE

=Max-Forwards= 头字段为 TRACE（[[id:bdc9e3b4-bac3-46c5-9319-31f7f4d6469d][章节 4.3.8]]）和 OPTIONS（[[id:f659b35f-7510-4961-ad3a-3ab1b312a681][章节 4.3.7]]）请求方法提供了一种方法来限制这个请求被代理所转发的次数。当客户端试图去追踪某个请求可能在请求[[ruby:mid-chain][链路的中部]]转发失败了或者陷入循环的时候，=Max-Forwards= 将非常有用。

#+BEGIN_SRC text
  Max-Forwards = 1*DIGIT
#+END_SRC

#+BEGIN_QUOTE
The =Max-Forwards= value is a decimal integer indicating the remaining number of times this request message can be forwarded.
#+END_QUOTE

=Max-Forwards= 的值是一个十进制整数——这个请求消息能够被转发的剩余次数。

#+BEGIN_QUOTE
Each intermediary that receives a TRACE or OPTIONS request containing a =Max-Forwards= header field *MUST* check and update its value prior to forwarding the request. If the received value is zero (0), the intermediary *MUST NOT* forward the request; instead, the intermediary *MUST* respond as the final recipient. If the received =Max-Forwards= value is greater than zero, the intermediary *MUST* generate an updated =Max-Forwards= field in the forwarded message with a field-value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for =Max-Forwards=.
#+END_QUOTE

接收到一个包含有一个 =Max-Forwards= 头字段的 TRACE 或者 OPTIONS 请求的每一个中间人，在转发这个请求的之前，*必须* 检查并更新 =Max-Forwards= 的值。如果所接收到的值是 0，这个中间人 *禁止* 转发该请求，而是，*必须* 作为[[ruby:final%20recipient][最终接收端]]来响应该请求。如果所接收到的 =Max-Forwards= 值大于 0，这个中间人 *必须* 在转发的消息里生成一个更新后的 =Max-Forwards=，其值可以为以下其中之一：

1. 所接收到的值减去 1；
2. 该接收端自身的 =Max-Forwards= 最大可支持的值。

#+BEGIN_QUOTE
A recipient *MAY* ignore a =Max-Forwards= header field received with any other request methods.
#+END_QUOTE

接收端 *可以* 忽略接收自其他请求方法里的 =Max-Forwards= 头字段。

#+BEGIN_QUOTE
译注：也就是说，应该仅在 TRACE 和 OPTIONS 请求里使用 Max-Forwards 头字段。
#+END_QUOTE

** 5.2. 条件句 / Conditionals
:PROPERTIES:
:ID:       b21923d5-a8f9-4560-8592-92fd9a098bf4
:END:

#+BEGIN_QUOTE
The HTTP conditional request header fields [[[file:RFC7232.org][RFC7232]]] allow a client to place a precondition on the state of the target resource, so that the action corresponding to the method semantics will not be applied if the precondition evaluates to false. Each precondition defined by this specification consists of a comparison between a set of validators obtained from prior representations of the target resource to the current state of validators for the selected representation ([[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][Section 7.2]]). Hence, these preconditions evaluate whether the state of the target resource has changed since a given state known by the client. The effect of such an evaluation depends on the method semantics and choice of conditional, as defined in [[id:fce45320-6c1c-4486-a32b-2c553780d785][Section 5]] of [RFC7232].
#+END_QUOTE

HTTP 的[[ruby:conditional%20request%20fields][条件请求头字段]]【[[file:RFC7232.org][RFC7232]]】让客户端可以在目标资源的状态上设置一个[[ruby:precondition][前置条件]]，使得如果前置条件不成立的话，该请求方法的语义所对应动作不会被执行。本规范所定义的每一种前置条件皆由从目标资源先前的[[ruby:representations][表示形式]]那里获得的一系列[[ruby:validators][验证器]]，与当前应用到已选定的表示形式的验证器的目前状态之间的比较来组成的（[[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][章节 7.2]]）。因此，这些前置条件以客户端的一个给定的已知状态作为参考，来评估目标资源的状态是否已经改变了。这种评估的结果依赖于[[ruby:method%20semantics][请求方法的语义]]以及[[ruby:choice%20of%20conditional][条件句的选择]]，其定义见[[id:fce45320-6c1c-4486-a32b-2c553780d785][【RFC7232】章节 5]]。

| Header Field Name   | Defined in...            |
|---------------------+--------------------------|
| If-Match            | [[id:2c4da24a-b694-472c-8ac3-f09c20a84216][Section 3.1]] of [RFC7232] |
| If-None-Match       | [[id:30878863-9a64-4efe-bc9b-07386eae0ed7][Section 3.2]] of [RFC7232] |
| If-Modified-Since   | [[id:e71fa098-728a-46bf-b792-2388946ea0ee][Section 3.3]] of [RFC7232] |
| If-Unmodified-Since | [[id:7365caf4-85ba-4e10-90a2-1abc298dc569][Section 3.4]] of [RFC7232] |
| If-Range            | [[id:2859ef1f-8309-4b7d-9e22-963391b5822a][Section 3.2]] of [RFC7233] |

** 5.3. 内容协商 / Content Negotiation
:PROPERTIES:
:ID:       99513880-9381-41eb-91ee-483b42d025e8
:END:

#+BEGIN_QUOTE
The following request header fields are sent by a user agent to engage in proactive negotiation of the response content, as defined in [[id:c1d92ed4-69d5-4575-88c2-090534949ccf][Section 3.4.1]]. The preferences sent in these fields apply to any content in the response, including representations of the target resource, representations of error or processing status, and potentially even the miscellaneous text strings that might appear within the protocol.
#+END_QUOTE

下列[[ruby:request%20header%20fields][请求头字段]]会被用户代理所发送以参与对响应内容的[[ruby:proactive%20negotiation][主动协商]]，其定义见[[id:c1d92ed4-69d5-4575-88c2-090534949ccf][章节 3.4.1]]。在这些头字段里[[ruby:preferences][偏好设置（首选项）]]会应用到响应里的所有内容上，这些内容包括：目标资源的表示形式、错误状态或处理中状态的表示形式、甚至是可能出现在协议内的混杂文本字符串。

| Header Field Name | Defined in... |
|-------------------+---------------|
| Accept            | [[id:95575604-c3d4-48d6-a061-325bd7798970][Section 5.3.2]] |
| Accept-Charset    | [[id:4c8262b6-8e4c-4476-ba72-47a096dfbfa7][Section 5.3.3]] |
| Accept-Encoding   | [[id:a8fcc101-3782-4ed0-aec0-561b933e6a5f][Section 5.3.4]] |
| Accept-Language   | [[id:bdbc4965-a98b-451d-91c6-58e51d7c03c9][Section 5.3.5]] |

*** 5.3.1. 质量值 / Quality Values
:PROPERTIES:
:ID:       91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37
:END:

#+BEGIN_QUOTE
Many of the request header fields for proactive negotiation use a common parameter, named "q" (case-insensitive), to assign a relative "weight" to the preference for that associated kind of content. This weight is referred to as a "quality value" (or "qvalue") because the same parameter name is often used within server configurations to assign a weight to the relative quality of the various representations that can be selected for a resource.
#+END_QUOTE

许多用于[[ruby:proactive%20negotiation][主动协商]]的请求头字段都会使用一个名为 "q"（不区分大小写）的[[ruby:common%20parameter][通用型参数]]，来分别向内容的对应类型的[[ruby:preference][偏爱度]]赋予一个相对的“[[ruby:weight][权重]]”。由于同名的参数 "q" 常常用在服务器配置里来对某个资源的各种可用的表现形式所对应的质量值赋予一个权重，因此，这个权重被称为“[[ruby:quality%20value][质量值]]”（或者称为 =qvalue=）。

#+BEGIN_QUOTE
The weight is normalized to a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means "not acceptable". If no "q" parameter is present, the default weight is 1.
#+END_QUOTE

权重被[[ruby:normalized][规范化]]为一个 0 到 1 范围内的实数值，其中，最小值是 0.001（优先级最低），最大值为 1（优先级最高），权重为 0 代表“不被接受”。如果没有出现参数 "q"，那么默认的权重为 1。 

#+BEGIN_SRC text
  weight = OWS ";" OWS "q=" qvalue
  qvalue = ( "0" [ "." 0*3DIGIT ] )
         / ( "1" [ "." 0*3("0") ] )
#+END_SRC

#+BEGIN_QUOTE
A sender of qvalue *MUST NOT* generate more than three digits after the decimal point. User configuration of these values ought to be limited in the same fashion.
#+END_QUOTE

发送端 *禁止* 生成小数点后超过三位小数的 =qvalue=。应该要以相同的方式来限制这些权重的用户配置。

*** 5.3.2. Accept
:PROPERTIES:
:ID:       95575604-c3d4-48d6-a061-325bd7798970
:END:

#+BEGIN_QUOTE
The "Accept" header field can be used by user agents to specify response media types that are acceptable. =Accept= header fields can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.
#+END_QUOTE

用户代理可以使用 =Accept= 头字段来[[ruby:specify][指定]]可以接受响应的哪些[[ruby:media%20types][媒体类型]]。=Accept= 头字段可以用来[[ruby:indicate][表明]]：请求是明确限定在一个[[ruby:desired%20types][期望类型]]的小集合的，正如请求一个[[ruby:in-line%20image][内嵌图片]]这种情况一样。

#+BEGIN_SRC text
  Accept = #( media-range [ accept-params ] )

  media-range    = ( "*/*"
                   / ( type "/" "*" )
                   / ( type "/" subtype )
                   ) *( OWS ";" OWS parameter )
  accept-params  = weight *( accept-ext )
  accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
#+END_SRC

#+BEGIN_QUOTE
译注：Accept 的 ABNF 定义使用了 =#= 列表规则，因此 =Accept= 接受多个媒体类型（=media-range=）及其对应的参数，每个媒体类型之间使用逗号分隔。媒体范围、媒体参数以及扩展参数之间使用分号分隔。
#+END_QUOTE

#+BEGIN_QUOTE
The asterisk "*" character is used to group media types into ranges, with "\ast{}/\ast{}" indicating all media types and "type/*" indicating all subtypes of that type. The =media-range= can include media type parameters that are applicable to that range.
#+END_QUOTE

字符 "*" 用于将媒体类型归为一个范围，使用 "\ast{}/\ast{}" 来表明任何媒体类型，使用 "type/*" 来表明该 type 类型的任何子类型。=media-range= 能够包含该 range 所接收的媒体类型参数。

#+BEGIN_QUOTE
Each =media-range= might be followed by zero or more applicable media type parameters (e.g., =charset=), an optional "q" parameter for indicating a relative weight ([[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][Section 5.3.1]]), and then zero or more extension parameters. The "q" parameter is necessary if any extensions (accept-ext) are present, since it acts as a separator between the two parameter sets.
#+END_QUOTE

每个 =media-range= 后面可以跟随：0 个以上合适的[[ruby:media%20type%20parameters][媒体类型参数]]（比如 =charset=）；一个可选的 "q" 参数用于指明一个相对的权重（[[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][章节 5.3.1]]）；以及在这些可选项其后还可以有 0 个以上[[ruby:extension%20parameters][扩展参数]]。如果存在任何扩展（=accept-ext=），那么必须要设置 "q" 参数，这是因为它在两种参数集中扮演着一个分隔符的角色。

#+BEGIN_QUOTE
*Note:* Use of the "q" parameter name to separate media type parameters from =Accept= extension parameters is due to historical practice. Although this prevents any media type parameter named "q" from being used with a media range, such an event is believed to be unlikely given the lack of any "q" parameters in the IANA media type registry and the rare usage of any media type parameters in =Accept=. Future media types are discouraged from registering any parameter named "q".
#+END_QUOTE

*注意：* 之所以使用 "q" 参数名来分隔媒体参数与扩展参数是出于[[ruby:historical%20practice][历史实践]]的原因。虽然这样做导致了 "q" 这个名字不能用来作为一个媒体类型的范围——基于 IANA 媒体类型注册表里的没有注册任何 "q" 参数，以及在 =Accept= 里极少使用媒体类型参数这些事实，相信不太可能会发生这种情况。将来新增的媒体类型会被劝阻注册任何命名为 "q" 的参数。

#+BEGIN_QUOTE
The example
#+END_QUOTE

例如：

#+BEGIN_SRC text
  Accept: audio/*; q=0.2, audio/basic
#+END_SRC

#+BEGIN_QUOTE
is interpreted as "I prefer =audio/basic=, but send me any audio type if it is the best available after an 80% markdown in quality".
#+END_QUOTE

上面例子可以解释为：“我首选（偏爱） =audio/basic=，但是，如果[[ruby:best available][最佳可用]]的质量值调低 80% 以上的话，可以发送给我任意音频类型”。

#+BEGIN_QUOTE
A request without any =Accept= header field implies that the user agent will accept any media type in response. If the header field is present in a request and none of the available representations for the response have a media type that is listed as acceptable, the origin server can either honor the header field by sending a =406 (Not Acceptable)= response or disregard the header field by treating the response as if it is not subject to content negotiation.
#+END_QUOTE

一个请求里没有任何 =Accept= 头字段，意味着用户代理接受任何媒体类型的响应。如果在一个请求里出现了 =Accept=，但响应没有任何[[ruby:available%20representations][可用的表现形式]]所带有的媒体类型是被其列为可接受的，那么，源服务器可以[[ruby:honor][遵守]] =Accept= 头字段的要求而返回一个 =406 (Not Acceptable)= 响应，也可以[[ruby:disregard][忽视]]该头字段的要求就好像它并没有受到[[ruby:content%20negotiation][内容协商]]的影响一样。

#+BEGIN_QUOTE
译注：也就是说，客户端提供了 =Accept= 头字段后并不能保证源服务器会按照它的要求来响应内容，选择权仍然在源服务器中。因为这是[[ruby:proactive%20content%20negotiation][主动内容协商]]嘛。
#+END_QUOTE

#+BEGIN_QUOTE
A more elaborate example is
#+END_QUOTE

一个更复杂的例子：

#+BEGIN_SRC text
  Accept: text/plain; q=0.5, text/html,
          text/x-dvi; q=0.8, text/x-c
#+END_SRC

#+BEGIN_QUOTE
Verbally, this would be interpreted as "=text/html= and =text/x-c= are the equally preferred media types, but if they do not exist, then send the =text/x-dvi= representation, and if that does not exist, send the =text/plain= representation".
#+END_QUOTE

通俗来说，上面例子可以解释为：“=text/html= 和 =text/x-c= 同样是首选的媒体类型。但是，如果它们都不存在的话，发送 =text/x-dvi= 类型的[[ruby:representation][表示形式]]。如果 =text/x-dvi= 同样也不存在的话，发送 =text/plain= 类型的表示形式。”

#+BEGIN_QUOTE
译注：=text/html= 和 =text/x-c= 都没有指定 "q" 值，则默认权重为 1（最高优先级）。
#+END_QUOTE

#+BEGIN_QUOTE
Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence. For example,
#+END_QUOTE

[[ruby:media%20ranges][媒体的范围]]可以通过更明确的媒体范围，或者更明确的媒体类型来[[ruby:overridden][重写]]。如果超过一个媒体范围应用到一个给定类型上，那么，优先使用最明确的那一个。例如：

#+BEGIN_SRC text
  Accept: text/*, text/plain, text/plain;format=flowed, */*
#+END_SRC

#+BEGIN_QUOTE
have the following precedence:

1. text/plain;format=flowed
2. text/plain
3. text/*
4. \ast{}/\ast{}
#+END_QUOTE

具有以下[[ruby:precedence][优先级]]：

1. text/plain;format=flowed
2. text/plain
3. text/*
4. \ast{}/\ast{}

#+BEGIN_QUOTE
译注：可以看出，在质量值相等的前提下，范围越精准，优先级越高。
#+END_QUOTE

#+BEGIN_QUOTE
The media type quality factor associated with a given type is determined by finding the media range with the highest precedence that matches the type. For example,
#+END_QUOTE

对应某个给定类型的媒体类型质量值，是通过查找匹配该类型的最高优先级的媒体范围来确定的。

#+BEGIN_SRC text
  Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
          text/html;level=2;q=0.4, */*;q=0.5
#+END_SRC

#+BEGIN_QUOTE
would cause the following values to be associated:
#+END_QUOTE

会导致以下对应的质量值：

| Media Type        | Quality Value |
|-------------------+---------------|
| text/html;level=1 |             1 |
| text/html         |           0.7 |
| text/plain        |           0.3 |
| image/jpeg        |           0.5 |
| text/html;level=2 |           0.4 |
| text/html;level=3 |           0.7 |

#+BEGIN_QUOTE
*Note:* A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent is a closed system that cannot interact with other rendering agents, this default set ought to be configurable by the user.
#+END_QUOTE

*注意：* 对于确定的媒体范围来说，用户代理可能被提供一个默认的质量值集合。但是，除非该用户代理是一个无法与其他[[ruby:rendering%20agents][渲染中介]]交互的封闭的系统，这个默认集合应该由用户来配置。

*** 5.3.3. Accept-Charset
:PROPERTIES:
:ID:       4c8262b6-8e4c-4476-ba72-47a096dfbfa7
:END:

#+BEGIN_QUOTE
The "Accept-Charset" header field can be sent by a user agent to indicate what charsets are acceptable in textual response content. This field allows user agents capable of understanding more comprehensive or special-purpose charsets to signal that capability to an origin server that is capable of representing information in those charsets.
#+END_QUOTE

用户代理可以发送 =Accept-Charset= 头字段来表明：在文本类型的响应内容中，它接受哪些[[ruby:charsets][字符集]]。这个头字段让那些能够理解更加综合或者更加专业的字符集的用户代理，可以向那些能够以所述字符集来表示信息的源服务器，来表达这种信号：与之通信的客户端具备这种能力。

#+BEGIN_SRC text
  Accept-Charset = 1#( ( charset / "*" ) [ weight ] )
#+END_SRC

#+BEGIN_QUOTE
Charset names are defined in [[id:dc31dd72-3e53-4fb1-b3a6-e6716f61b202][Section 3.1.1.2]]. A user agent *MAY* associate a quality value with each charset to indicate the user's relative preference for that charset, as defined in [[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][Section 5.3.1]]. An example is
#+END_QUOTE

字符集名称的定义见[[id:dc31dd72-3e53-4fb1-b3a6-e6716f61b202][章节 3.1.1.2]]。用户代理 *可以* 向每个字符集关联一个质量值，来表明：该用户对于那种字符集的相对偏爱度，其定义见[[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][章节 5.3.1]]。以下是一个例子：

#+BEGIN_SRC text
  Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
#+END_SRC

#+BEGIN_QUOTE
The special value "*", if present in the =Accept-Charset= field, matches every charset that is not mentioned elsewhere in the =Accept-Charset= field. If no "*" is present in an =Accept-Charset= field, then any charsets not explicitly mentioned in the field are considered "not acceptable" to the client.
#+END_QUOTE

如果 =Accept-Charset= 的字段值里出现了特殊值 "*" 的话，说明匹配任何未在该域里提及到的字符集。如果 =Accept-Charset= 的字段值里没有出现 "*"，说明任何没有在该域里明确提及到的字符集是不为客户端所接受的。

#+BEGIN_QUOTE
A request without any =Accept-Charset= header field implies that the user agent will accept any charset in response. Most general-purpose user agents do not send =Accept-Charset=, unless specifically configured to do so, because a detailed list of supported charsets makes it easier for a server to identify an individual by virtue of the user agent's request characteristics ([[id:58ca9032-65b1-47ff-b759-d1cedc245d4b][Section 9.7]]).
#+END_QUOTE

请求里没有任何 =Accept-Charset= 头字段意味着该用户代理在响应里将接受的任何字符集。大多数[[ruby:general-purpose][通用型]]的用户代理并不会发送 =Accept-Charset=，除非明确地配置为这样做，这是因为凭借用户代理的[[ruby:request%20characteristics][请求特征]]（[[id:58ca9032-65b1-47ff-b759-d1cedc245d4b][章节 9.7]]），一个支持的字符集的详细列表让一个服务器（相对 =Accept-Charset= 来说）更加轻松地标识一个[[ruby:individual][个体]]。

#+BEGIN_QUOTE
If an =Accept-Charset= header field is present in a request and none of the available representations for the response has a charset that is listed as acceptable, the origin server can either honor the header field, by sending a =406 (Not Acceptable)= response, or disregard the header field by treating the resource as if it is not subject to content negotiation.
#+END_QUOTE

如果请求里出现了 =Accept-Charset= 头字段，但响应没有任何[[ruby:available%20representations][待选表现形式]]所带有的字符集是被其列为可接受的，那么，源服务器可以[[ruby:honor][遵守]] =Accept-Charset= 头字段的要求而返回一个 =406 (Not Acceptable)= 响应，也可以[[ruby:disregard][忽视]]该头字段的要求就好像它并没有受到[[ruby:content%20negotiation][内容协商]]的影响一样。 

*** 5.3.4. Accept-Encoding
:PROPERTIES:
:ID:       a8fcc101-3782-4ed0-aec0-561b933e6a5f
:END:

#+BEGIN_QUOTE
The "Accept-Encoding" header field can be used by user agents to indicate what response content-codings ([[id:a67acb58-7b0a-49c8-8de4-5dd8a4ab9e61][Section 3.1.2.1]]) are acceptable in the response. An "identity" token is used as a synonym for "no encoding" in order to communicate when no encoding is preferred.
#+END_QUOTE

用户代理可以使用 =Accept-Encoding= 头字段来表明：在响应中，它接受哪些响应[[ruby:content-codings][内容编码]]（[[id:a67acb58-7b0a-49c8-8de4-5dd8a4ab9e61][章节 3.1.2.1]]）。"identity" 标记用于作为一个“[[ruby:no%20encoding][没有编码]]”的同义词以便在首选不编码的情况下进行通信。

#+BEGIN_SRC text
  Accept-Encoding  = #( codings [ weight ] )
  codings          = content-coding / "identity" / "*"
#+END_SRC

#+BEGIN_QUOTE
Each codings value *MAY* be given an associated quality value representing the preference for that encoding, as defined in [[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][Section 5.3.1]]. The asterisk "*" symbol in an =Accept-Encoding= field matches any available content-coding not explicitly listed in the header field.
#+END_QUOTE

每个 codings 值都 *可以* 分别被给予一个相关联的[[ruby:quality%20value][质量值]]来表示对应的编码的优先级，其定义见[[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][章节 5.3.1]]。如果 =Accept-Encoding= 的字段值里出现了符号 "*" 的话，说明匹配任何没有被明确列举在该域里的[[ruby:available%20content-coding][可用的内容编码]]。

#+BEGIN_QUOTE
For example,
#+END_QUOTE

例如：

#+BEGIN_EXAMPLE
  Accept-Encoding: compress, gzip
  Accept-Encoding:
  Accept-Encoding: *
  Accept-Encoding: compress;q=0.5, gzip;q=1.0
  Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
#+END_EXAMPLE

#+BEGIN_QUOTE
A request without an =Accept-Encoding= header field implies that the user agent has no preferences regarding content-codings. Although this allows the server to use any content-coding in a response, it does not imply that the user agent will be able to correctly process all encodings.
#+END_QUOTE

请求里没有 =Accept-Encoding= 头字段，意味着该用户代理没有指定关于[[ruby:content-codings][内容编码]]的[[ruby:preferences][偏好程度]]。虽然这样做让服务器可以在响应里使用任何内容编码，但它并不意味着用户代理能够正确处理所有编码。

#+BEGIN_QUOTE
A server tests whether a content-coding for a given representation is acceptable using these rules:

1. If no =Accept-Encoding= field is in the request, any content-coding is considered acceptable by the user agent.
2. If the representation has no content-coding, then it is acceptable by default unless specifically excluded by the =Accept-Encoding= field stating either "identity;q=0" or "*;q=0" without a more specific entry for "identity".
3. If the representation's content-coding is one of the content-codings listed in the =Accept-Encoding= field, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in [[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][Section 5.3.1]], a qvalue of 0 means "not acceptable".)
4. If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.
#+END_QUOTE

服务器使用以下规则来测试一个给定[[ruby:representation][表示形式]]的某种内容编码是否为客户端所接受：

1. 如果请求里没有出现 =Accept-Encoding=，那么，可以认为任何内容编码皆为用户代理所接受。
2. 如果该表示形式没有内容编码，那么，默认是可接受，除非客户端使用以下方式来明确地排除无内容编码的情况：=Accept-Encoding= 的字段值以 "identity;q=0" 或者 "*;q=0" 开头，并且不再有比 "identity" 更明确的条目。
3. 如果该表示形式的内容编码是 =Accept-Encoding= 头字段里所列举的其中之一，那么，该内容编码可接受的，除非它伴随着的一个值为 0 的[[ruby:qvalue][质量值]]（定义见[[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][章节 5.3.1]]，其值为 0 意味着“[[ruby:not%20acceptable][不接受]]”）。
4. 如果多个内容编码都是可接受的，那么，带有质量值为最大且非 0 的内容编码作为首选。

#+BEGIN_QUOTE
An =Accept-Encoding= header field with a combined field-value that is empty implies that the user agent does not want any content-coding in response. If an =Accept-Encoding= header field is present in a request and none of the available representations for the response have a content-coding that is listed as acceptable, the origin server *SHOULD* send a response without any content-coding.
#+END_QUOTE

如果 =Accept-Encoding= 头字段里其中一个[[ruby:combined%20field-value][组合条目值]]为空，意味着用户代理并不想在响应里进行任何的内容编码。如果请求里出现了 =Accept-Encoding= 头字段，但响应没有任何[[ruby:available%20representations][可用的表示形式]]所带有的内容编码是被其列为可接受的，那么，源服务器 *应当* 在没有任何内容编码的情况下发送响应。

#+BEGIN_QUOTE
*Note:* Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings. This means that qvalues might not work and are not permitted with x-gzip or x-compress.
#+END_QUOTE

*注意：* 大多数 HTTP/1.0 的应用并不能识别或者遵循内容编码相关联的质量值。这意味着，质量值可能并不一定有用，并且它不能带有 x-gzip 或者 x-compress。

*** 5.3.5. Accept-Language
:PROPERTIES:
:ID:       bdbc4965-a98b-451d-91c6-58e51d7c03c9
:END:

#+BEGIN_QUOTE
The "Accept-Language" header field can be used by user agents to indicate the set of natural languages that are preferred in the response. Language tags are defined in [[id:0a52652d-e5e8-40f9-ba1a-f96c45969b85][Section 3.1.3.1]].
#+END_QUOTE

用户代理可以使用 =Accept-Language= 头字段来表明：在响应中首选使用的[[ruby:natural%20language][自然语言]]集合。[[ruby:language%20tags][语言标签]]的定义见[[id:0a52652d-e5e8-40f9-ba1a-f96c45969b85][章节 3.1.3.1]]。

#+BEGIN_SRC text
  Accept-Language = 1#( language-range [ weight ] )
  language-range  = 
            <language-range, see [RFC4647], Section 2.1>
#+END_SRC

#+BEGIN_QUOTE
Each language-range can be given an associated quality value representing an estimate of the user's preference for the languages specified by that range, as defined in [[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][Section 5.3.1]]. For example,
#+END_QUOTE

上述每个 =language-range= 都可以分别被给予一个相关联的[[ruby:quality%20value][质量值]]来表示用户对由该范围所指定的语言的偏爱程度，其定义见[[id:91059de1-4a9b-4d9f-8be2-eb4d2d6ddc37][章节 5.3.1]]。例如：

#+BEGIN_EXAMPLE
  Accept-Language: da, en-gb;q=0.8, en;q=0.7
#+END_EXAMPLE

#+BEGIN_QUOTE
would mean: "I prefer Danish, but will accept British English and other types of English".
#+END_QUOTE

意为：“我首选[[ruby:Danish][丹麦语]]，但也会接受[[ruby:British%20English][英式英语]]以及其他类型的英语”。

#+BEGIN_QUOTE
A request without any =Accept-Language= header field implies that the user agent will accept any language in response. If the header field is present in a request and none of the available representations for the response have a matching language tag, the origin server can either disregard the header field by treating the response as if it is not subject to content negotiation or honor the header field by sending a =406 (Not Acceptable)= response. However, the latter is not encouraged, as doing so can prevent users from accessing content that they might be able to use (with translation software, for example).
#+END_QUOTE

如果请求里没有任何 =Accept-Language= 头字段，意味着该用户代理将会在响应里接受任何语言。如果请求里出现了该头字段，但响应没有任何[[ruby:avaliable%20representations][可用的表示形式]]带有与之相匹配的语言标签，源服务器可以[[ruby:disregard][忽视]]该头字段的要求就好像它并没有受到[[ruby:content%20negotiation][内容协商]]的影响一样，可以[[ruby:honor][遵守]]该头字段的要求而返回一个 =406 (Not Acceptable)= 响应。但是，并不鼓励使用后者这种方式，这是因为后者会阻止用户访问他们可能能够使用的内容（例如，使用翻译软件等）。

#+BEGIN_QUOTE
Note that some recipients treat the order in which language tags are listed as an indication of descending priority, particularly for tags that are assigned equal quality values (no value is the same as q=1). However, this behavior cannot be relied upon. For consistency and to maximize interoperability, many user agents assign each language tag a unique quality value while also listing them in order of decreasing quality. Additional discussion of language priority lists can be found in [[https://tools.ietf.org/html/rfc4647#section-2.3][Section 2.3]] of [RFC4647].
#+END_QUOTE

需要注意的是，某些接收端会将语言标签在 =Accept-Language= 里的列举顺序作为优先级的顺序（[[ruby:descending][降序]]），特别是对于赋值为相等质量值（没有值时，等价于 q=1）的标签。但是，不能够依赖这种行为。为了[[ruby:consistency][一致性]]以及[[ruby:maximize%20interoperability][最化大互操作性]]，许多用户代理会对每种语言标签赋值一个唯一的质量值并且将它们以质量值降序的顺序列举到头字段里。对语言优先级列表的更多讨论能够在[[https://tools.ietf.org/html/rfc4647#section-2.3][【RFC4647】章节 2.3]] 里找到。

#+BEGIN_QUOTE
For matching, [[https://tools.ietf.org/html/rfc4647#section-3][Section 3]] of [RFC4647] defines several matching schemes. Implementations can offer the most appropriate matching scheme for their requirements. The "Basic Filtering" scheme ([RFC4647], [[https://tools.ietf.org/html/rfc4647#section-3.3.1][Section 3.3.1]]) is identical to the matching scheme that was previously defined for HTTP in [[https://tools.ietf.org/html/rfc2616#section-14.4][Section 14.4]] of [RFC2616].
#+END_QUOTE

为了匹配，[[https://tools.ietf.org/html/rfc4647#section-3][【RFC4647】章节 3]] 定义了若干[[ruby:matching%20schemes][匹配方案]]。实现可以以它们的要求来提供最合适的匹配方案。“[[ruby:Basic%20Filtering][基础过滤]]”方案（[[https://tools.ietf.org/html/rfc4647#section-3.3.1][【RFC4647】章节 3.3.1]]）等价于之前[[https://tools.ietf.org/html/rfc2616#section-14.4][【RFC2616】章节 14.4]] 为 HTTP 而定义的匹配方案。

#+BEGIN_QUOTE
It might be contrary to the privacy expectations of the user to send an =Accept-Language= header field with the complete linguistic preferences of the user in every request ([[id:58ca9032-65b1-47ff-b759-d1cedc245d4b][Section 9.7]]).
#+END_QUOTE

在用户每次请求里的完整的语言[[ruby:preferences][偏爱]]可能会和用户发送 =Accept-Language= 头字段的[[ruby:privacy%20expectations][隐私期望]]相悖（[[id:58ca9032-65b1-47ff-b759-d1cedc245d4b][章节 9.7]]）。

#+BEGIN_QUOTE
Since intelligibility is highly dependent on the individual user, user agents need to allow user control over the linguistic preference (either through configuration of the user agent itself or by defaulting to a user controllable system setting). A user agent that does not provide such control to the user *MUST NOT* send an =Accept-Language= header field.
#+END_QUOTE

正由于[[ruby:intelligibility][可理解性]]是高度依赖于单独个体的，因此，用户代理需要让用户来控制语言[[ruby:preferences][偏爱]]（可以通过用户代理自己的配置，也可以默认为用户所控制的系统设置）。不提供这些控制的用户代理 *禁止* 发送 =Accept-Language= 头字段。

#+BEGIN_QUOTE
*Note:* User agents ought to provide guidance to users when setting a preference, since users are rarely familiar with the details of language matching as described above. For example, users might assume that on selecting "en-gb", they will be served any kind of English document if British English is not available. A user agent might suggest, in such a case, to add "en" to the list for better matching behavior.
#+END_QUOTE

*注意：* 当需要选择语言偏爱的时候，用户代理应该向用户提供引导，这是因为用户很少熟悉上述[[ruby:language%20matching][语言匹配]]相关的细节。例如，用户可以假设在选择 "en-gb" 的时候，如果英式英文不可用的情况下，用户代理会提供给他们任何类型的英文文档。在这种场景下，用户代理可以建议将 "en" 添加到列表中以为了更好的匹配行为。

** 5.4. 认证凭证 / Authentication Credentials

#+BEGIN_QUOTE
Two header fields are used for carrying authentication credentials, as defined in [[[file:RFC7235.org][RFC7235]]]. Note that various custom mechanisms for user authentication use the =Cookie= header field for this purpose, as defined in [[[https://tools.ietf.org/html/rfc6265][RFC6265]]].
#+END_QUOTE

以下两个头字段是用于装载认证凭证的，其定义见【[[file:RFC7235.org][RFC7235]]】。需要注意的是，很多种用于用户身份验证的自定义机制使用了 =Cookie= 头字段来实现上述目的，其定义见【[[https://tools.ietf.org/html/rfc6265][RFC6265]]】。

| Header Field Name   | Defined in...            |
|---------------------+--------------------------|
| Authorization       | [[id:14671c8e-e5a4-4f9d-ad1d-6460328ed7f5][Section 4.2]] of [RFC7235] |
| Proxy-Authorization | [[id:89c3125a-e7ef-48ea-a2c1-ff4c57214389][Section 4.4]] of [RFC7235] |

** 5.5. 请求上下文/ Request Context

#+BEGIN_QUOTE
The following request header fields provide additional information about the request context, including information about the user, user agent, and resource behind the request.
#+END_QUOTE

以下请求头字段提供了请求上下文相关的额外信息，包括用户、用户代理、请求背后的资源等相关的信息。

| Header Field Name | Defined in... |
|-------------------+---------------|
| Form              | [[id:197fca23-d64a-470b-9c12-31ff7d2ddf02][Section 5.5.1]] |
| Referer           | [[id:5738c39d-f031-4866-b280-76cc7e2ff433][Section 5.5.2]] |
| User-Agent        | [[id:d3473599-e20b-4b5d-9600-cb05340e8687][Section 5.5.3]] |

*** 5.5.1. From
:PROPERTIES:
:ID:       197fca23-d64a-470b-9c12-31ff7d2ddf02
:END:

#+BEGIN_QUOTE
The "From" header field contains an Internet email address for a human user who controls the requesting user agent. The address ought to be machine-usable, as defined by "mailbox" in [[https://tools.ietf.org/html/rfc5322#section-3.4][Section 3.4]] of [RFC5322]:
#+END_QUOTE

=From= 头字段包含一个控制现正发起请求的用户代理的人类用户的一个电子邮箱地址。该地址应该是[[ruby:machine-usable][机器可用的]]，正如[[https://tools.ietf.org/html/rfc5322#section-3.4][【RFC5322】章节 3.4]] 中的 "mailbox" 所定义的一样。

#+BEGIN_SRC text
  From    = mailbox

  mailbox = <mailbox, see [RFC5322], Section 3.4>
#+END_SRC

#+BEGIN_QUOTE
An example is:
#+END_QUOTE

一个例子：

#+BEGIN_EXAMPLE
  From: webmaster@example.org
#+END_EXAMPLE

#+BEGIN_QUOTE
The =From= header field is rarely sent by non-robotic user agents. A user agent *SHOULD NOT* send a =From= header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy.
#+END_QUOTE

=From= 头字段很少由[[ruby:non-robotic][非机器人]]的用户代理所发送。用户代理 *不应当* 在未经用户显式配置（许可）的情况下发送 =From= 头字段，这是因为这样做可能会与用户的[[ruby:privacy%20interests][隐私利益]]或者他们网站的[[ruby:security%20policy][安全策略]]相冲突。

#+BEGIN_QUOTE
A robotic user agent *SHOULD* send a valid =From= header field so that the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.
#+END_QUOTE

机器人用户代理 *应当* 发送一个合法的 =From= 头字段，以便于如果服务器发生故障（比如该机器人发送了过多的、不必要的或者非法的请求）的时候，能够联系到负责运行该机器人的人。

#+BEGIN_QUOTE
A server *SHOULD NOT* use the =From= header field for access control or authentication, since most recipients will assume that the field value is public information.
#+END_QUOTE

服务器 *不应当* 将这个 =From= 头字段用于[[ruby:access%20control][访问控制]]或者[[ruby:authentication][身份验证]]，这是因为大多数接收端将会假定这个字段值是一种公共的信息。

*** 5.5.2. Referer
:PROPERTIES:
:ID:       5738c39d-f031-4866-b280-76cc7e2ff433
:END:

#+BEGIN_QUOTE
The "Referer" [sic] header field allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the "referrer", though the field name is misspelled). A user agent *MUST NOT* include the =fragment= and =userinfo= components of the URI reference [[[https://tools.ietf.org/html/rfc3986][RFC3986]]], if any, when generating the =Referer= field value.
#+END_QUOTE

=Referer= 头字段让用户代理可以指定一个 URI 引用，来表明：本次请求的[[ruby:target%20URI][目标 URI]] 是从哪一个资源那里获得的（也就是说，"referer" 指的是“引用页、引用者”，虽然这个字段名称存在拼写错误，本应该是 "referrer"）。用户代理在生成 =Referer= 头字段的时候，*禁止* 包含有 URI 引用里的 =fragment= 以及 =userinfo= 组件【[[https://tools.ietf.org/html/rfc3986][RFC3986]]】。 

#+BEGIN_QUOTE
译注：自【RFC7231】开始，已不再允许在 HTTP 和 HTTPS URI 中出现 =userinfo= （也就是说，用户名和密码）了，因为它在通信线路上传输时存在安全问题（见[[id:cdfe1d9f-fe54-40a8-936b-aa02154989f9][【RFC7230】附录 A.1]]）。而 =fragment= 标识是保留给客户端处理的，也不必提交到服务器上。
#+END_QUOTE

#+BEGIN_SRC text
  Referer = absolute-URI / partial-URI
#+END_SRC

#+BEGIN_QUOTE
The =Referer= header field allows servers to generate back-links to other resources for simple analytics, logging, optimized caching, etc. It also allows obsolete or mistyped links to be found for maintenance. Some servers use the =Referer= header field as a means of denying links from other sites (so-called "deep linking") or restricting cross-site request forgery (CSRF), but not all requests contain it.
#+END_QUOTE

=Referer= 头字段让服务器可以生成[[ruby:back-links][反向链接]]到其他资源上，以达到[[ruby:simple%20analytics][简单分析]]、[[ruby:logging][日志记录]]、[[ruby:optimized%20caching][缓存优化]]等目的。它还让弃用的或者打错的链接得以被发现，以便修复。某些服务器使用 =Referer= 头字段来作为拒绝来自其他网站的链接（即所谓的“深度链接”）或者限制[[ruby:cross-site%20request%20forgery][跨站请求伪造]]（CSRF）的一种方法，但并不是所有请求都会包含这个头字段。

#+BEGIN_QUOTE
Example:
#+END_QUOTE

例如：

#+BEGIN_EXAMPLE
  Referer: http://www.example.org/hypertext/Overview.html
#+END_EXAMPLE

#+BEGIN_QUOTE
If the target URI was obtained from a source that does not have its own URI (e.g., input from the user keyboard, or an entry within the user's bookmarks/favorites), the user agent *MUST* either exclude the =Referer= field or send it with a value of "about:blank".
#+END_QUOTE

如果[[ruby:target%20URI][目标 URI]]是从一个资源那里获得的，但该资源并没有自己的 URI（比如，从键盘直接输入网址，或者在用户的书签/收藏夹内的某个条目），那么，用户代理 *必须* 排除掉 =Referer= 头字段，或者将它赋值为 "about:blank" 来发送。

#+BEGIN_QUOTE
译注：从网站统计的角度上看，用户通过在浏览器上直接输入网址或书签对网站进行访问的行为，就是所谓的[[https://baike.baidu.com/item/%25E7%259B%25B4%25E6%258E%25A5%25E8%25AE%25BF%25E9%2597%25AE/8845360?fr=aladdin#2][直接访问]]。服务器的判断依据是请求是否有 =Referer= 或者其值是否为 "about:blank"。
#+END_QUOTE

#+BEGIN_QUOTE
The =Referer= field has the potential to reveal information about the request context or browsing history of the user, which is a privacy concern if the referring resource's identifier reveals personal information (such as an account name) or a resource that is supposed to be confidential (such as behind a firewall or internal to a secured service). Most general-purpose user agents do not send the =Referer= header field when the referring resource is a local "file" or "data" URI. A user agent *MUST NOT* send a =Referer= header field in an unsecured HTTP request if the referring page was received with a secure protocol. See [[id:ed824807-db16-4f5b-ab13-2366f5cfc0f3][Section 9.4]] for additional security considerations.
#+END_QUOTE

=Referer= 头字段存在暴露请求上下文或用户浏览历史记录的相关信息的可能，如果所引用的资源的标识符暴露了个人信息（比如一个账户名）或者暴露了一个本应是保密的资源（比如在一个防火墙之后的，或者一个安全服务内部的）的话，这是需要关注的隐私问题。当所引用的资源是一个本地文件或者一个本地数据的 URI 的时候，大多数通用型的用户代理并不会发送 =Referer= 头字段。如果所引用的页面使用的是一种安全的协议的话，用户代理 *禁止* 在一个不安全的 HTTP 请求中带有 =Referer= 字段值。更多安全注意事项见[[id:ed824807-db16-4f5b-ab13-2366f5cfc0f3][章节 9.4]]。

#+BEGIN_QUOTE
Some intermediaries have been known to indiscriminately remove =Referer= header fields from outgoing requests. This has the unfortunate side effect of interfering with protection against CSRF attacks, which can be far more harmful to their users. Intermediaries and user agent extensions that wish to limit information disclosure in =Referer= ought to restrict their changes to specific edits, such as replacing internal domain names with pseudonyms or truncating the =query= and/or =path= components. An intermediary *SHOULD NOT* modify or delete the =Referer= header field when the field value shares the same scheme and host as the request target.
#+END_QUOTE

目前已经知道某些[[ruby:intermediaries][中间人]]会在其[[ruby:outgoing%20requests][发出的请求]]中任意移除 =Referer= 头字段。这样做会对抵御 CSRF 攻击造成干扰，这种副作用对用户来说更加有害。以[[ruby:limit][限制]] =Referer= 的信息暴露为目的中间人扩展以及用户代理扩展应该将它们对 =Referer= 的改变[[ruby:restrict][限制]]在特定的编辑范围内，比如使用[[ruby:pseudonyms][化名]]来替换掉内部域名，或者截断 =query= 和/或 =path= 组件等。当 =Referer= 的字段值与[[ruby:request%20target][请求目标]]使用的是相同的 =scheme= 和 =host= 的时候，中间人 *不应当* 修改或者删除 =Referer= 头字段。

*** 5.5.3. User-Agent
:PROPERTIES:
:ID:       d3473599-e20b-4b5d-9600-cb05340e8687
:END:

#+BEGIN_QUOTE
The "User-Agent" header field contains information about the user agent originating the request, which is often used by servers to help identify the scope of reported interoperability problems, to work around or tailor responses to avoid particular user agent limitations, and for analytics regarding browser or operating system use. A user agent *SHOULD* send a =User-Agent= field in each request unless specifically configured not to do so.
#+END_QUOTE

=User-Agent= 头字段包含了[[ruby:originating%20the%20request][发起请求]]的用户代理的相关信息。=User-Agent= 常被服务器用来帮助识别报告出互操作性问题的范围，[[ruby:work%20around][变通]]或[[ruby:tailor][调整]]响应以避免个别用户代理的限制，以及分析浏览器或操作系统的使用情况等。用户代理 *应当* 在每个请求里包含一个 =User-Agent= 头字段，除非被明确配置为不要这样做。

#+BEGIN_SRC text
  User-Agent = product *( RWS ( product / comment ) )
#+END_SRC

#+BEGIN_QUOTE
The =User-Agent= field-value consists of one or more product identifiers, each followed by zero or more comments ([[id:a6c4dceb-8a19-4799-a39b-b7240755c672][Section 3.2]] of [RFC7230]), which together identify the user agent software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software. Each product identifier consists of a name and optional version.
#+END_QUOTE

=User-Agent= 的字段值由一个或多个[[ruby:product%20identifiers][产品标识符]]组成，每个产品标识符后面跟随零个或多个注释（[[id:a6c4dceb-8a19-4799-a39b-b7240755c672][【RFC7230】章节 3.2]]），它们一起标识了该用户代理软件以及它的重要的[[ruby:subproducts][子产品]]。按照惯例，这些产品标识符是按其标识用户代理软件的重要性的降序顺序排列的。每个产品标识符由一个名称和一个可选的版本组成。

#+BEGIN_SRC text
  product         = token ["/" product-version]
  product-version = token
#+END_SRC

#+BEGIN_QUOTE
A sender *SHOULD* limit generated product identifiers to what is necessary to identify the product; a sender *MUST NOT* generate advertising or other nonessential information within the product identifier. A sender *SHOULD NOT* generate information in =product-version= that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the =product-version= portion of the product identifier).
#+END_QUOTE

发送端 *应当* 将所生成的产品标识符限制为必要于标识该产品的那些标识符。发送端 *禁止* 将广告或其他非本质信息生成到产品标识符内部。发送端 *不应当* 将非版本标识符的信息生成到 =product-version= 内部（也就是说，同一个产品名称的连续版本之间区别应该仅在于产品标识符的 =product-version= 部分）。

#+BEGIN_QUOTE
Example:
#+END_QUOTE

例如：

#+BEGIN_EXAMPLE
  User-Agent: CERN-LineMode/2.15 libwww/2.17b3
#+END_EXAMPLE

#+BEGIN_QUOTE
A user agent *SHOULD NOT* generate a =User-Agent= field containing needlessly fine-grained detail and *SHOULD* limit the addition of subproducts by third parties. Overly long and detailed =User-Agent= field values increase request latency and the risk of a user being identified against their wishes ("fingerprinting").
#+END_QUOTE

用户代理 *不应当* 生成一个包含不必要的[[ruby:fine-grained%20detail][细粒度详尽信息]] 的 =User-Agent= 头字段，同时，*应当* 限制被第三方添加子产品到该字段中。太过长或详尽的 =User-Agent= 字段值会加大请求的延迟以及违背用户意愿而被识别出（“[[ruby:fingerprinting][指纹识别]]”）的风险。

#+BEGIN_QUOTE
Likewise, implementations are encouraged not to use the product tokens of other implementations in order to declare compatibility with them, as this circumvents the purpose of the field. If a user agent masquerades as a different user agent, recipients can assume that the user intentionally desires to see responses tailored for that identified user agent, even if they might not work as well for the actual user agent being used.
#+END_QUOTE

同样，不鼓励[[ruby:implementations][实现]]使用[[ruby:other%20implementations][其他实现]]的 =product= 标记来[[ruby:declare][断言]]（判断）与它们之间的[[ruby:compatibility][兼容性]]，因为这样[[ruby:circumvents][逃避]]了该字段的目的。如果一个用户代理伪装成另一个不同的用户代理，接收端可以假定这个用户代理故意想查看适用于被伪装的用户代理的响应，即使这些响应可能无法很好地适用于实际的用户代理。

* 6. 响应状态码 / Response Status Codes
:PROPERTIES:
:ID:       5a69d0cc-628c-4897-a089-45f906b94a92
:END:

#+BEGIN_QUOTE
The status-code element is a three-digit integer code giving the result of the attempt to understand and satisfy the request.
#+END_QUOTE

状态码是为试图理解和满足请求而给出结果的一个三位整数。

#+BEGIN_QUOTE
HTTP status codes are extensible. HTTP clients are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, a client *MUST* understand the class of any status code, as indicated by the first digit, and treat an unrecognized status code as being equivalent to the x00 status code of that class, with the exception that a recipient *MUST NOT* cache a response with an unrecognized status code.
#+END_QUOTE

HTTP 状态码是[[ruby:extensible][可扩展的]]。不要求 HTTP 客户端去理解所有已注册的状态码的意义，虽然这种理解明显是很值得的。但是，客户端 *必须* 理解所有状态码的种类，这些类型是由状态码的第一位数字来指明的。而且，客户端 *必须* 将它[[ruby:unrecoginized][无法识别的]]状态码当作等同于它的种类的 =x00= 状态码来对待，不过有一个区别是接收端 *禁止* 缓存带有它无法识别的状态码的响应。

#+BEGIN_QUOTE
For example, if an unrecognized status code of =471= is received by a client, the client can assume that there was something wrong with its request and treat the response as if it had received a =400 (Bad Request)= status code. The response message will usually contain a representation that explains the status.
#+END_QUOTE

例如，如果某个客户端接收到一个它无法识别的 =471= 状态码，那么，客户端可以假定为它所发送的请求出了问题，并将这个响应当作是一个 =400 (Bad Request)= 响应来对待。响应消息通常会包含有一种[[ruby:representation][表示形式]]来解释响应的状态。

#+BEGIN_QUOTE
The first digit of the status-code defines the class of response. The last two digits do not have any categorization role. There are five values for the first digit:

- [[id:2dd7a3d1-25c2-4192-9a19-6a3cf137036e][1xx (Informational)]]: The request was received, continuing process
- [[id:795b7295-fd61-4ded-8dff-da880548f665][2xx (Successful)]]: The request was successfully received, understood, and accepted
- [[id:455a69c1-4d80-440e-a98c-851a296d9ce2][3xx (Redirection)]]: Further action needs to be taken in order to complete the request
- [[id:d052de1c-5d88-41e3-baf6-c7a37a841de6][4xx (Client Error)]]: The request contains bad syntax or cannot be fulfilled
- [[id:6b95899d-bbec-474e-bcb0-3ca5dbbf0ba1][5xx (Server Error)]]: The server failed to fulfill an apparently valid request
#+END_QUOTE

状态码的第一位数字定义了响应的种类。后两位数字并没有任何分类的作用。第一位数字有五个值：

- [[id:2dd7a3d1-25c2-4192-9a19-6a3cf137036e][1xx (Informational)]]：请求已被接收，目前正在持续处理该请求
- [[id:795b7295-fd61-4ded-8dff-da880548f665][2xx (Successful)]]：请求已被成功接收、理解以及接受
- [[id:455a69c1-4d80-440e-a98c-851a296d9ce2][3xx (Redirection)]]：为完成请求，需要采取进一步的动作
- [[id:d052de1c-5d88-41e3-baf6-c7a37a841de6][4xx (Client Error)]]：请求包含有不良的语法，或者请求不能被[[ruby:fulfill][实现]]
- [[id:6b95899d-bbec-474e-bcb0-3ca5dbbf0ba1][5xx (Server Error)]]：服务器未能[[ruby:fulfill][实现]]一个显然有效的请求

** 6.1. 状态码概况 / Overview of Status Codes

#+BEGIN_QUOTE
The status codes listed below are defined in this specification, [[id:c983830d-bf6f-4e61-a905-285f070f9d20][Section 4]] of [RFC7232], [[id:028da72d-1e54-4bee-ac56-3d63169c6c3f][Section 4]] of [RFC7233], and [[id:3a079a03-d926-4f70-95da-d8fcedbdf3ac][Section 3]] of [RFC7235]. The reason phrases listed here are only recommendations — they can be replaced by local equivalents without affecting the protocol.
#+END_QUOTE

下列状态码定义在本规范、[[id:c983830d-bf6f-4e61-a905-285f070f9d20][【RFC7232】章节 4]]、[[id:028da72d-1e54-4bee-ac56-3d63169c6c3f][【RFC7233】章节 4]] 和[[id:3a079a03-d926-4f70-95da-d8fcedbdf3ac][【RFC7235】章节 3]] 里。下列[[ruby:reason%20phrases][原因短语]]仅为建议，也就是说，在没有影响到协议的情况下，本地可以将它们替换为等效的其他短语。

#+BEGIN_QUOTE
Responses with status codes that are defined as cacheable by default (e.g., =200=, =203=, =204=, =206=, =300=, =301=, =404=, =405=, =410=, =414=, and =501= in this specification) can be reused by a cache with heuristic expiration unless otherwise indicated by the method definition or explicit cache controls [[[file:RFC7234.org][RFC7234]]]; all other status codes are not cacheable by default.
#+END_QUOTE

响应如果带有被定义为默认是[[ruby:cacheable][可缓存的]]状态码（比如，本规范里的 =200=、=203=、=204=、=206=、=300=、=301=、=404=、=405=、=410=、=414= 和 =501=），那么，该响应能够被一个使用[[ruby:heuristic%20expiration][试探性过期]]的缓存所复用，除非在请求方法的定义或者[[ruby:explicit%20cache%20controls][显式缓存控制]]【[[file:RFC7234.org][RFC7234]]】里另有指定；其他所有状态码默认是[[ruby:not%20cacheable][不可缓存的]]。


| Code | Reason-Phrase                 | Defined in...            |
|------+-------------------------------+--------------------------|
| 100  | Continue                      | [[id:91fffa22-c6f0-476c-b69f-f76828e861f3][Section 6.2.1]]            |
| 101  | Switching Protocols           | [[id:c8200a68-3b0f-4f12-bf1f-ac895c5dcf9f][Section 6.2.2]]            |
| 200  | OK                            | [[id:8b00dffb-977c-496a-be64-60d2f5f46e36][Section 6.3.1]]            |
| 201  | Created                       | [[id:0f0de6df-c767-45b5-a6a9-1f45f20bba38][Section 6.3.2]]            |
| 202  | Accepted                      | [[id:f333c72d-3351-4339-b41a-0832ed8884ac][Section 6.3.3]]            |
| 203  | Non-Authoritative Information | [[id:5a18bb35-2626-4fe4-a36c-cae3a7655a60][Section 6.3.4]]            |
| 204  | No Content                    | [[id:3a5fcefb-f004-4981-a616-0feba4c9e9e4][Section 6.3.5]]            |
| 205  | Reset Content                 | [[id:545a7a5c-0589-40d5-bae4-726b8e71dd10][Section 6.3.6]]            |
| 206  | Partial Content               | [[id:32182a4e-00f6-44d9-82e2-f08d98b59324][Section 4.1]] of [RFC7233] |
| 300  | Multiple Choices              | [[id:bb139936-2671-4ffc-9dd0-75af2bab7d9b][Section 6.4.1]]            |
| 301  | Moved Permanently             | [[id:e883e3aa-aac3-46ca-83cc-2a085889f9d2][Section 6.4.2]]            |
| 302  | Found                         | [[id:89acc9d5-366e-4a7c-820e-891fe25738be][Section 6.4.3]]            |
| 303  | See Other                     | [[id:12c7ea0c-85ac-401f-8132-293e6ebcf52f][Section 6.4.4]]            |
| 304  | Not Modified                  | [[id:6033b2bf-1408-4756-9929-15dd6510c7e3][Section 4.1]] of [RFC7232] |
| 305  | Use Proxy                     | [[id:e69019b2-b071-4380-bcd7-d2fd80261d81][Section 6.4.5]]            |
| 307  | Temporary Redirect            | [[id:549c5916-48a9-4e75-8c68-538635c00a2c][Section 6.4.7]]            |
| 400  | Bad Request                   | [[id:323c581a-d558-421f-a0f1-8c28fe904264][Section 6.5.1]]            |
| 401  | Unauthorized                  | [[id:50ef5918-69e6-4826-9f20-db56fdd02974][Section 3.1]] of [RFC7235] |
| 402  | Payment Required              | [[id:d4484e6e-b1a9-4ae9-b8cd-5da28a80fce7][Section 6.5.2]]            |
| 403  | Forbidden                     | [[id:addb601c-6b2f-45a7-97f7-9d24bdb8b585][Section 6.5.3]]            |
| 404  | Not Found                     | [[id:aff1f620-f950-48fe-a479-0276d2aeac0e][Section 6.5.4]]            |
| 405  | Method Not Allowed            | [[id:6c2a3e21-55e6-465c-b8dc-7d773d341e8f][Section 6.5.5]]            |
| 406  | Not Acceptable                | [[id:c600bda4-d399-4870-894f-ea4293fc173f][Section 6.5.6]]            |
| 407  | Proxy Authentication Required | [[id:1029b0aa-9c78-463a-b3f4-a4acbfbac26f][Section 3.2]] of [RFC7235] |
| 408  | Request Timeout               | [[id:8523542a-3e33-4261-92b7-0bf706f14a57][Section 6.5.7]]            |
| 409  | Conflict                      | [[id:63517bec-7c89-4655-a6df-e5e2c8de4a17][Section 6.5.8]]            |
| 410  | Gone                          | [[id:9b6a1a09-f457-45b9-9b66-b05916f8d1a0][Section 6.5.9]]            |
| 411  | Length Required               | [[id:57b9a13c-fa90-4ad0-a898-dbb7a80b007c][Section 6.5.10]]           |
| 412  | Precondition Failed           | [[id:02e5a084-aac8-4f06-840f-507ef2489bb1][Section 4.2]] of [RFC7232] |
| 413  | Payload Too Large             | [[id:620869b7-1f42-4bb9-a3ba-664e80d5161d][Section 6.5.11]]           |
| 414  | URI Too Long                  | [[id:77d1edbb-ceeb-450d-9b85-5f8c89db2f97][Section 6.5.12]]           |
| 415  | Unsupported Media Type        | [[id:7c879fad-0a52-4f22-8447-38b860f3e71d][Section 6.5.13]]           |
| 416  | Range Not Satisfiable         | [[id:a2f29dcf-8c15-4b15-ab66-742f476d27f3][Section 4.4]] of [RFC7233] |
| 417  | Expectation Failed            | [[id:a4b990e6-b91e-422d-ad8e-cb77866ed170][Section 6.5.14]]           |
| 426  | Upgrade Required              | [[id:5d028105-552c-4079-bcfe-30809395f6c9][Section 6.5.15]]           |
| 500  | Internal Server Error         | [[id:4a288d4c-063f-4589-9ec6-3c4f246e2d8a][Section 6.6.1]]            |
| 501  | Not Implemented               | [[id:776a0530-a654-43bc-879b-186e39dbff63][Section 6.6.2]]            |
| 502  | Bad Gateway                   | [[id:dd36be96-0bfa-4dbc-8656-132fe9509b14][Section 6.6.3]]            |
| 503  | Service Unavailable           | [[id:4e09afe4-30a3-4bbb-aa7e-23f621d42801][Section 6.6.4]]            |
| 504  | Gateway Timeout               | [[id:4502f86d-74d1-4890-b235-3155ba125cb6][Section 6.6.5]]            |
| 505  | HTTP Version Not Supported    | [[id:00dabed7-f9a1-471e-a9f6-77220446dbfa][Section 6.6.6]]            |

#+BEGIN_QUOTE
Note that this list is not exhaustive — it does not include extension status codes defined in other specifications. The complete list of status codes is maintained by IANA. See Section 8.2 for details.
#+END_QUOTE

需要注意的是上述列表并不完整的，它并没有包含定义在其他规范里的扩展状态码。完整的状态码列表由 IANA 所维护。详情见[[id:c0f1fbbc-3471-430e-90be-1b120d9b449f][章节 8.2]]。

** 6.2. 信息性 1xx / Informational 1xx
:PROPERTIES:
:ID:       2dd7a3d1-25c2-4192-9a19-6a3cf137036e
:END:

#+BEGIN_QUOTE
The =1xx (Informational)= class of status code indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response. =1xx= responses are terminated by the first empty line after the status-line (the empty line signaling the end of the header section). Since HTTP/1.0 did not define any =1xx= status codes, a server *MUST NOT* send a =1xx= response to an HTTP/1.0 client.
#+END_QUOTE

=1xx (Informational)= 状态码种类表明：这是一个[[ruby:interim%20response][过渡响应]]，用于在完成所请求的动作以及发送一个[[ruby:final%20response][最终响应]]之前传递[[ruby:connection%20status][连接状态]]或[[ruby:request%20progress][请求进展]]。=1xx= 响应终止于[[ruby:status-line][状态行]]之后的第一个[[ruby:empty%20line][空行]]（空行标志着[[ruby:header%20section][消息头部]]的结束）。由于 HTTP/1.0 并没有定义任何 =1xx= 状态码，因此，服务器 *禁止* 将 =1xx= 的响应发送到一个 HTTP/1.0 客户端上。

#+BEGIN_QUOTE
A client *MUST* be able to parse one or more =1xx= responses received prior to a final response, even if the client does not expect one. A user agent *MAY* ignore unexpected =1xx= responses.
#+END_QUOTE

客户端 *必须* 能够[[ruby:parse][解析]]在接收到一个最终响应之前所接收到的一个或多个 =1xx= 响应，即使这个客户端并不[[ruby:expect][期待]]接收。用户代理 *可以* 忽略[[ruby:unexpected][意料之外的]] =1xx= 响应。

#+BEGIN_QUOTE
A proxy *MUST* forward =1xx= responses unless the proxy itself requested the generation of the =1xx= response. For example, if a proxy adds an "Expect: 100-continue" field when it forwards a request, then it need not forward the corresponding =100 (Continue)= response(s).
#+END_QUOTE

代理 *必须* 转发 =1xx= 响应，除非这个 =1xx= 响应是代理自身要求对方发送的。例如，如果某个代理在转发一个请求的时候添加了一个头字段 "Expect: 100-continue"，那么，它并不需要转发对应的那个（或多个） =100 (Continue)= 响应。

*** 6.2.1. 100 继续 / 100 Continue
:PROPERTIES:
:ID:       91fffa22-c6f0-476c-b69f-f76828e861f3
:END:

#+BEGIN_QUOTE
The =100 (Continue)= status code indicates that the initial part of a request has been received and has not yet been rejected by the server. The server intends to send a final response after the request has been fully received and acted upon.
#+END_QUOTE

=100 (Continue)= 状态码表明：一个请求的[[ruby:initial%20part][初始部分]]已经被服务器接收，并且它还没有被服务器[[ruby:rejected][拒绝]]。服务器打算在请求完全接收完毕并处理好之后再发送一个[[ruby:final%20response][最终响应]]。

#+BEGIN_QUOTE
When the request contains an =Expect= header field that includes a =100-continue= expectation, the =100= response indicates that the server wishes to receive the request payload body, as described in Section 5.1.1. The client ought to continue sending the request and discard the =100= response.
#+END_QUOTE

当请求带有一个 =Expect= 头字段，而这个头字段含有一个 =100-continue= [[ruby:expectation][期望]]的时候，=100= 响应表明：服务器希望去接收[[ruby:request%20payload%20body][请求的有效载荷]]，正如[[id:0b0cea12-0af7-47f1-8908-2afc48ce3fb2][章节 5.1.1]] 讲述的那样。客户端应该继续发送请求的剩余部分并[[ruby:discard][丢弃]]这个 =100= 响应。

#+BEGIN_QUOTE
If the request did not contain an =Expect= header field containing the =100-continue= expectation, the client can simply discard this interim response.
#+END_QUOTE

如果请求并未带有一个含有 =100-continue= [[ruby:expectation][期望]]的 =Expect= 头字段，那么，客户端能够简单地丢弃这个[[ruby:interm%20response][过渡响应]]。

*** 6.2.2. 101 切换协议 / 101 Switching Protocols
:PROPERTIES:
:ID:       c8200a68-3b0f-4f12-bf1f-ac895c5dcf9f
:END:

#+BEGIN_QUOTE
The =101 (Switching Protocols)= status code indicates that the server understands and is willing to comply with the client's request, via the =Upgrade= header field (Section 6.7 of [RFC7230]), for a change in the application protocol being used on this connection. The server *MUST* generate an =Upgrade= header field in the response that indicates which protocol(s) will be switched to immediately after the empty line that terminates the =101= response.
#+END_QUOTE

=101 (Switching Protocols)= 状态码表明：服务器理解并愿意按照客户端的[[ruby:request][请求]]（该请求经由 =Upgrade= 头字段来表达，见[[id:62632d23-475d-4daa-8efb-3206d370573a][【RFC7230】章节 6.7]]）来改变本次连接正在使用的[[ruby:application%20protocol][应用协议]]。服务器 *必须* 在响应里生成一个 =Upgrade= 头字段，来表明：从结束该 =101= 响应的空行之后开始，将会马上切换到哪一种（或多种）协议。

#+BEGIN_QUOTE
It is assumed that the server will only agree to switch protocols when it is advantageous to do so. For example, switching to a newer version of HTTP might be advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features.
#+END_QUOTE

假定服务器将仅当对其有利的情况下才会同意切换协议。例如，切换到一个新版本的 HTTP 的好处可能会大于旧版本，或者在交付资源的时候切换到一种[[ruby:real-time,%20synchronous%20protocol][实时同步的协议]]可能会更有优势。

** 6.3. 成功 2xx / Successful 2xx
:PROPERTIES:
:ID:       795b7295-fd61-4ded-8dff-da880548f665
:END:

#+BEGIN_QUOTE
The =2xx (Successful)= class of status code indicates that the client's request was successfully received, understood, and accepted.
#+END_QUOTE

=2xx (Successful)= 状态码种类表明：客户端的请求已经被成功[[ruby:received][接收]]、[[ruby:understood][理解]]和[[ruby:accepted][接受]]。

*** 6.3.1. 200 OK
:PROPERTIES:
:ID:       8b00dffb-977c-496a-be64-60d2f5f46e36
:END:

#+BEGIN_QUOTE
The =200 (OK)= status code indicates that the request has succeeded. The payload sent in a =200= response depends on the request method. For the methods defined by this specification, the intended meaning of the payload can be summarized as:

- GET :: a representation of the target resource;
- HEAD :: the same representation as GET, but without the representation data;
- POST :: a representation of the status of, or results obtained from, the action;
- PUT, DELETE :: a representation of the status of the action;
- OPTIONS :: a representation of the communications options;
- TRACE :: a representation of the request message as received by the end server.
#+END_QUOTE

=200 (OK)= 状态码表明：请求已经成功。=200= 响应里的[[ruby:payload][有效载荷]]的含义取决于对应的[[ruby:request%20method][请求方法]]。对于由本规范所定义的方法来说，有效载荷想要表达的含义可以总结为：

- GET :: 目标资源的一种[[ruby:representation][表示形式]]；
- HEAD :: 与 GET 一样的表示形式，但没有[[ruby:representation%20data][表示形式数据]]；
- POST :: 动作的状态（或者从动作获得的结果）的一种表示形式；
- PUT, DELETE :: 动作的状态的一种表示形式；
- OPTIONS :: [[ruby:communication%20options][通信选项]]的一种表示形式；
- TRACE :: 如同接收自[[ruby:end%20server][终端服务器]]一样的请求消息的一种表现形式。

#+BEGIN_QUOTE
Aside from responses to CONNECT, a =200= response always has a payload, though an origin server *MAY* generate a payload body of zero length. If no payload is desired, an origin server ought to send =204 (No Content)= instead. For CONNECT, no payload is allowed because the successful result is a tunnel, which begins immediately after the =200= response header section.
#+END_QUOTE

除了回应给 CONNECT 的响应以外，=200= 响应总是带有一个有效载荷的，尽管源服务器 *可以* 生成一个长度为零的有效载荷。如果不想带有有效载荷，源服务器应该改为发送 =204 (No Content)= 响应。对于 CONNECT，不允许带有有效载荷是因为它的成功结果是一个[[ruby:tunnel][隧道]]，而该隧道会在 =200= 响应头部以后马上开始建立。

#+BEGIN_QUOTE
A =200= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=200= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.3.2. 201 已创建 / 201 Created
:PROPERTIES:
:ID:       0f0de6df-c767-45b5-a6a9-1f45f20bba38
:END:

#+BEGIN_QUOTE
The =201 (Created)= status code indicates that the request has been fulfilled and has resulted in one or more new resources being created. The primary resource created by the request is identified by either a =Location= header field in the response or, if no =Location= field is received, by the effective request URI.
#+END_QUOTE

=201 (Created)= 状态码表明：请求已被[[ruby:fulfilled][实现]]并且引起了一个或多个[[ruby:new%20resources][新资源]]被创建。上述因请求而创建的[[ruby:primary%20resource][主要资源]]会被一个在响应里的 =Location= 头字段所标识，或者，如果没有接收到 =Location= 头字段的话，则通过[[ruby:effective%20request%20URI][有效请求 URI]] 来识别。

#+BEGIN_QUOTE
The =201= response payload typically describes and links to the resource(s) created. See [[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][Section 7.2]] for a discussion of the meaning and purpose of validator header fields, such as =ETag= and =Last-Modified=, in a =201= response.
#+END_QUOTE

=201= 响应的有效载荷通常描述并链接到新创建的资源上。对于在 =201= 响应里的[[ruby:validator%20header%20fields][验证器头字段]]（比如 =ETag= 和 =Last-Modified=）的意义和目的的讨论，见[[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][章节 7.2]]。

*** 6.3.3. 202 已接受 / 202 Accepted
:PROPERTIES:
:ID:       f333c72d-3351-4339-b41a-0832ed8884ac
:END:

#+BEGIN_QUOTE
The =202 (Accepted)= status code indicates that the request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There is no facility in HTTP for re-sending a status code from an asynchronous operation.
#+END_QUOTE

=202 (Accepted)= 状态码表明：请求已被接受处理，但处理尚未[[ruby:completed][完成]]。最终可能也可能不会按照请求来行事，因为当实际进行处理的时候该请求可能被拒绝。HTTP 里没有任何的[[ruby:facility][技巧]]可以从一个[[ruby:asynchronous%20operation][异步操作]]中重发一个状态码。

#+BEGIN_QUOTE
The =202= response is intentionally noncommittal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed. The representation sent with this response ought to describe the request's current status and point to (or embed) a status monitor that can provide the user with an estimate of when the request will be fulfilled.
#+END_QUOTE

=202= 响应有意含糊的。它的目的是为了让服务器可以接受一个请求来进行其他的处理（也许是一个每天仅运行一次的面向批量的处理）而不要求用户代理[[ruby:persist][保持]]对服务器的连接直到完成该处理。随响应一起发送的[[ruby:representation][表示形式]]应该描述该请求的当前状态并且指向（或者[[ruby:embed][内嵌]]）一个[[ruby:status%20monitor][状态监听器]]来向用户提供“请求将会在什么时候被实现”的评估。

*** 6.3.4. 203 非权威信息 / 203 Non-Authoritative Information
:PROPERTIES:
:ID:       5a18bb35-2626-4fe4-a36c-cae3a7655a60
:END:

#+BEGIN_QUOTE
The =203 (Non-Authoritative Information)= status code indicates that the request was successful but the enclosed payload has been modified from that of the origin server's =200 (OK)= response by a transforming proxy ([[id:b6641b58-3ac6-4fce-9c44-a3715ffdc8a0][Section 5.7.2]] of [RFC7230]). This status code allows the proxy to notify recipients when a transformation has been applied, since that knowledge might impact later decisions regarding the content. For example, future cache validation requests for the content might only be applicable along the same request path (through the same proxies).
#+END_QUOTE

=203 (Non-Authoritative Information)= 状态码表明：请求已成功，但是，由源服务器所生成的 =200 (OK)= 响应内的有效载荷已经被链路中的某个[[ruby:transforming%20proxy][转换代理]]（[[id:b6641b58-3ac6-4fce-9c44-a3715ffdc8a0][【RFC7230】章节 5.7.2]]）修改过了。这个状态码让代理在对响应的有效载荷执行过转换时可以通知接收端，因为这种信息可能会影响到接收端以后对内容的相关决定。例如，今后对于该内容的[[ruby:cache%20validation%20requests][缓存有效期验证请求]]可能只适用于沿着相同的请求路径（途经相同的代理）。

#+BEGIN_QUOTE
The =203= response is similar to the =Warning= code of =214 Transformation Applied= ([[id:84f5867e-4a3e-45fa-b085-dd23e8598a6b][Section 5.5]] of [RFC7234]), which has the advantage of being applicable to responses with any status code.
#+END_QUOTE

=203= 响应类似于 =214 Transformation Applied= 这个 =Warning= 码（[[id:84f5867e-4a3e-45fa-b085-dd23e8598a6b][【RFC7234】章节 5.5]]），后者的好处是适用于带有任何状态码的响应。

#+BEGIN_QUOTE
A =203= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=203= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.3.5. 204 无内容 / 204 No Content
:PROPERTIES:
:ID:       3a5fcefb-f004-4981-a616-0feba4c9e9e4
:END:

#+BEGIN_QUOTE
The =204 (No Content)= status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body. Metadata in the response header fields refer to the target resource and its selected representation after the requested action was applied.
#+END_QUOTE

=204 (No Content)= 状态码表明：服务器已经[[ruby:fulfilled][实现]]了这个请求，并且没有额外的内容需要发送到响应的有效载荷里。在[[ruby:apply][执行]]完所请求的动作以后，响应头字段里的[[ruby:metadata][元数据]]会引用目标资源及其[[ruby:selected%20representation][选定的表示形式]]。

#+BEGIN_QUOTE
For example, if a =204= status code is received in response to a PUT request and the response contains an =ETag= header field, then the PUT was successful and the =ETag= field-value contains the =entity-tag= for the new representation of that target resource.
#+END_QUOTE

例如，在回应给某个 PUT 请求的响应里，如果该响应带一个 =204= 状态码，并且包含有一个 =ETag= 头字段，说明这个 PUT 请求已被成功执行并且 =ETag= 的字段值所包含的 =entity-tag= 是那个目标资源的[[ruby:new%20representation][新的表示形式]]。

#+BEGIN_QUOTE
The =204= response allows a server to indicate that the action has been successfully applied to the target resource, while implying that the user agent does not need to traverse away from its current "document view" (if any). The server assumes that the user agent will provide some indication of the success to its user, in accord with its own interface, and apply any new or updated metadata in the response to its active representation.
#+END_QUOTE

=204= 响应让服务器可以去指出动作已被成功对目标资源[[ruby:apply][应用（执行）]]，而这意味着用户代理并不需要切换它当前的“文档视图”（如果有的话）。服务器假定用户代理会向它的用户提供与它自身接口相符的某些成功指示，并且会将响应里的所有新的或更新过的元数据[[ruby:apply][应用]]到用户代理的[[ruby:active%20representation][活动表示形式]]上。

#+BEGIN_QUOTE
For example, a =204= status code is commonly used with document editing interfaces corresponding to a "save" action, such that the document being saved remains available to the user for editing. It is also frequently used with interfaces that expect automated data transfers to be prevalent, such as within distributed version control systems.
#+END_QUOTE

例如，=204= 状态码通常使用在一个执行“保存”动作的文档编辑接口中，这样，文档在保存过程中仍然可以给用户继续编辑。它也经常用在期待流行自动化数据传输的接口中，比如在分布式版本控制系统当中。

#+BEGIN_QUOTE
A =204= response is terminated by the first empty line after the header fields because it cannot contain a message body.
#+END_QUOTE

=204= 响应结束于头字段之后的第一个空行，因为它并不能带有一个[[ruby:message%20body][消息体]]。

#+BEGIN_QUOTE
A =204= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=204= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.3.6. 205 重置内容 / 205 Reset Content
:PROPERTIES:
:ID:       545a7a5c-0589-40d5-bae4-726b8e71dd10
:END:

#+BEGIN_QUOTE
The =205 (Reset Content)= status code indicates that the server has fulfilled the request and desires that the user agent reset the "document view", which caused the request to be sent, to its original state as received from the origin server.
#+END_QUOTE

=205 (Reset Content)= 状态码表明：服务器已经[[ruby:fulfilled][实现]]了这个请求，并且很希望用户代理将“文档视图”重置为原始状态——这将导致发起请求——以源服务器的响应作为重置后的结果。

#+BEGIN_QUOTE
This response is intended to support a common data entry use case where the user receives content that supports data entry (a form, notepad, canvas, etc.), enters or manipulates data in that space, causes the entered data to be submitted in a request, and then the data entry mechanism is reset for the next entry so that the user can easily initiate another input action.
#+END_QUOTE

这种响应意图去支持一种通用的数据录入用例，用户接收到支持数据录入的内容（一个表单、笔记本、画布等），在那个位置上输入或操作数据，引起已输入的数据被一个请求所提交，然后数据录入机制会被重置来为下一次录入做准备，以便于用户可以轻松地初始化其他输入动作。

#+BEGIN_QUOTE
Since the =205= status code implies that no additional content will be provided, a server *MUST NOT* generate a payload in a =205= response. In other words, a server *MUST* do one of the following for a =205= response: a) indicate a zero-length body for the response by including a =Content-Length= header field with a value of 0; b) indicate a zero-length payload for the response by including a =Transfer-Encoding= header field with a value of =chunked= and a message body consisting of a single chunk of zero-length; or, c) close the connection immediately after sending the blank line terminating the header section.
#+END_QUOTE

因为 =205= 状态码意味着不会提供额外的内容，服务器 *禁止* 在 =205= 响应里生成有效载荷。换句话说，服务器 *必须* 对 205 响应做以下其中之一的处理：

- 通过包含一个值为 0 的 =Content-Length= 头字段来表明：响应有一个长度为零的消息体；
- 通过包含一个值为 =chunked= 的 =Transfer-Encoding=，并且消息体由单独一个长度为零的[[ruby:chunk][分块]]组成，来表明：响应有一个长度为零的有效载荷；
- 在发送空行来结束消息头部以后，马上关闭连接。

** 6.4. 重定向 3xx / Redirection 3xx
:PROPERTIES:
:ID:       455a69c1-4d80-440e-a98c-851a296d9ce2
:END:

#+BEGIN_QUOTE
The =3xx (Redirection)= class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request. If a =Location= header field ([[id:bc2baf29-0bf6-4816-865c-3d33f5fe38e3][Section 7.1.2]]) is provided, the user agent *MAY* automatically redirect its request to the URI referenced by the =Location= field value, even if the specific status code is not understood. Automatic redirection needs to done with care for methods not known to be safe, as defined in [[id:2f967e3d-8694-430b-ad06-e748fd39b281][Section 4.2.1]], since the user might not wish to redirect an unsafe request.
#+END_QUOTE

=3xx (Redirection)= 状态码种类表明：需要用户代理采取进一步的动作才能[[ruby:fulfill][实现]]这个请求。如果提供了一个 =Location= 头字段（[[id:bc2baf29-0bf6-4816-865c-3d33f5fe38e3][章节 7.1.2]]），用户代理 *可以* 自动[[ruby:redirect][重定向]]它的请求到 =Location= 的字段值所指定的 URI 引用，即使它不理解具体的状态码。自动重定向需要小心处理那些不知道是否安全的方法，见[[id:2f967e3d-8694-430b-ad06-e748fd39b281][章节 4.2.1]]，因为用户可能并不希望重定向一个不安全的请求。

#+BEGIN_QUOTE
There are several types of redirects:

1. Redirects that indicate the resource might be available at a different URI, as provided by the =Location= field, as in the status codes =301 (Moved Permanently)=, =302 (Found)=, and =307 (Temporary Redirect)=.

2. Redirection that offers a choice of matching resources, each capable of representing the original request target, as in the =300 (Multiple Choices)= status code.

3. Redirection to a different resource, identified by the =Location= field, that can represent an indirect response to the request, as in the =303 (See Other)= status code.

4. Redirection to a previously cached result, as in the =304 (Not Modified)= status code.
#+END_QUOTE

重定向有若干类型：

1. 状态码为 =301 (Moved Permanently)=、=302 (Found)=、=307 (Temporary Redirect)= 的重定向表明：资源可能在 =Location= 头字段所提供的另一个不同 URI 上可用。
2. 状态码为 =300 (Multiple Choices)= 的重定向提供了对于匹配到的资源的一种选择，每种都能够表示原始的请求目标。
3. 状态码 =303 (See Other)=，重定向到由 =Location= 字段所标识的另一个不同资源上，能够表示回应给请求的一种[[ruby:indirect%20response][间接响应]]。
4. 状态码 =304 (Not Modified)=，重定向到上一个缓存结果。 

#+BEGIN_QUOTE
*Note:* In HTTP/1.0, the status codes =301 (Moved Permanently)= and =302 (Found)= were defined for the first type of redirect ([RFC1945], [[https://tools.ietf.org/html/rfc1945#section-9.3][Section 9.3]]). Early user agents split on whether the method applied to the redirect target would be the same as the original request or would be rewritten as GET. Although HTTP originally defined the former semantics for =301= and =302= (to match its original implementation at CERN), and defined =303 (See Other)= to match the latter semantics, prevailing practice gradually converged on the latter semantics for =301= and =302= as well. The first revision of HTTP/1.1 added =307 (Temporary Redirect)= to indicate the former semantics without being impacted by divergent practice. Over 10 years later, most user agents still do method rewriting for =301= and =302=; therefore, this specification makes that behavior conformant when the original request is POST.
#+END_QUOTE

*注意：* 在 HTTP/1.0 中，=301 (Moved Permanently)= 和 =302 (Found)= 状态码是定义为上述第一种重定向类型的（[[https://tools.ietf.org/html/rfc1945#section-9.3][【RFC1945】章节 9.3]]）。早期的用户代理有一个分歧——应用到重定向目标的请求方法是使用与原来请求的方法一样呢，还是[[ruby:rewrite][改写]]为 GET 方法呢？虽然 HTTP 最初将 =301= 和 =302= 定义为前者语义（来匹配它在 CERN 的最初实现），将 =303 (See Other)= 定义为后者语义，但是主流实现通常将 =301= 和 =302= 也转化为后者语义。HTTP/1.1 第一个修订版新增了 =307 (Temporary Redirect)= 来表明前者语言，以免受到实现上分歧的影响。其后十多年以来，大多数用户代理仍然对 =301= 和 =302= 的重定向使用方法重写的方式（即后者语义），所以，当原始请求是 POST 的时候，本规范顺应了这种行为。

#+BEGIN_QUOTE
A client *SHOULD* detect and intervene in cyclical redirections (i.e., "infinite" redirection loops).
#+END_QUOTE

客户端 *应当* 检测并调停[[ruby:cyclical redirections][循环重定向]]（也就是说，无限重定向循环）。

#+BEGIN_QUOTE
*Note:* An earlier version of this specification recommended a maximum of five redirections ([RFC2068], Section 10.3). Content developers need to be aware that some clients might implement such a fixed limitation.
#+END_QUOTE

*注意：* 本规范早期的版本推荐最多 5 次重定向（【RFC2068】章节 10.3）。[[ruby:content developers][内容开发者]]需要意识到某些客户端可能实现了这种固定次数的限制。

*** 6.4.1. 300 多重选择 / 300 Multiple Choices
:PROPERTIES:
:ID:       bb139936-2671-4ffc-9dd0-75af2bab7d9b
:END:

#+BEGIN_QUOTE
The =300 (Multiple Choices)= status code indicates that the target resource has more than one representation, each with its own more specific identifier, and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers. In other words, the server desires that the user agent engage in reactive negotiation to select the most appropriate representation(s) for its needs ([[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][Section 3.4]]).
#+END_QUOTE

=300 (Multiple Choices)= 表明：目标资源有一个以上的表示形式，每种都具有更加明确的标识符，并提供了备选表示形式相关的信息以便用户（或者用户代理）能够通过重定向它的请求到一个或多个那些标识符来选择[[ruby:preferred%20representation][最优的表示形式]]。换句话说，服务器希望用户代理参与[[ruby:reactive negotiation][进响应式协商]]来选择它需要的最合适的表现形式（[[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][章节 3.4]]）。

#+BEGIN_QUOTE
If the server has a preferred choice, the server *SHOULD* generate a =Location= header field containing a preferred choice's URI reference. The user agent *MAY* use the =Location= field value for automatic redirection.
#+END_QUOTE

如果服务器有一个[[ruby:preferred choice][最优选择]]，那么它 *应当* 生成一个 =Location= 头字段来包含最优选择的 URI 引用。用户代理 *可以* 使用 =Location= 字段的值自动重定向。

#+BEGIN_QUOTE
For request methods other than HEAD, the server *SHOULD* generate a payload in the =300= response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred. The user agent *MAY* make a selection from that list automatically if it understands the provided media type. A specific format for automatic selection is not defined by this specification because HTTP tries to remain orthogonal to the definition of its payloads. In practice, the representation is provided in some easily parsed format believed to be acceptable to the user agent, as determined by shared design or content negotiation, or in some commonly accepted hypertext format.
#+END_QUOTE

对于除 HEAD 以外的请求方法，服务器 *应当* 在 =300= 响应里生成一个有效载荷来包含一个列表，列表中有各种[[ruby:representation%20metadata][表示形式元数据]]以及 URI 引用，让用户或者用户代理可以从中选出一个最优表示形式。如果用户代理了解所提供的媒体类型的话，它 *可以* 自动从中选择一个。本规范并没有定义自动选择的具体格式，那是因为 HTTP 试图与它的有效载荷的定义保持[[ruby:orthogonal][正交]]。在实践过程中，表示形式会以某种被认为是便于用户代理去解析的格式来提供——这取决于共享设计或[[ruby:content%20negotiation][内容协商]]；又或者以某些普遍被接受的超文本格式来提供。

#+BEGIN_QUOTE
A =300= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=300= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。


#+BEGIN_QUOTE
Note: The original proposal for the =300= status code defined the =URI= header field as providing a list of alternative representations, such that it would be usable for =200=, =300=, and =406= responses and be transferred in responses to the HEAD method. However, lack of deployment and disagreement over syntax led to both =URI= and =Alternates= (a subsequent proposal) being dropped from this specification. It is possible to communicate the list using a set of =Link= header fields [[[https://tools.ietf.org/html/rfc5988][RFC5988]]], each with a relationship of "alternate", though deployment is a chicken-and-egg problem.
#+END_QUOTE

*注意：* =300= 状态码最初的提案定义了名叫 =URI= 的头字段来提供一个备选表示形式的列表，以便它能用在 =200=、=300=、=406= 响应里并且能在回应给 HEAD 方法的响应回进行传输。尽管如此，缺乏部署并且句法上的争议导致本规范放弃了 =URI= 和 =Alternates= （随后的一个提案）两者。有可能使用一系列的 =Link= 头字段【[[https://tools.ietf.org/html/rfc5988][RFC5988]]】来表达上述列表，每个 =Link= 值都与备选有关，虽然其部署还是一个“鸡和蛋”的问题。

*** 6.4.2. 301 永久移动 / 301 Moved Permanently
:PROPERTIES:
:ID:       e883e3aa-aac3-46ca-83cc-2a085889f9d2
:END:

#+BEGIN_QUOTE
The =301 (Moved Permanently)= status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs. Clients with link-editing capabilities ought to automatically re-link references to the effective request URI to one or more of the new references sent by the server, where possible.
#+END_QUOTE

=301 (Move Permanently)= 状态码表明：目标资源已被[[ruby:assign][分配]]到一个新的永久 URI 上，将来对本资源的任何引用都应该使用本次响应所提供的新 URIs 之一。对于具有[[ruby:link-editing][链接编辑]]能力的客户端应该自动将链接到有效请求 URI 的引用重新链接到由服务器传过来的新的引用上。

#+BEGIN_QUOTE
The server *SHOULD* generate a =Location= header field in the response containing a preferred URI reference for the new permanent URI. The user agent *MAY* use the =Location= field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the new URI(s).
#+END_QUOTE

服务器 *应当* 在响应里生成一个 =Location= 头字段来包含新的永久 URI 引用中最优的那一个。用户代e在皮耶entation
 *可以* 使用 =Location= 的字段值来[[ruby:automatic%20redirection][自动重定向]]。服务器的响应有效载荷通常会包含一个简短的超文本[[ruby:note][注释]]，其内有一个指向这个（或多个）新 URI 的超链接。

#+BEGIN_QUOTE
*Note:* For historical reasons, a user agent *MAY* change the request method from POST to GET for the subsequent request. If this behavior is undesired, the =307 (Temporary Redirect)= status code can be used instead.
#+END_QUOTE

由于历史的原因，用户代理 *可以* 在接下来的请求里将 POST 方法改变为 GET 方法。如果不希望这种行为，可以使用 =307 (Temporary Redirect)= 状态码来代替。

#+BEGIN_QUOTE
A =301= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=301= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.4.3. 302 发现 / 302 Found
:PROPERTIES:
:ID:       89acc9d5-366e-4a7c-820e-891fe25738be
:END:

#+BEGIN_QUOTE
The =302 (Found)= status code indicates that the target resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client ought to continue to use the effective request URI for future requests.
#+END_QUOTE

=302 (Found)= 状态码表明：目标资源临时处在一个不同的 URI 之下。因为重定向可以会再次改变，客户端应该在将来的请求中继续使用原来的[[ruby:effective%20request%20URI][有效请求 URI]]（而不是使用本次响应中 =Location= 字段所指的那个 URI）。

#+BEGIN_QUOTE
The server *SHOULD* generate a =Location= header field in the response containing a URI reference for the different URI. The user agent *MAY* use the =Location= field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s).
#+END_QUOTE

服务器 *应当* 在响应里生成一个 =Location= 头字段来包含这个不同的 URI 引用。用户代理 *可以* 使用 =Location= 的字段值来自动重定向。服务器的响应有效载荷通常会包含一个简短的超文本[[ruby:note][注释]]，其内有一个指向这个（或多个）新 URI 的超链接。

#+BEGIN_QUOTE
*Note:* For historical reasons, a user agent *MAY* change the request method from POST to GET for the subsequent request. If this behavior is undesired, the =307 (Temporary Redirect)= status code can be used instead.
#+END_QUOTE

由于历史的原因，用户代理 *可以* 在接下来的请求里将 POST 方法改变为 GET 方法。如果不希望这种行为，可以使用 =307 (Temporary Redirect)= 状态码来代替。

*** 6.4.4. 303 查看其他 / See Other
:PROPERTIES:
:ID:       12c7ea0c-85ac-401f-8132-293e6ebcf52f
:END:

#+BEGIN_QUOTE
The =303 (See Other)= status code indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the =Location= header field, which is intended to provide an indirect response to the original request. A user agent can perform a retrieval request targeting that URI (a GET or HEAD request if using HTTP), which might also be redirected, and present the eventual result as an answer to the original request. Note that the new URI in the =Location= header field is not considered equivalent to the effective request URI.
#+END_QUOTE

=303 (See Other)= 状态码表明：服务器让用户代理重新定向到一个不同的资源上，正如在 =Location= 的字段值里所示的 URI 上，其意图是提供一个[[ruby:indirect][间接]]的响应到原始请求。用户代理可以执行一个[[ruby:retrieval%20request][检索请求]]（如果使用 HTTP 的话就是一个 GET 或者 HEAD）来定位这个 URI，这样同样可以重定向，并呈现最终结果来作为这个[[ruby:original%20request][原始请求]]的应答。需要注意的是在 =Location= 头字段里的新 URI 不被视为等同于[[ruby:effective%20request%20URI][有效请求 URI]]。 

#+BEGIN_QUOTE
译注：=300= 的 =Location= 字段值所指的 URI 表示资源有多个表示形式，=301= 和 =302= 中 =Location= 的 URI 表示资源在不同的位置上，这些 URI 所代表是同一个资源。与上述状态码不同的是，=303= 中 =Location= 的 URI 所指的是另一个不同的资源，所以有“间接”的意义。同时，正因为 =303= 的有效请求 URI 所代表的资源与 =Location= 的 URI 不是同一个，因为才有上述的“不视为等同”。
#+END_QUOTE

#+BEGIN_QUOTE
This status code is applicable to any HTTP method. It is primarily used to allow the output of a POST action to redirect the user agent to a selected resource, since doing so provides the information corresponding to the POST response in a form that can be separately identified, bookmarked, and cached, independent of the original request.
#+END_QUOTE

这个状态码适用于任何 HTTP 方法。它主要用来让一个 POST 动作的输出结果可以将用户代理重定向到一个选定的资源上，因为这样做可以以一种能够被单独[[ruby:indentified][标识]]、[[ruby:bookmarked][保存书签]]、[[ruby:cached][缓存]]的方式来提供这个 POST 响应对应的信息，而不依赖于原始请求。

#+BEGIN_QUOTE
A =303= response to a GET request indicates that the origin server does not have a representation of the target resource that can be transferred by the server over HTTP. However, the =Location= field value refers to a resource that is descriptive of the target resource, such that making a retrieval request on that other resource might result in a representation that is useful to recipients without implying that it represents the original target resource. Note that answers to the questions of what can be represented, what representations are adequate, and what might be a useful description are outside the scope of HTTP.
#+END_QUOTE

回应给 GET 请求的一个 =303= 响应表明：源服务器不存在一个目标资源的[[ruby:representation][表示形式]]能够通过 HTTP 来传输。尽管如此，=Location= 的字段值引用了另一个资源来描述这个目标资源，以便于向这个新资源发起一个检索请求时可以得到一个可用于接收端的表示形式而不必有任何暗示它（这个表示形式）代表了原始的目标资源。

#+BEGIN_QUOTE
Except for responses to a HEAD request, the representation of a =303= response ought to contain a short hypertext note with a hyperlink to the same URI reference provided in the =Location= header field.
#+END_QUOTE

除了回应给 HEAD 请求的响应以外，=303= 响应的表示形式应该包含一个简短的超文本[[ruby:note][注释]]，其内有一个与 =Location= 头字段相同的 URI 的超链接。

*** 6.4.5. 305 使用代理 / 305 Use Proxy
:PROPERTIES:
:ID:       e69019b2-b071-4380-bcd7-d2fd80261d81
:END:

#+BEGIN_QUOTE
The =305 (Use Proxy)= status code was defined in a previous version of this specification and is now deprecated ([[id:b9da2375-731c-4b8a-a7d5-b07352c045a9][Appendix B]]).
#+END_QUOTE

=305 (Use Proxy)= 状态码是本规范之前的版本所定义的，现在已经弃用（[[id:b9da2375-731c-4b8a-a7d5-b07352c045a9][附录 B]]）。

*** 6.4.6. 305 未使用 / 306 (Unused)

#+BEGIN_QUOTE
The =306= status code was defined in a previous version of this specification, is no longer used, and the code is reserved.
#+END_QUOTE

306 状态码是本规范之前的版本所定义的，已经不再使用，同时保留该状态码。

*** 6.4.7. 307 临时重定向 / 307 Temporary Redirect
:PROPERTIES:
:ID:       549c5916-48a9-4e75-8c68-538635c00a2c
:END:

#+BEGIN_QUOTE
The =307 (Temporary Redirect)= status code indicates that the target resource resides temporarily under a different URI and the user agent *MUST NOT* change the request method if it performs an automatic redirection to that URI. Since the redirection can change over time, the client ought to continue using the original effective request URI for future requests.
#+END_QUOTE

=307 (Temporary Redirect)= 状态码表明：目标资源临时处在一个不同的 URI 之下，并且如果用户代理执行自动重定向到该 URI 的话，*禁止* 改变请求方法。因为重定向可能随时会改变，客户端应该在将来的请求中继续使用原来的[[ruby:effective%20request%20URI][有效请求 URI]]（而不是使用本次响应中 =Location= 字段所指的那个 URI）。

#+BEGIN_QUOTE
The server *SHOULD* generate a =Location= header field in the response containing a URI reference for the different URI. The user agent *MAY* use the =Location= field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s).
#+END_QUOTE

服务器 *应当* 在响应里生成一个 =Location= 头字段来包含这个不同的 URI 引用。用户代理 *可以* 使用 =Location= 的字段值来自动重定向。服务器的响应有效载荷通常会包含一个简短的超文本[[ruby:note][注释]]，其内有一个指向这个（或多个）新 URI 的超链接。

#+BEGIN_QUOTE
*Note:* This status code is similar to =302 (Found)=, except that it does not allow changing the request method from POST to GET. This specification defines no equivalent counterpart for =301 (Moved Permanently)= ([[[https://tools.ietf.org/html/rfc7238][RFC7238]]], however, defines the status code =308 (Permanent Redirect)= for this purpose).
#+END_QUOTE

*注意：* 本状态码和 =302 (Found)= 类似，不同之处在于它并不允许请求方法从 POST 改变到 GET。本规范并没有（像 =307= 之于 =302= 一样）为 =301 (Moved Permanently)= 定义对应的等效版本（不过为此目的【[[https://tools.ietf.org/html/rfc7238][RFC7238]]】定义了 =308 (Permanent Redirect)= 状态码）。

** 6.5. 客户端错误 / Client Error 4xx
:PROPERTIES:
:ID:       d052de1c-5d88-41e3-baf6-c7a37a841de6
:END:

#+BEGIN_QUOTE
The =4xx (Client Error)= class of status code indicates that the client seems to have erred. Except when responding to a HEAD request, the server *SHOULD* send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition. These status codes are applicable to any request method. User agents *SHOULD* display any included representation to the user.
#+END_QUOTE

=4xx (Client Error)= 状态码种类表明：客户端貌似有错误。除了响应给 HEAD 请求的这种情况以外，服务器 *应当* 在其发送的响应里包含一个表示形式来解释这种[[ruby:error%20situation][错误情况]]，以及这是暂时还是永久的[[ruby:condition][状况]]。这些状态码适用于任何请求方法。用户代理 *应当* 向用户展示其内的任何表示形式。

*** 6.5.1. 400 无效请求 / 400 Bad Request
:PROPERTIES:
:ID:       323c581a-d558-421f-a0f1-8c28fe904264
:END:

#+BEGIN_QUOTE
The =400 (Bad Request)= status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).
#+END_QUOTE

=400 (Bad Request)= 状态码表明：由于某些被认为是客户端的错误，导致服务器[[ruby:cannot][无法]]或者[[ruby:will%20not][不会]]处理这个请求（比如，错误的请求[[ruby:syntax][句法]]、无效的请求报文[[ruby:framing][分帧]]、欺骗性的请求[[ruby:routing][路由]]等）。

*** 6.5.2. 402 要求付费 / 402 Payment Required
:PROPERTIES:
:ID:       d4484e6e-b1a9-4ae9-b8cd-5da28a80fce7
:END:

#+BEGIN_QUOTE
The =402 (Payment Required)= status code is reserved for future use.
#+END_QUOTE

=402 (Payment Required)= 状态码保留为将来使用。

*** 6.5.3. 403 禁止 / 403 Forbidden
:PROPERTIES:
:ID:       addb601c-6b2f-45a7-97f7-9d24bdb8b585
:END:

#+BEGIN_QUOTE
The =403 (Forbidden)= status code indicates that the server understood the request but refuses to authorize it. A server that wishes to make public why the request has been forbidden can describe that reason in the response payload (if any).
#+END_QUOTE

=403 (Forbidden)= 状态码表明：服务器理解这个请求但拒绝授权。如果服务器希望公布“为什么这个请求被禁止”的话，可以在[[ruby:response%20payload][响应有效载荷]]（如果有的话）里描述其原因。

#+BEGIN_QUOTE
If authentication credentials were provided in the request, the server considers them insufficient to grant access. The client *SHOULD NOT* automatically repeat the request with the same credentials. The client *MAY* repeat the request with new or different credentials. However, a request might be forbidden for reasons unrelated to the credentials.
#+END_QUOTE

如果该请求提供了[[ruby:authentication%20credentials][认证凭据]]，那么 =404= 表示服务器认为它们还不足以予以访问。客户端 *不应当* 使用相同的凭据来自动重复这个请求。客户端 *可以* 使用新的或不同的凭据来重复该请求。尽管如此，请求可能出于凭据不相关的其他原因而被禁止。

#+BEGIN_QUOTE
An origin server that wishes to "hide" the current existence of a forbidden target resource *MAY* instead respond with a status code of =404 (Not Found)=.
#+END_QUOTE

如果源服务器希望对这个请求“隐藏”被禁止的目标资源的存在，它 *可以* 使用 =404 (Not Found)= 来代替 =403=。

*** 6.5.4. 404 没有找到 / 404 Not Found
:PROPERTIES:
:ID:       aff1f620-f950-48fe-a479-0276d2aeac0e
:END:

#+BEGIN_QUOTE
The =404 (Not Found)= status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists. A =404= status code does not indicate whether this lack of representation is temporary or permanent; the =410 (Gone)= status code is preferred over =404= if the origin server knows, presumably through some configurable means, that the condition is likely to be permanent.
#+END_QUOTE

=404 (Not Found)= 状态码表明：源服务器没有找到目标资源的一个[[ruby:current%20representation][当前表示形式]]，或者不想公开它的存在。=404= 状态码并没有表明表示形式的缺失是暂时的还是永久的。如果服务器（假定通过某些可配置的手段）得知这种状况很可能是永久的，那么，使用 =410 (Gone)= 状态码优于 =404=。

#+BEGIN_QUOTE
A =404= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=404= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.5.5. 405 方法不允许 / 405 Method Not Allowed
:PROPERTIES:
:ID:       6c2a3e21-55e6-465c-b8dc-7d773d341e8f
:END:

#+BEGIN_QUOTE
The =405 (Method Not Allowed)= status code indicates that the method received in the request-line is known by the origin server but not supported by the target resource. The origin server *MUST* generate an =Allow= header field in a =405= response containing a list of the target resource's currently supported methods.
#+END_QUOTE

=405 (Method Not Allowed)= 状态码表明：接收自[[ruby:request-line][请求行]]的方法为源服务器所知，但不为目标资源所支持。源服务器 *必须* 在 =405= 响应里生成一个 =Allow= 头字段来包含目标资源目前所支持的一系列的方法。

#+BEGIN_QUOTE
A =405= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=405= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.5.6. 406 不接受 / 406 Not Acceptable
:PROPERTIES:
:ID:       c600bda4-d399-4870-894f-ea4293fc173f
:END:

#+BEGIN_QUOTE
The =406 (Not Acceptable)= status code indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request ([[id:99513880-9381-41eb-91ee-483b42d025e8][Section 5.3]]), and the server is unwilling to supply a default representation.
#+END_QUOTE

=406 (Not Acceptable)= 状态码表明：根据在这个请求里接收到的主动协商相关的头字段（[[id:99513880-9381-41eb-91ee-483b42d025e8][章节 5.3]]）来看，目标资源没有一种用户代理[[ruby:acceptable][能接受的]][[ruby:current%20representation][当前表示形式]]，而且服务器并不愿意提供一个默认的表示形式。

#+BEGIN_QUOTE
The server *SHOULD* generate a payload containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate. A user agent *MAY* automatically select the most appropriate choice from that list. However, this specification does not define any standard for such automatic selection, as described in [[id:bb139936-2671-4ffc-9dd0-75af2bab7d9b][Section 6.4.1]].
#+END_QUOTE

服务器 *应当* 生成一个有效载荷来包含一个列表，列表中有各种可用的表示形式的特点及其对应的资源定位符，让用户或者用户代理可以从中选择一个最合适的。用户代理 *可以* 从该列表中[[ruby:automatically%20select][自动选择]]最合适的表示形式。但是，本规范并没有为这种自动选择定义任何标准，见[[id:bb139936-2671-4ffc-9dd0-75af2bab7d9b][章节 6.4.1]]。

*** 6.5.7. 408 请求超时 / 408 Request Timeout
:PROPERTIES:
:ID:       8523542a-3e33-4261-92b7-0bf706f14a57
:END:

#+BEGIN_QUOTE
The =408 (Request Timeout)= status code indicates that the server did not receive a complete request message within the time that it was prepared to wait. A server *SHOULD* send the "close" connection option ([[id:40B2B721-F916-41EA-86FB-514FDED5B3A4][Section 6.1]] of [RFC7230]) in the response, since =408= implies that the server has decided to close the connection rather than continue waiting. If the client has an outstanding request in transit, the client *MAY* repeat that request on a new connection.
#+END_QUOTE

=408 (Request Timeout)= 状态码表明：服务器并没有在等待时间内接收到一个完整的请求消息。由于 =408= 意味着服务器已经决定关闭连接而不是继续等待，因此，服务器 *应当* 在响应中发送一个 "close" 连接选项（[[id:40B2B721-F916-41EA-86FB-514FDED5B3A4][【RFC7230】章节 6.1]]）。如果客户端有一个[[ruby:outstanding][未偿付]]的请求（也就是说，服务器未响应该请求）正在连接中传输，那么，客户端 *可以* 在一个新的连接中重复该请求。

*** 6.5.8. 409 冲突 / 409 Conflict
:PROPERTIES:
:ID:       63517bec-7c89-4655-a6df-e5e2c8de4a17
:END:

#+BEGIN_QUOTE
The =409 (Conflict)= status code indicates that the request could not be completed due to a conflict with the current state of the target resource. This code is used in situations where the user might be able to resolve the conflict and resubmit the request. The server *SHOULD* generate a payload that includes enough information for a user to recognize the source of the conflict.
#+END_QUOTE

=409 (Conflict)= 状态码表明：由于这个请求与目标资源的当前状态存在冲突，请求无法完成。本状态码用在用户可能有能力解决冲突并且重新提交该请求的情况。服务器 *应当* 生成一个有效载荷来包含足够的信息，让用户可以识别出冲突的源头。

#+BEGIN_QUOTE
Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the representation being PUT included changes to a resource that conflict with those made by an earlier (third-party) request, the origin server might use a =409= response to indicate that it can't complete the request. In this case, the response representation would likely contain information useful for merging the differences based on the revision history.
#+END_QUOTE

冲突很可能发生在回应给 PUT 请求的响应里。例如，如果使用了[[ruby:versioning][版本控制]]，并且将要被 PUT 的表示形式包含了对资源的变更，这些变更与一个更早的（第三方）请求相冲突，那么，源服务器可以使用一个 =409= 响应来表明它不能完成该请求。在这种情况下，响应的表示形式可能会包含有助于基于[[ruby:revision%20history][修订记录]]来合并差异的信息。

*** 6.5.9. 410 已不在 / 410 Gone
:PROPERTIES:
:ID:       9b6a1a09-f457-45b9-9b66-b05916f8d1a0
:END:

#+BEGIN_QUOTE
The =410 (Gone)= status code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent. If the origin server does not know, or has no facility to determine, whether or not the condition is permanent, the status code =404 (Not Found)= ought to be used instead.
#+END_QUOTE

=410 (Gone)= 状态码表明：对目标资源的访问在源服务器上已经不再可用，并且这种状况很可能是永久的。如果源服务器并不了解，或者不容易确定，这种状况是否是永久的，那么，应该使用 =404 (Not Found)= 状态码来代替。

#+BEGIN_QUOTE
The =410= response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer associated with the origin server's site. It is not necessary to mark all permanently unavailable resources as "gone" or to keep the mark for any length of time — that is left to the discretion of the server owner.
#+END_QUOTE

=410= 响应主要是为了辅助网站维护的工作——通过通知接收端这个资源是有意设为不可用的，并且[[ruby:server%20owners][服务器所有者]]希望这些引用该资源的[[ruby:remote%20links][远程链接]]得到删除。常见于限定时间的促销活动和属于个人的资源不再与源服务器的网站相关联的情况。不需要将所有永久不可用的资源都标记为 "gone" 或者将这些标记维持在任意长的时间里——那是留给服务器所有者来决定的。

#+BEGIN_QUOTE
A =410= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=410= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.5.10. 411 要求长度 / 411 Length Required
:PROPERTIES:
:ID:       57b9a13c-fa90-4ad0-a898-dbb7a80b007c
:END:

#+BEGIN_QUOTE
The =411 (Length Required)= status code indicates that the server refuses to accept the request without a defined =Content-Length= ([[id:7b3e90b9-3ae5-402b-922c-2342d361c79f][Section 3.3.2]] of [RFC7230]). The client *MAY* repeat the request if it adds a valid =Content-Length= header field containing the length of the message body in the request message.
#+END_QUOTE

=411 (Length Required)= 状态码表明：服务器拒绝接受这个没有定义 =Content-Length= （[[id:7b3e90b9-3ae5-402b-922c-2342d361c79f][【RFC7230】章节 3.3.3]]）的请求。如果客户端在请求消息中添加了一个包含[[ruby:message%20body][消息体]]长度的合法 =Content-Length= 头字段，那么，客户端 *可以* 重复这个请求。

*** 6.5.11. 413 有效载荷过大 / 413 Payload Too Large
:PROPERTIES:
:ID:       620869b7-1f42-4bb9-a3ba-664e80d5161d
:END:

#+BEGIN_QUOTE
The =413 (Payload Too Large)= status code indicates that the server is refusing to process a request because the request payload is larger than the server is willing or able to process. The server *MAY* close the connection to prevent the client from continuing the request.
#+END_QUOTE

=413 (Payload Too Large)= 状态码表明：服务器拒绝处理这个请求，因为请求的有效载荷的大小超出了服务器所愿意或能够处理的限制。服务器 *可以* 关闭连接来阻止客户端继续这个请求。

#+BEGIN_QUOTE
If the condition is temporary, the server *SHOULD* generate a =Retry-After= header field to indicate that it is temporary and after what time the client *MAY* try again.
#+END_QUOTE

如果这种状况是暂时的，服务器 *应当* 生成一个 =Retry-After= 头字段来表明：这只是暂时的，以及在什么时间以后客户端 *可以* 重试。

*** 6.5.12. 414 URI 过长 / 414 URI Too Long
:PROPERTIES:
:ID:       77d1edbb-ceeb-450d-9b85-5f8c89db2f97
:END:

#+BEGIN_QUOTE
The =414 (URI Too Long)= status code indicates that the server is refusing to service the request because the request-target ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]) is longer than the server is willing to interpret. This rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query information, when the client has descended into a "black hole" of redirection (e.g., a redirected URI prefix that points to a suffix of itself) or when the server is under attack by a client attempting to exploit potential security holes.
#+END_QUOTE

=414 (URI Too Long)= 状态码表明：服务器拒绝服务这个请求，因为[[ruby:request-target][请求目标]]（[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]）的长度超出了服务器所愿意[[ruby:interpret][解释]]的限制。这种状况极少出现，仅可能发生在：当客户端将一个 POST 请求不恰当地转换为一个带有超长[[ruby:query%20information][查询信息]]的 GET 请求的时候；当客户端坠入一个重定向“[[ruby:black%20hole][黑洞]]”（比如，一个重定向的 URI 前缀指向到它自己的一个后缀上）的时候；当服务器被客户端试图挖掘潜在的安全漏洞的时候。

#+BEGIN_QUOTE
译注：重定向“黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。
#+END_QUOTE

#+BEGIN_QUOTE
译注：某些服务器使用了固定长度的缓冲来读取或操作请求 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出。
#+END_QUOTE

#+BEGIN_QUOTE
A =414= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=414= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.5.13. 415 不支持的媒体类型 / 415 Unsupported Media Type
:PROPERTIES:
:ID:       7c879fad-0a52-4f22-8447-38b860f3e71d
:END:

#+BEGIN_QUOTE
The =415 (Unsupported Media Type)= status code indicates that the origin server is refusing to service the request because the payload is in a format not supported by this method on the target resource. The format problem might be due to the request's indicated =Content-Type= or =Content-Encoding=, or as a result of inspecting the data directly.
#+END_QUOTE

=415 (Unsupported Media Type)= 状态码表明：源服务器拒绝服务这个请求，因为有效载荷处于某种格式，请求方法不支持将该种格式作用到目标资源上。这种格式问题可能是由于这个请求所指明的 =Content-Type= 或 =Content-Encoding=，或者直接检查数据得出的结果。

*** 6.5.14. 417 期望错误 / 417 Expectation Failed
:PROPERTIES:
:ID:       a4b990e6-b91e-422d-ad8e-cb77866ed170
:END:

#+BEGIN_QUOTE
The =417 (Expectation Failed)= status code indicates that the expectation given in the request's =Expect= header field ([[id:0b0cea12-0af7-47f1-8908-2afc48ce3fb2][Section 5.1.1]]) could not be met by at least one of the inbound servers.
#+END_QUOTE

=417 (Expectation Failed)= 状态码表明：请求中的 =Expect= 头字段（[[id:0b0cea12-0af7-47f1-8908-2afc48ce3fb2][章节 5.1.1]]）所给定的[[ruby:expectation][期望]]不能被至少一个[[ruby:inbound%20servers][入站服务器]]所[[ruby:meet][完成]]。

*** 6.5.15. 426 要求升级 / 426 Upgrade Required
:PROPERTIES:
:ID:       5d028105-552c-4079-bcfe-30809395f6c9
:END:

#+BEGIN_QUOTE
The =426 (Upgrade Required)= status code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server *MUST* send an =Upgrade= header field in a =426= response to indicate the required protocol(s) ([[id:62632d23-475d-4daa-8efb-3206d370573a][Section 6.7]] of [RFC7230]).
#+END_QUOTE

=426 (Upgrade Required)= 状态码表明：服务器拒绝使用当前协议来执行这个请求，但是，在客户端升级到一种不同的协议后，它可能愿意这样做。服务器 *必须* 在 =426= 响应里带有一个 =Upgrade= 头字段来指明所要求的一个或多个协议（[[id:62632d23-475d-4daa-8efb-3206d370573a][【RFC7230】章节 6.7]]）。

#+BEGIN_QUOTE
Example:
#+END_QUOTE

例如：

#+BEGIN_EXAMPLE
  HTTP/1.1 426 Upgrade Required
  Upgrade: HTTP/3.0
  Connection: Upgrade
  Content-Length: 53
  Content-Type: text/plain

  This service requires use of the HTTP/3.0 protocol.
#+END_EXAMPLE

** 6.6. 服务器错误 / Server Error 5xx
:PROPERTIES:
:ID:       6b95899d-bbec-474e-bcb0-3ca5dbbf0ba1
:END:

#+BEGIN_QUOTE
The =5xx (Server Error)= class of status code indicates that the server is aware that it has erred or is incapable of performing the requested method. Except when responding to a HEAD request, the server *SHOULD* send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition. A user agent *SHOULD* display any included representation to the user. These response codes are applicable to any request method.
#+END_QUOTE

=5xx (Server Error)= 状态码种类表明：服务器意识到它有错误或者它无法执行所请求的方法。除了响应给 HEAD 请求这种情况以外，服务器 *应当* 在其发送的响应里包含一个表示形式来解释这种[[ruby:error%20situation][错误情况]]，以及这是暂时还是永久的[[ruby:condition][状况]]。用户代理 *应当* 向用户展示其内的任何表示形式。这些状态码适用于任何请求方法。

*** 6.6.1. 500 服务器内部错误 / 500 Internal Server Error
:PROPERTIES:
:ID:       4a288d4c-063f-4589-9ec6-3c4f246e2d8a
:END:

#+BEGIN_QUOTE
The =500 (Internal Server Error)= status code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.
#+END_QUOTE

=500 (Internal Server Error)= 状态码表明：服务器遇到一种异常状况阻止了它[[ruby:fulfill][实现]]这个请求。

*** 6.6.2. 501 没有实现 / 501 Not Implemented
:PROPERTIES:
:ID:       776a0530-a654-43bc-879b-186e39dbff63
:END:

#+BEGIN_QUOTE
The =501 (Not Implemented)= status code indicates that the server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
#+END_QUOTE

=501 (Not Implemented)= 状态码表明：服务器并不支持[[ruby:fulfill][实现]]这个请求所需要的功能。当服务器无法识别出请求方法并且它无法支持任何资源的时候，响应这个状态码是很合适。

#+BEGIN_QUOTE
A =501= response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see [[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][Section 4.2.2]] of [RFC7234]).
#+END_QUOTE

=501= 响应默认是[[ruby:cacheable][可缓存的]]，也就是说，除非在请求方法的定义里另有指定，或者显式带有[[ruby:cache%20controls][缓存控制]]（[[id:9bcea6ca-bab6-4324-9cdb-cf7855aeba01][【RFC7234】章节 4.2.2]]）。

*** 6.6.3. 502 无效网关 / 502 Bad Gateway
:PROPERTIES:
:ID:       dd36be96-0bfa-4dbc-8656-132fe9509b14
:END:

#+BEGIN_QUOTE
The =502 (Bad Gateway)= status code indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.
#+END_QUOTE

=502 (Bad Gateway)= 状态码表明：当服务器充当一个网关或代理的时候，在它试图[[ruby:fulfill][实现]]这个请求的时候，从一个[[ruby:inbound%20server][站内服务器]]里接收到一个无效的响应。

*** 6.6.4. 503 服务不可用 / 503 Service Unavailable
:PROPERTIES:
:ID:       4e09afe4-30a3-4bbb-aa7e-23f621d42801
:END:

#+BEGIN_QUOTE
The =503 (Service Unavailable)= status code indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. The server *MAY* send a =Retry-After= header field ([[id:f7b225e0-95f5-4d59-81c2-afbf6abb1656][Section 7.1.3]]) to suggest an appropriate amount of time for the client to wait before retrying the request.
#+END_QUOTE

=503 (Service Unavailable)= 状态码表明：由于临时的[[ruby:overload][过载]]或者计划好的[[ruby:maintenance][维护]]，导致服务器当前无法处理这个请求，可能等一段时间后就会恢复过来。服务器 *可以* 在其发送的响应里带有一个 =Retry-After= 头字段（[[id:f7b225e0-95f5-4d59-81c2-afbf6abb1656][章节 7.1.3]]）来向客户端建议一个合适的等待时长再进行重试请求。

#+BEGIN_QUOTE
*Note:* The existence of the =503= status code does not imply that a server has to use it when becoming overloaded. Some servers might simply refuse the connection.
#+END_QUOTE

*注意：* =503= 的存在并不意味着当服务器出现过载的时候必须使用它。某些服务器可能只是简单地拒绝连接。

*** 6.6.5. 504 网关超时 / 504 Gateway Timeout
:PROPERTIES:
:ID:       4502f86d-74d1-4890-b235-3155ba125cb6
:END:

#+BEGIN_QUOTE
The =504 (Gateway Timeout)= status code indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request.
#+END_QUOTE

=504 (Gateway Timeout)= 状态码表明：当服务器充当一个网关或代理的时候，它并没有在限时内从[[ruby:upstream%20server][上游服务器]]——为了[[ruby:complete][完成]]这个请求而需要访问的服务器——接收到一个响应。

*** 6.6.6. 505 HTTP 版本不支持 / 505 HTTP Version Not Supported
:PROPERTIES:
:ID:       00dabed7-f9a1-471e-a9f6-77220446dbfa
:END:

#+BEGIN_QUOTE
The =505 (HTTP Version Not Supported)= status code indicates that the server does not support, or refuses to support, the major version of HTTP that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in Section 2.6 of [RFC7230], other than with this error message. The server *SHOULD* generate a representation for the =505= response that describes why that version is not supported and what other protocols are supported by that server.
#+END_QUOTE

=505 (HTTP Version Not Supported)= 状态码表明：服务器并不支持，或者拒绝支持，用在这个请求消息里的 HTTP 的[[ruby:major%20version][主版本]]。服务器表明它不能或不愿意使用与客户端相同的 HTTP 主版本来完成这个请求，详情见[[id:d1387674-a388-4ea6-9165-1ded175d90b4][【RFC7230】章节 2.6]]；而是使用这个错误消息。服务器 *应当* 为 =505= 响应生成一个表示形式来描述“为什么不支持那个版本”以及“服务器支持其他哪些协议”。

#+BEGIN_QUOTE
译注：HTTP 使用“<主版本>.<次版本>”这种[[ruby:numbering%20scheme][编号方案]]来表明协议的版本，如 HTTP/1.0、HTTP/1.1 等。详情见[[id:d1387674-a388-4ea6-9165-1ded175d90b4][【RFC7230】章节 2.6]]。
#+END_QUOTE

* 7. 响应头字段 / Response Header Fields
:PROPERTIES:
:ID:       30e7b781-4a14-4519-abb9-63ec43516b98
:END:

#+BEGIN_QUOTE
The response header fields allow the server to pass additional information about the response beyond what is placed in the status-line. These header fields give information about the server, about further access to the target resource, or about related resources.
#+END_QUOTE

除了放在[[ruby:status-line][状态行]]的响应信息以外，[[ruby:response%20header%20fields][响应头字段]]让服务器可以传递额外的响应相关信息。这些头字段给出了关于服务器、关于对目标资源的后续访问、或者关于相关联的资源的信息。

#+BEGIN_QUOTE
Although each response header field has a defined meaning, in general, the precise semantics might be further refined by the semantics of the request method and/or response status code.
#+END_QUOTE

虽然每种响应头字段都定义了含义，但通常情况下，更精确的语义可能经由[[ruby:request%20method][请求方法]]以及（或者）[[ruby:response%20status%20code][响应状态码]]来进一步精炼。

** 7.1. 控制数据 / Control Data

#+BEGIN_QUOTE
Response header fields can supply control data that supplements the status code, directs caching, or instructs the client where to go next.
#+END_QUOTE

响应头字段能够提供以下方面的控制数据：补充状态码（如 =Location= 头字段提供了 =302= 重定向所需的 URI）；指导缓存；指导客户端下一步去哪里。

| Header Field Name | Defined in...            |
|-------------------+--------------------------|
| Age               | [[id:0fda7a59-2592-493d-9ce1-01e72543c6c0][Section 5.1]] of [RFC7234] |
| Cache-Control     | [[id:03c2dad4-a6d2-4d3c-b087-d08717bf09ec][Section 5.2]] of [RFC7234] |
| Expires           | [[id:18d3caca-869d-4ae8-8038-2c57cd36fef5][Section 5.3]] of [RFC7234] |
| Date              | [[id:5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1][Section 7.1.1.2]]          |
| Location          | [[id:bc2baf29-0bf6-4816-865c-3d33f5fe38e3][Section 7.1.2]]            |
| Retry-After       | [[id:f7b225e0-95f5-4d59-81c2-afbf6abb1656][Section 7.1.3]]            |
| Vary              | [[id:ca7f8781-b183-4563-a90a-b9b7ad4f1032][Section 7.1.4]]            |
| Warning           | [[id:84f5867e-4a3e-45fa-b085-dd23e8598a6b][Section 5.5]] of [RFC7234] |

*** 7.1.1. 创始日期 / Origination Date

**** 7.1.1.1. 日期时间格式 / Date/Time Formats
:PROPERTIES:
:ID:       2091e4af-684f-4511-aaa1-8094dc7dcb21
:END:

#+BEGIN_QUOTE
Prior to 1995, there were three different formats commonly used by servers to communicate timestamps. For compatibility with old implementations, all three are defined here. The preferred format is a fixed-length and single-zone subset of the date and time specification used by the Internet Message Format [[[https://tools.ietf.org/html/rfc5322][RFC5322]]].
#+END_QUOTE

1995 年前，总共有三种不同的格式常用于服务器来传达[[ruby:timestamps][时间戳]]。为了兼容旧有的实现，所有这三种都定义在这里。首选的格式是[[ruby:Internet%20Message%20Format][互联网消息格式]]【[[https://tools.ietf.org/html/rfc5322][RFC5322]]】所使用的日期和时间规范——一种固定长度的、单一时区的时间格式。

#+BEGIN_QUOTE
译注：所谓“单一时区”是因为 IMF（Internet Message Format）日期和时间规范里的[[ruby:zone][时区]]支持多时区（虽然定义为已淘汰），这里取其 =obs-zone= ABNF 规则里的一个子集，见[[https://tools.ietf.org/html/rfc5322#section-3.3][【RFC5322】章节 3.3]]。
#+END_QUOTE

#+BEGIN_SRC text
  HTTP-date    = IMF-fixdate / obs-date
#+END_SRC

#+BEGIN_QUOTE
An example of the preferred format is
#+END_QUOTE

首选格式的一个例子：

#+BEGIN_EXAMPLE
  Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
#+END_EXAMPLE

#+BEGIN_QUOTE
Examples of the two obsolete formats are
#+END_QUOTE

两种已淘汰的格式的例子：

#+BEGIN_EXAMPLE
  Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
  Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
#+END_EXAMPLE

#+BEGIN_QUOTE
A recipient that parses a timestamp value in an HTTP header field *MUST* accept all three =HTTP-date= formats. When a sender generates a header field that contains one or more timestamps defined as =HTTP-date=, the sender *MUST* generate those timestamps in the =IMF-fixdate= format.
#+END_QUOTE

接收端对某个 HTTP 头字段里的时间戳值进行[[ruby:parse][解析]]的时候，*必须* 接受所有这三种 HTTP 日期格式。当发送端生成带有一个或多个作为 =HTTP-date= 的时间戳的头字段时，发送端 *必须* 以 =IMF-fixdate= 格式生成那些时间戳（即本规范首选的那一种格式）。

#+BEGIN_QUOTE
An =HTTP-date= value represents time as an instance of Coordinated Universal Time (UTC). The first two formats indicate UTC by the three-letter abbreviation for Greenwich Mean Time, "GMT", a predecessor of the UTC name; values in the asctime format are assumed to be in UTC. A sender that generates =HTTP-date= values from a local clock ought to use NTP ([[[https://tools.ietf.org/html/rfc5905][RFC5905]]]) or some similar protocol to synchronize its clock to UTC.
#+END_QUOTE

一个 =HTTP-date= 的值表示一个[[ruby:Coordinated%20Universal%20Time][世界标准时间]]（UTC）。上述三个例子中的前两例通过[[ruby:Greenwich%20Mean%20Time][格林威治标准时间]]——UTC 名称的前身——的三个英文字母缩写 "GMT" 来表明是 UTC。而 =asctime= 格式（即上述第三例）假定时间是 UTC 的。发送端从本地时钟生成 =HTTP-date= 值的时候，应该使用 NTP（【[[https://tools.ietf.org/html/rfc5905][RFC5905]]】）或者其他类似的协议来将本地时间同步为 UTC。

#+BEGIN_QUOTE
Preferred format:
#+END_QUOTE

首选的格式：

#+BEGIN_SRC text
  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %x4D.6F.6E ; "Mon", case-sensitive
               / %x54.75.65 ; "Tue", case-sensitive
               / %x57.65.64 ; "Wed", case-sensitive
               / %x54.68.75 ; "Thu", case-sensitive
               / %x46.72.69 ; "Fri", case-sensitive
               / %x53.61.74 ; "Sat", case-sensitive
               / %x53.75.6E ; "Sun", case-sensitive

  date1        = day SP month SP year
               ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %x4A.61.6E ; "Jan", case-sensitive
               / %x46.65.62 ; "Feb", case-sensitive
               / %x4D.61.72 ; "Mar", case-sensitive
               / %x41.70.72 ; "Apr", case-sensitive
               / %x4D.61.79 ; "May", case-sensitive
               / %x4A.75.6E ; "Jun", case-sensitive
               / %x4A.75.6C ; "Jul", case-sensitive
               / %x41.75.67 ; "Aug", case-sensitive
               / %x53.65.70 ; "Sep", case-sensitive
               / %x4F.63.74 ; "Oct", case-sensitive
               / %x4E.6F.76 ; "Nov", case-sensitive
               / %x44.65.63 ; "Dec", case-sensitive
  year         = 4DIGIT

  GMT          = %x47.4D.54 ; "GMT", case-sensitive

  time-of-day  = hour ":" minute ":" second
               ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT               
  minute       = 2DIGIT               
  second       = 2DIGIT               
#+END_SRC
  
#+BEGIN_QUOTE
Obsolete formats:
#+END_QUOTE

已淘汰的格式：

#+BEGIN_SRC text
  obs-date     = rfc850-date / asctime-date 
  rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
  date2        = day "-" month "-" 2DIGIT
               ; e.g., 02-Jun-82

  day-name-l   = %x4D.6F.6E.64.61.79    ; "Monday", case-sensitive
         / %x54.75.65.73.64.61.79       ; "Tuesday", case-sensitive
         / %x57.65.64.6E.65.73.64.61.79 ; "Wednesday", case-sensitive
         / %x54.68.75.72.73.64.61.79    ; "Thursday", case-sensitive
         / %x46.72.69.64.61.79          ; "Friday", case-sensitive
         / %x53.61.74.75.72.64.61.79    ; "Saturday", case-sensitive
         / %x53.75.6E.64.61.79          ; "Sunday", case-sensitive

  asctime-date = day-name SP date3 SP time-of-day SP year
  date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
               ; e.g., Jun  2
#+END_SRC

#+BEGIN_QUOTE
=HTTP-date= is case sensitive. A sender *MUST NOT* generate additional whitespace in an =HTTP-date= beyond that specifically included as =SP= in the grammar. The semantics of =day-name=, =day=, =month=, =year=, and =time-of-day= are the same as those defined for the Internet Message Format constructs with the corresponding name ([RFC5322], [[https://tools.ietf.org/html/rfc5322#section-3.3][Section 3.3]]).
#+END_QUOTE

=HTTP-date= 是区分大小写的。发送端 *禁止* 在一个 =HTTP-date= 里生成除在语法中明确添加了 =SP= 以外的额外空格。=day-name=、=day=、=month=、=year= 以及 =time-of-day= 的语义与[[ruby:Internet%20Message%20Format][互联网消息格式]]里所定义同名结构的语义相一致（[[https://tools.ietf.org/html/rfc5322#section-3.3][【RFC5322】章节 3.3]]）。

#+BEGIN_QUOTE
Recipients of a timestamp value in =rfc850-date= format, which uses a two-digit year, *MUST* interpret a timestamp that appears to be more than 50 years in the future as representing the most recent year in the past that had the same last two digits.
#+END_QUOTE

=rfc850-date= 格式的时间戳使用两位数字来表示年份，如果接收端接收到一个 =rfc850-date= 格式的时间戳，*必须* 将时间戳里看起来像是未来 50 年以上的年份为过去最近具有这两位数字相同的年份。 

#+BEGIN_QUOTE
译注：
由于两位数字表示的年份无法表现出世纪，因此，要将一个 2 位数字表示的年份转换为 4 位数字表示的年份时可将这个 2 位数字的年份限定在距今前后 50 年内。如果这 2 位数比当前年的差超过 50 年，则认为是过去时间。

例如，假设当前年份为 2018 年，要转换的时间戳的月、日、时、分、秒以及毫秒数与当前瞬时时间一致（即不考虑除年份以外的因素）：

- 如果 2 位数字的年份为 02，那么 02 比 18 小，则认为是过去时间，距今最近的 02 年是 2002 年，那么 2002 就是转换的结果；
- 如果 2 位数字的年份为 20，那么 20 比 18 大，则认为是未来时间，且 2020 距今（2018）只相差 2 年，不超过 50 年，那么 2020 就是转换的结果；
- 如果 2 位数字的年份为 68，那么 68 比 18 大，则认为是未来时间，且 2068 距今（2018）只相差 50 年，不超过 50 年，那么 2068 就是转换的结果；
- 如果 2 位数字的年份为 69，那么 69 比 18 大，则认为是未来时间，且 2069 距今（2018）只相差 51 年，不超过 50 年，那么 1969 就是转换的结果。

再给一个详细的转换表：

| 2位数年份 | 在2017年时转换为 | 在2018年时转换为 | 在2020年转换为 |
| <c>       | <c>              | <c>              | <c>            |
|-----------+------------------+------------------+----------------|
| 1         | 2001             | 2001             |           2001 |
| 2         | 2002             | 2002             |           2002 |
| 16        | 2016             | 2016             |           2016 |
| 17        | 2017             | 2017             |           2017 |
| 18        | 2018             | 2018             |           2018 |
| 19        | 2019             | 2019             |           2019 |
| 20        | 2020             | 2020             |           2020 |
| 21        | 2021             | 2021             |           2021 |
| 22        | 2022             | 2022             |           2022 |
| 65        | 2065             | 2065             |           2065 |
| 66        | 2066             | 2066             |           2066 |
| 67        | 2067             | 2067             |           2067 |
| 68        | 1968             | 2068             |           2068 |
| 69        | 1969             | 1969             |           2069 |
| 70        | 1970             | 1970             |           2070 |
| 71        | 1971             | 1971             |           1971 |
| 72        | 1972             | 1972             |           1972 |
| 87        | 1987             | 1987             |           1987 |
| 99        | 1999             | 1999             |           1999 |
#+END_QUOTE

#+BEGIN_QUOTE
Recipients of timestamp values are encouraged to be robust in parsing timestamps unless otherwise restricted by the field definition. For example, messages are occasionally forwarded over HTTP from a non-HTTP source that might generate any of the date and time specifications defined by the Internet Message Format.
#+END_QUOTE

鼓励接收端在[[ruby:parse][解析]]时间戳的时候足够[[ruby:robust][健壮]]，除非被字段的定义另有限制。例如，不定期地从某个非 HTTP 源通过 HTTP 转发的消息，可能生成[[ruby:Internet%20Message%20Format][互联网消息格式]]所使用的日期和时间规范里的任何一种格式。

#+BEGIN_QUOTE
*Note:* HTTP requirements for the date/time stamp format apply only to their usage within the protocol stream. Implementations are not required to use these formats for user presentation, request logging, etc.
#+END_QUOTE

*注意：* HTTP 对时间戳的格式要求仅应用于它们在协议流里的用途。不要求[[ruby:implementations][实现]]使用这些格式来进行用户展示、请求日志记录等。

**** 7.1.1.2. Date
:PROPERTIES:
:ID:       5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1
:END:

#+BEGIN_QUOTE
The "Date" header field represents the date and time at which the message was originated, having the same semantics as the Origination Date Field (=orig-date=) defined in [[https://tools.ietf.org/html/rfc5322#section-3.6.1][Section 3.6.1]] of [RFC5322]. The field value is an =HTTP-date=, as defined in [[id:2091e4af-684f-4511-aaa1-8094dc7dcb21][Section 7.1.1.1]].
#+END_QUOTE

=Date= 头字段表示在消息[[ruby:originated][创始]]的日期和时间，与定义在[[https://tools.ietf.org/html/rfc5322#section-3.6.1][【RFC5322】章节 3.6.1]] 里的[[ruby:Origination%20Date%20Field][创始日期字段]]（=orig-date=）具有相同的语义。它的字段值是一个 =HTTP-date=，正如[[id:2091e4af-684f-4511-aaa1-8094dc7dcb21][章节 7.1.1.1]] 所定义。

#+BEGIN_SRC text
  Date = HTTP-date
#+END_SRC

#+BEGIN_QUOTE
An example is
#+END_QUOTE

一个例子：

#+BEGIN_EXAMPLE
  Date: Tue, 15 Nov 1994 08:12:31 GMT
#+END_EXAMPLE

#+BEGIN_QUOTE
When a =Date= header field is generated, the sender *SHOULD* generate its field value as the best available approximation of the date and time of message generation. In theory, the date ought to represent the moment just before the payload is generated. In practice, the date can be generated at any time during message origination.
#+END_QUOTE

当生成一个 =Date= 头字段的时候，发送端 *应当* 将它的值生成为最接近消息生成的时间。理论上，该时间应该代表有效载荷就要生成好之前的时候。实践过程中，该时间可以生成为消息创始过程中的任意时候。

#+BEGIN_QUOTE
An origin server *MUST NOT* send a =Date= header field if it does not have a clock capable of providing a reasonable approximation of the current instance in Coordinated Universal Time. An origin server *MAY* send a =Date= header field if the response is in the =1xx (Informational)= or =5xx (Server Error)= class of status codes. An origin server *MUST* send a =Date= header field in all other cases.
#+END_QUOTE

如果源服务器不具有[[ruby:clock%20capable][记时功能]]来提供一个合理的接近当前 UTC 的时间，*禁止* 在其发送的响应里带有 =Date= 头字段。如果响应的状态码种类是 =1xx (Informational)= 或者 =5xx (Server Error)=，源服务器 *可以* 在响应里带有 =Date= 头字段。源服务器 *必须* 在所有其他情况下带有一个 =Date= 头字段。

#+BEGIN_QUOTE
A recipient with a clock that receives a response message without a =Date= header field *MUST* record the time it was received and append a corresponding =Date= header field to the message's header section if it is cached or forwarded downstream.
#+END_QUOTE

当带有记时功能的接收端接收到一个没有 =Date= 头字段的响应消息的时候，哪果响应被缓存或被转发到下游，服务器 *必须* 记录下它接收到响应的时间，并且附加一个对应的 =Date= 头字段到消息的头部。

#+BEGIN_QUOTE
A user agent *MAY* send a =Date= header field in a request, though generally will not do so unless it is believed to convey useful information to the server. For example, custom applications of HTTP might convey a =Date= if the server is expected to adjust its interpretation of the user's request based on differences between the user agent and server clocks.
#+END_QUOTE

用户代理 *可以* 在请求里带有一个 =Date= 头字段，虽然一般不会这么做，除非认为它传达了有用的信息给到服务器。例如，某些 HTTP 的客户应用程序可能会传达一个 =Date= 如果服务器期望用它基于用户代理与服务器时间上的不同来调整对用户请求的[[ruby:interpretation][解释]]。

*** 7.1.2. Location
:PROPERTIES:
:ID:       bc2baf29-0bf6-4816-865c-3d33f5fe38e3
:END:

#+BEGIN_QUOTE
The "Location" header field is used in some responses to refer to a specific resource in relation to the response. The type of relationship is defined by the combination of request method and status code semantics.
#+END_QUOTE

#+BEGIN_SRC text
  Location = URI-reference
#+END_SRC

#+BEGIN_QUOTE
The field value consists of a single URI-reference. When it has the form of a relative reference ([RFC3986], Section 4.2), the final value is computed by resolving it against the effective request URI ([RFC3986], Section 5).
#+END_QUOTE

#+BEGIN_QUOTE
For 201 (Created) responses, the =Location= value refers to the primary resource created by the request. For =3xx (Redirection)= responses, the Location value refers to the preferred target resource for automatically redirecting the request.
#+END_QUOTE

#+BEGIN_QUOTE
If the Location value provided in a =3xx (Redirection)= response does not have a fragment component, a user agent *MUST* process the redirection as if the value inherits the fragment component of the URI reference used to generate the request target (i.e., the redirection inherits the original reference's fragment, if any).
#+END_QUOTE

#+BEGIN_QUOTE
For example, a GET request generated for the URI reference "http://www.example.org/~tim" might result in a 303 (See Other) response containing the header field:
#+END_QUOTE

#+BEGIN_EXAMPLE
  Location: /People.html#tim
#+END_EXAMPLE

#+BEGIN_QUOTE
which suggests that the user agent redirect to "http://www.example.org/People.html#tim"
#+END_QUOTE

#+BEGIN_QUOTE
Likewise, a GET request generated for the URI reference "http://www.example.org/index.html#larry" might result in a 301 (Moved Permanently) response containing the header field:
#+END_QUOTE

#+BEGIN_EXAMPLE
  Location: http://www.example.net/index.html
#+END_EXAMPLE

#+BEGIN_QUOTE
which suggests that the user agent redirect to "http://www.example.net/index.html#larry", preserving the original fragment identifier.
#+END_QUOTE

#+BEGIN_QUOTE
There are circumstances in which a fragment identifier in a =Location= value would not be appropriate. For example, the Location header field in a 201 (Created) response is supposed to provide a URI that is specific to the created resource.
#+END_QUOTE

#+BEGIN_QUOTE
*Note:* Some recipients attempt to recover from Location fields that are not valid URI references. This specification does not mandate or define such processing, but does allow it for the sake of robustness.
#+END_QUOTE

#+BEGIN_QUOTE
*Note:* The =Content-Location= header field (Section 3.1.4.2) differs from Location in that the Content-Location refers to the most specific resource corresponding to the enclosed representation. It is therefore possible for a response to contain both the Location and Content-Location header fields.
#+END_QUOTE

*** 7.1.3. Retry-After
:PROPERTIES:
:ID:       f7b225e0-95f5-4d59-81c2-afbf6abb1656
:END:

#+BEGIN_QUOTE
Servers send the "Retry-After" header field to indicate how long the user agent ought to wait before making a follow-up request. When sent with a 503 (Service Unavailable) response, Retry-After indicates how long the service is expected to be unavailable to the client. When sent with any 3xx (Redirection) response, Retry-After indicates the minimum time that the user agent is asked to wait before issuing the redirected request.
#+END_QUOTE

#+BEGIN_QUOTE
The value of this field can be either an HTTP-date or a number of seconds to delay after the response is received.
#+END_QUOTE

#+BEGIN_SRC text
  Retry-After = HTTP-date / delay-seconds
#+END_SRC

#+BEGIN_QUOTE
A delay-seconds value is a non-negative decimal integer, representing time in seconds.
#+END_QUOTE

#+BEGIN_SRC text
  delay-seconds  = 1*DIGIT
#+END_SRC

#+BEGIN_QUOTE
Two examples of its use are
#+END_QUOTE

#+BEGIN_EXAMPLE
  Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
  Retry-After: 120
#+END_EXAMPLE

#+BEGIN_QUOTE
In the latter example, the delay is 2 minutes.
#+END_QUOTE

*** 7.1.4. Vary
:PROPERTIES:
:ID:       ca7f8781-b183-4563-a90a-b9b7ad4f1032
:END:

#+BEGIN_QUOTE
The "Vary" header field in a response describes what parts of a request message, aside from the method, Host header field, and request target, might influence the origin server's process for selecting and representing this response. The value consists of either a single asterisk ("*") or a list of header field names (case-insensitive).
#+END_QUOTE

#+BEGIN_SRC text
  Vary = "*" / 1#field-name
#+END_SRC

#+BEGIN_QUOTE
A Vary field value consisting of a comma-separated list of names indicates that the named request header fields, known as the selecting header fields, might have a role in selecting the representation. The potential selecting header fields are not limited to those defined by this specification.
#+END_QUOTE

#+BEGIN_QUOTE
For example, a response that contains
#+END_QUOTE

#+BEGIN_EXAMPLE
  Vary: accept-encoding, accept-language
#+END_EXAMPLE

#+BEGIN_QUOTE
indicates that the origin server might have used the request's Accept-Encoding and Accept-Language fields (or lack thereof) as determining factors while choosing the content for this response.
#+END_QUOTE

#+BEGIN_QUOTE
An origin server might send Vary with a list of fields for two purposes:

1. To inform cache recipients that they MUST NOT use this response to satisfy a later request unless the later request has the same values for the listed fields as the original request (Section 4.1 of [RFC7234]). In other words, Vary expands the cache key required to match a new request to the stored cache entry.
2. To inform user agent recipients that this response is subject to content negotiation (Section 5.3) and that a different representation might be sent in a subsequent request if additional parameters are provided in the listed header fields (proactive negotiation).
#+END_QUOTE

#+BEGIN_QUOTE
An origin server SHOULD send a Vary header field when its algorithm for selecting a representation varies based on aspects of the request message other than the method and request target, unless the variance cannot be crossed or the origin server has been deliberately configured to prevent cache transparency. For example, there is no need to send the Authorization field name in Vary because reuse across users is constrained by the field definition (Section 4.2 of [RFC7235]). Likewise, an origin server might use Cache-Control directives (Section 5.2 of [RFC7234]) to supplant Vary if it considers the variance less significant than the performance cost of Vary's impact on caching.
#+END_QUOTE

** 7.2. 验证器头字段 / Validator Header Fields
:PROPERTIES:
:ID:       efd98bfe-3f3c-4d75-9fa9-041a5af2f917
:END:

#+BEGIN_QUOTE
Validator header fields convey metadata about the selected representation (Section 3). In responses to safe requests, validator fields describe the selected representation chosen by the origin server while handling the response. Note that, depending on the status code semantics, the selected representation for a given response is not necessarily the same as the representation enclosed as response payload.
#+END_QUOTE

#+BEGIN_QUOTE
In a successful response to a state-changing request, validator fields describe the new representation that has replaced the prior selected representation as a result of processing the request.
#+END_QUOTE

#+BEGIN_QUOTE
For example, an ETag header field in a 201 (Created) response communicates the entity-tag of the newly created resource's representation, so that it can be used in later conditional requests to prevent the "lost update" problem [RFC7232].
#+END_QUOTE

| Header Field Name | Defined in...            |
|-------------------+--------------------------|
| ETag              | Section 2.3 of [RFC7232] |
| Last-Modified     | Section 2.2 of [RFC7232] |

** 7.3. 认证质询 / Authentication Challenges

#+BEGIN_QUOTE
Authentication challenges indicate what mechanisms are available for the client to provide authentication credentials in future requests.
#+END_QUOTE

| Header Field Name | Defined in...            |
|-------------------+--------------------------|
| WWW-Authenticate  | Section 4.1 of [RFC7235] |
| Proxy-Authenticate | Section 4.3 of [RFC7235] |

** 7.4. 响应上下文 / Response Context

#+BEGIN_QUOTE
The remaining response header fields provide more information about the target resource for potential use in later requests.
#+END_QUOTE

| Header Field Name | Defined in...            |
|-------------------+--------------------------|
| Accept-Ranges     | Section 2.3 of [RFC7233] |
| Allow             | Section 7.4.1            |
| Server            | Section 7.4.2            |

*** 7.4.1. Allow
:PROPERTIES:
:ID:       f8577773-512f-4d68-8f5d-444368db7c29
:END:

#+BEGIN_QUOTE
The "Allow" header field lists the set of methods advertised as supported by the target resource. The purpose of this field is strictly to inform the recipient of valid request methods associated with the resource.
#+END_QUOTE

#+BEGIN_SRC text
  Allow = #method
#+END_SRC

#+BEGIN_QUOTE
Example of use:
#+END_QUOTE

#+BEGIN_EXAMPLE
  Allow: GET, HEAD, PUT
#+END_EXAMPLE

#+BEGIN_QUOTE
The actual set of allowed methods is defined by the origin server at the time of each request. An origin server MUST generate an Allow field in a 405 (Method Not Allowed) response and MAY do so in any other response. An empty Allow field value indicates that the resource allows no methods, which might occur in a 405 response if the resource has been temporarily disabled by configuration.
#+END_QUOTE

#+BEGIN_QUOTE
A proxy *MUST NOT* modify the Allow header field — it does not need to understand all of the indicated methods in order to handle them according to the generic message handling rules.
#+END_QUOTE

*** 7.4.2. Server

#+BEGIN_QUOTE
The "Server" header field contains information about the software used by the origin server to handle the request, which is often used by clients to help identify the scope of reported interoperability problems, to work around or tailor requests to avoid particular server limitations, and for analytics regarding server or operating system use. An origin server MAY generate a Server field in its responses.
#+END_QUOTE

#+BEGIN_SRC text
  Server = product *( RWS ( product / comment ) )
#+END_SRC

#+BEGIN_QUOTE
The Server field-value consists of one or more product identifiers, each followed by zero or more comments (Section 3.2 of [RFC7230]), which together identify the origin server software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the origin server software. Each product identifier consists of a name and optional version, as defined in Section 5.5.3.
#+END_QUOTE

#+BEGIN_QUOTE
Example:
#+END_QUOTE

#+BEGIN_EXAMPLE
  Server: CERN/3.0 libwww/2.17
#+END_EXAMPLE

#+BEGIN_QUOTE
An origin server *SHOULD NOT* generate a Server field containing needlessly fine-grained detail and *SHOULD* limit the addition of subproducts by third parties. Overly long and detailed Server field values increase response latency and potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.
#+END_QUOTE

* 8. IANA 注意事项 / IANA Considerations
** 8.1. 方法注册表 / Method Registry
:PROPERTIES:
:ID:       193d7ad5-9c6d-4bf7-98f1-6984a42af639
:END:
*** 8.1.1. Procedure
*** 8.1.2. Considerations for New Methods
*** 8.1.3. Registrations
** 8.2. 状态码注册表 / Status Code Registry
:PROPERTIES:
:ID:       c0f1fbbc-3471-430e-90be-1b120d9b449f
:END:
*** 8.2.1. Procedure
*** 8.2.2. Considerations for New Status Codes
*** 8.2.3. Registrations
** 8.3. 头字段注册表 / Header Field Registry
*** 8.3.1. Considerations for New Header Fields
*** 8.3.2. Registrations
** 8.4. 内容编码值注册表 / Content Coding Registry
:PROPERTIES:
:ID:       87f2ed30-a48b-4c31-a181-8e3a33ba1080
:END:
*** 8.4.1. Procedure
*** 8.4.2. Registrations
* 9. 安全注意事项 / Security Considerations
** 9.1. 基于文件和路径名称的攻击 / Attacks Based on File and Path Names
:PROPERTIES:
:ID:       9195be98-bd4e-40ae-a5a0-6af920044f02
:END:
** 9.2. 基于命令、代码、查询注入 / Attacks Based on Command, Code, or Query Injection
** 9.3. 个人信息的披露 / Disclosure of Personal Information
** 9.4. URLs 敏感信息的披露 / Disclosure of Sensitive Information in URLs
:PROPERTIES:
:ID:       ed824807-db16-4f5b-ab13-2366f5cfc0f3
:END:
** 9.5. Disclosure of Fragment after Redirects
** 9.6. Disclosure of Product Information
** 9.7. 浏览器指纹识别 / Browser Fingerprinting
:PROPERTIES:
:ID:       58ca9032-65b1-47ff-b759-d1cedc245d4b
:END:
* 10. 鸣谢 / Acknowledgements
* 11. 参考资料 / References
** 11.1. Normative References
** 11.2. Informative References
* A. HTTP 与 MIME 的区别 / Defferences between HTTP and MIME
:PROPERTIES:
:ID:       84208afd-e458-4f40-97cc-2e9535523797
:END:
** A.1. MIME-VERSION
** A.2. Conversion to Canonical Form
** A.3. Conversion of Date Formats
** A.4. Conversion of Content-Encoding
** A.5. Conversion of Content-Transfer-Encoding
** A.6. MHTML and Line Length Limitations
* B. 相对 RFC 2616 的变化 / Changes from RFC 2616
:PROPERTIES:
:ID:       b9da2375-731c-4b8a-a7d5-b07352c045a9
:END:
* C. 引入的 ABNF 规则 / Imported ABNF
* D. ABNF 规则集合 Collected ABNF
* Index
* Author' Addresses

* Footnotes

[fn:2] Content Object Tree
#+BEGIN_QUOTE
a *Content Object* is a single piece of managed content. Often referred to as simply "content".

The suffx of "object" is often used specifically to differentiate an object from its defining content type. For example: The "2016 Annual Report" content object is based on the "Managed Document" content type.

a *Content Tree* is the aggregation of content in a hierarchical tree.

Each content object in the tree has a parent (except, of course, for the object at the base of the tree -- the "root" object), zero or more siblings, and zero or more children. The tree can be used to represent relationships between content objects

-- O'REILLY "[[http://flyingsquirrelbook.com/glossary/term/content-object][Web Content Management, SYSTEMS, FEATURES, AND BEST PRACTICES]]" Deane Barker
#+END_QUOTE

[fn:1] Backlink，反向连接，参考 [[https://en.wikipedia.org/wiki/Backlink][Wikipedia: Backlink]]。
