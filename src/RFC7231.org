#+FILETAGS: :note:rfc:
#+TITLE: RFC7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
#+SELECT_TAGS: export
#+OPTIONS: toc:5 ^:{} H:6 num:0
#+UNNUMBERED: t
#+bind: org-export-publishing-directory "./docs"

#+BEGIN_EXPORT html
<a class="github-repo" href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <svg height="18" width="18" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
  <span>View Repo</span>
</a>
#+END_EXPORT

#+BEGIN_EXPORT html
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img alt="" src="https://img.shields.io/github/license/duoani/HTTP-RFCs.zh-cn.svg?style=social"/>
</a>
<a href="https://github.com/duoani/HTTP-RFCs.zh-cn">
  <img src="https://img.shields.io/github/stars/duoani/HTTP-RFCs.zh-cn.svg?style=social&label=Stars"/>
</a>
#+END_EXPORT

#+BEGIN_SRC text
                                                         PROPOSED STANDARD
                                                              Errata Exist
  Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
  Request for Comments: 7231                                         Adobe
  Obsoletes: 2616                                          J. Reschke, Ed.
  Updates: 2817                                                 greenbytes
  Category: Standards Track                                      June 2014
  ISSN: 2070-1721
#+END_SRC

* 摘要 / Abstract
#+BEGIN_QUOTE
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.
#+END_QUOTE

超文本传输协议（HTTP）是一种[[ruby:stateless][无状态]]的应用层协议，适用于分布式、协作式的超文本信息系统。本文档定义了 HTTP/1.1 报文的语义，引申为[[ruby:request%20methods][请求方法]]、[[ruby:request%20header%20fields][请求报头域]]、[[ruby:response%20status%20codes][响应状态码]]、[[ruby:response%20header%20fields][响应报头域]]，连同报文的[[ruby:payload][有效载荷]]（元数据以及报文正文内容）以及[[ruby:content%20negotiation][内容协商]]的机制。

* 备忘录状态 / Status of This Memo
This is an Internet Standards Track document.

This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.

Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7231.

* 版权声明 / Copyright Notice
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.

This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.

* 1. 引言 / Introduction
#+BEGIN_QUOTE
Each Hypertext Transfer Protocol (HTTP) message is either a request or a response. A server listens on a connection for a request, parses each message received, interprets the message semantics in relation to the identified request target, and responds to that request with one or more response messages. A client constructs request messages to communicate specific intentions, examines received responses to see if the intentions were carried out, and determines how to interpret the results. This document defines HTTP/1.1 request and response semantics in terms of the architecture defined in [RFC7230].
#+END_QUOTE

每一个超文本传输协议（HTTP）报文不是一个请求就是一个响应。服务器监听某个连接的请求，[[ruby:parse][解析]]其接收到的每个报文，[[ruby:interpret][解释]]报文内关于请求目标的语义，最后使用一个或多个响应报文来回应该请求。客户端构建请求报文来传达特定的意图，检查接收到的响应来观察其意图是否得到贯彻执行，并确定如何去[[ruby:interpret][解释]]该结果。本文档依据[[file:RFC7230.org][【RFC7230】]]所定义的架构，定义了 HTTP/1.1 请求和响应的语义。

#+BEGIN_QUOTE
HTTP provides a uniform interface for interacting with a resource ([[id:304453f4-a250-4f73-b82c-2825a0bda464][Section 2]]), regardless of its type, nature, or implementation, via the manipulation and transfer of representations ([[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][Section 3]]).
#+END_QUOTE

HTTP 提供了一种统一的接口来对[[ruby:resource][资源]]（[[id:304453f4-a250-4f73-b82c-2825a0bda464][章节 2]]）进行交互，而不必理会资源的类型、性质或者[[ruby:implementation][实现]]，具体是经由对[[ruby:representations][资源的表示]]（[[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][章节 3]]）进行操作和传输来实现的。

#+BEGIN_QUOTE
HTTP semantics include the intentions defined by each request method ([[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][Section 4]]), extensions to those semantics that might be described in request header fields ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]), the meaning of status codes to indicate a machine-readable response ([[id:5a69d0cc-628c-4897-a089-45f906b94a92][Section 6]]), and the meaning of other control data and resource metadata that might be given in response header fields ([[id:30e7b781-4a14-4519-abb9-63ec43516b98][Section 7]]).
#+END_QUOTE

HTTP 的语义包含了每个[[ruby:request%20method][请求方法]]所定义的意图（[[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][章节 4]]）、[[ruby:request%20header%20fields][请求报头域]]对这些语义的扩展（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）、[[ruby:status%20codes][状态码]]的含义（用于指定一种机器可阅读的响应，[[id:5a69d0cc-628c-4897-a089-45f906b94a92][章节 6]]）、以及出现在[[ruby:response%20header%20fields][响应报头域]]里的其他控制数据和资源元数据的含义（[[id:30e7b781-4a14-4519-abb9-63ec43516b98][章节 7]]）。

#+BEGIN_QUOTE
This document also defines representation metadata that describe how a payload is intended to be interpreted by a recipient, the request header fields that might influence content selection, and the various selection algorithms that are collectively referred to as "content negotiation" ([[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][Section 3.4]]).
#+END_QUOTE

本文档还定义了以下内容：描述打算让接收端怎样[[ruby:interpret][解释]]一个[[ruby:payload][有效载荷]]的[[ruby:representation%20metadata][资源的表示元数据]]、可能影响[[ruby:content%20selection][内容选择]]的请求报头域、统称为“[[ruby:content%20negotiation][内容协商]]”的各种选择算法（[[id:c45cb9ca-1e51-4738-8c43-231e7316ea86][章节 3.4]]）。

** 1.1. 一致性和错误处理 / Conformance and Error Handling
#+BEGIN_QUOTE
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[[https://tools.ietf.org/html/rfc2119][RFC2119]]].
#+END_QUOTE

关键词 *[[ruby:MUST][必须]]*、*[[ruby:MUST%20NOT][禁止]]*、*[[ruby:REQUIRED][要求]]*、*[[ruby:SHALL][必须]]*、*[[ruby:SHALL%20NOT][禁止]]*、*[[ruby:SHOULD][应该]]*、*[[ruby:SHOULD%20NOT][不应当]]*、*[[ruby:RECOMMENDED][推荐]]*、*[[ruby:MAY][可以]]* 和 *[[ruby:OPTIONAL][可选]]* 的意义与【[[https://tools.ietf.org/html/rfc2119][RFC2119]]】一致。

#+BEGIN_QUOTE
Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].
#+END_QUOTE

关于错误处理的一致性标准以及注意事项已在[[id:A0441F72-9799-4667-9477-1E05885946A1][【RFC7230】章节 2.5]] 中定义了。

** 1.2. 句法标记 / Syntax Notation
#+BEGIN_QUOTE
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [[[https://tools.ietf.org/html/rfc5234][RFC5234]]] with a list extension, defined in [[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][Section 7]] of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix C describes rules imported from other documents. Appendix D shows the collected grammar with all list operators expanded to standard ABNF notation.
#+END_QUOTE

本规范使用了扩展巴科斯范式（ABNF）标记法【[[https://tools.ietf.org/html/rfc5234][RFC5234]]】，另外，出于定义的紧凑性的考虑，本规范对 ABNF 规则进行了扩展（见[[id:b9db011d-fe47-4781-929a-4b1b0aa55aec][【RFC7230】章节 7]]），允许使用一个 =#= 操作符（类似于 =*= 操作符，指代“重复”）来定义一种以逗号分隔的列表。

#+BEGIN_QUOTE
This specification uses the terms "character", "character encoding scheme", "charset", and "protocol element" as they are defined in [[[https://tools.ietf.org/html/rfc6365][RFC6365]]].
#+END_QUOTE

本规范使用了术语“[[ruby:character][字符]]”、“[[ruby:character%20encoding%20scheme][字符编码方案]]”、“[[ruby:charset][字符集]]”、“[[ruby:protocol%20element][协议元素]]”，其定义见[[https://tools.ietf.org/html/rfc6365][【RFC6365】]]。

* 2. 资源 / Resources
:PROPERTIES:
:ID:       304453f4-a250-4f73-b82c-2825a0bda464
:END:
The target of an HTTP request is called a "resource". HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources. Each resource is identified by a Uniform Resource Identifier (URI), as described in [[id:9c45ae18-46b0-4acb-a478-3d3e9a3748ab][Section 2.7]] of [RFC7230].

HTTP 请求的目标，被称为“[[ruby:resource][资源]]”。HTTP 并不限制一个资源的性质，它仅仅定义了一个可以用来对资源进行交互的接口。每一个资源都被一个[[ruby:Uniform%20Resource%20Identifier][统一资源标识符（URI）]]所标识，见[[id:9c45ae18-46b0-4acb-a478-3d3e9a3748ab][【RFC7230】章节 2.7]]。

When a client constructs an HTTP/1.1 request message, it sends the target URI in one of various forms, as defined in ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]). When a request is received, the server reconstructs an effective request URI for the target resource ([[id:3265c21d-0d3b-4776-8e28-38278d168779][Section 5.5]] of [RFC7230]).

当客户端[[ruby:construct][构建]]一个 HTTP/1.1 请求报文的时候，它将某种形式的[[ruby:target%20URI][目标 URI]] 包含在报文中，见[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]。当服务器接收到一个请求的时候，它将[[ruby:reconstruct][重新构建]]出一个[[ruby:effective%20request%20URI][有效请求 URI]]（见[[id:3265c21d-0d3b-4776-8e28-38278d168779][【RFC7230】章节 5.5]]）来定位[[ruby:target%20resource][目标资源]]。

#+BEGIN_QUOTE
译注：目标 URI 有四种形式：[[ruby:origin-form][原始形式]]、[[ruby:absolute-form][绝对形式]]、[[ruby:authority-form][权威形式]]、[[ruby:asterisk-form][星号形式]]，详情见[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]。
#+END_QUOTE

One design goal of HTTP is to separate resource identification from request semantics, which is made possible by vesting the request semantics in the request method ([[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][Section 4]]) and a few request-modifying header fields ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]). If there is a conflict between the method semantics and any semantic implied by the URI itself, as described in Section 4.2.1, the method semantics take precedence.

HTTP 的设计目标之一是将[[ruby:resource%20identification][资源识别]]与请求语义相分离，使得请求语义全部归属于[[ruby:request%20method][请求方法]]（[[id:e6ec0aa0-3e4d-4367-bffd-423e028210b0][章节 4]]）以及几个[[ruby:request-modifying%20header%20fields][请求修饰报头域]]（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）。如果方法语义与 URI 自身所暗含的语义相冲突，正如[[id:2f967e3d-8694-430b-ad06-e748fd39b281][章节 4.2.1]] 所述，优先使用方法语义。

* 3. 资源的表示 / Representations
:PROPERTIES:
:ID:       7dd837af-fd6a-4918-9c62-cf12a4c31522
:END:
#+BEGIN_QUOTE
Considering that a resource could be anything, and that the uniform interface provided by HTTP is similar to a window through which one can observe and act upon such a thing only through the communication of messages to some independent actor on the other side, an abstraction is needed to represent ("take the place of") the current or desired state of that thing in our communications. That abstraction is called a representation [REST].
#+END_QUOTE

考虑到[[ruby:resource][资源]]可以是任何事物，而 HTTP 所提供的统一接口类似于一个窗口，在窗口的一边我们能够对该事物进行观察；而要想对该事物采取行动的话，只能通过消息沟通来让窗口另一边的某个独立的动作执行者来完成。因此，在沟通过程中，我们需要一种“抽象”来[[ruby:represent][表示]]（代替）该事物的[[ruby:current%20state][当前状态]]或[[ruby:desired%20state][期望状态]]。而这种“抽象”被称为 [[ruby:representation][资源的表示]]【[[http://roy.gbiv.com/pubs/dissertation/top.htm][REST]]】。

#+BEGIN_QUOTE
译注：术语 "representation" 一词源自一种软件架构风格的术语—— REST（Representational Style Transfer），也就是我们常常听到的 RESTful 风格。[[ruby:representation][资源的表示]]是[[ruby:resource][资源]]的抽象，资源一般是唯一的，而资源的表示方式可以多种多样，例如，一份银行流水账单可以认为是一种资源，按媒体类型来分，它的表示形式可以有 JSON、XML 或者二进制格式等，按时间来分，它的表示形式可以有昨日收支、今日收支、本用收支等，更详细的介绍可以[[http://roy.gbiv.com/pubs/dissertation/rest_arch_style.htm][查看这里]]。
#+END_QUOTE

#+BEGIN_QUOTE
For the purposes of HTTP, a "representation" is information that is intended to reflect a past, current, or desired state of a given resource, in a format that can be readily communicated via the protocol, and that consists of a set of representation metadata and a potentially unbounded stream of representation data.
#+END_QUOTE

基于 HTTP 的目的，[[ruby:representation][资源的表示]]是一种信息，该信息用于反映某个给定资源的过去、现在、或将来期望的状态。它以一种能够轻易地经由协议进行传达的格式，并由一系列 [[ruby:representation%20metadata][元数据]]以及一个可能是无限大的 [[ruby:representation%20data][数据]]（流）组成。

#+BEGIN_QUOTE
译注：再强调一次，"representation" 是资源的一种抽象，反映的是资源的状态，资源一般有多种状态。引用上面提到的银行流水账单的例子，JSON 形式的表示是它的一种状态，它也可以转变为 XML 形式（状态过渡）。每一种状态由一种 representation 来表示，因此，资源与 representation 是一对多的关系。

下文会多次提及到 "current representation"，它反映了资源的[[ruby:current%20state][目前状态]]，怎么理解呢？还是拿账单的例子，假设有两个接口，一个接口 A 用来获取今天的总支出，另一个接口 B 用来提交支出。

- 第一次调用接口 A，返回总支出为 50 元，50 元反映了该接口所对应的资源的当前状态；
- 调用接口 B 提交一条支出 5 元的数据，这时数据库新增了一条记录，资源的状态发生改变；
- 每二次调用接口 A，返回总支出为 55 元，55 元反映了该接口所对应的资源的当前状态；

另外，"current representation" 也可以同时有多个，例如接口 A 默认返回的是文本类型，但它还有一个参数 =filetype= 可以让接口调用者指定返回的数据类型，例如 JSON，那么，文本类型和 JSON 类型的总支出信息皆为接口 B 所对应的资源的 "current representation"。 
#+END_QUOTE

#+BEGIN_QUOTE
译注："representation" 由 "representation data" 和 "representation metadata" 组成。"representation data"，即资源本身；而 "representation metadata"，是用来描述 "representation" 的，所以叫作“元数据”。为了表述的准确，以后将不再对 "representation"、"representation data" 以及 "representation metadata" 进行翻译。
#+END_QUOTE

#+BEGIN_QUOTE
An origin server might be provided with, or be capable of generating, multiple representations that are each intended to reflect the current state of a target resource. In such cases, some algorithm is used by the origin server to select one of those representations as most applicable to a given request, usually based on content negotiation. This "selected representation" is used to provide the data and metadata for evaluating conditional requests [RFC7232] and constructing the payload for 200 (OK) and 304 (Not Modified) responses to GET ([[id:698bab73-07b1-4349-8a03-5a4a89d966d8][Section 4.3.1]]).
#+END_QUOTE

[[ruby:origin%20server][源服务器]]可能提供或能够生成多种 representations，每种 representation 旨在反映[[ruby:target%20resource][目标资源]]的当前状态。在这种情况下，源服务器会使用某些算法（通常会基于[[ruby:content%20negotiation][内容协商]]）来选择其中一种对于给定请求来说最适合的 representation。这个“[[ruby:selected%20representation][已选定的 representation]]”是用来为[[ruby:evaluating%20conditional%20requests][评估带条件的请求]]提供数据和元数据，以及为响应给 GET 请求（[[id:698bab73-07b1-4349-8a03-5a4a89d966d8][章节 4.3.1]]）的 =200 (OK)= 和 =304 (Not Modified)= 响应报文构建[[ruby:payload][有效载荷]]。

** 3.1. 表示元数据 / Representation Metadata
#+BEGIN_QUOTE
Representation header fields provide metadata about the representation. When a message includes a payload body, the representation header fields describe how to interpret the representation data enclosed in the payload body. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the payload body if the same request had been a GET.
#+END_QUOTE

与 representation 相关的报头域提供了 representation 的元数据。当一个[[ruby:message][报文]]包含一个[[ruby:payload%20body][有效载荷]]时，与 representation 相关的报头域描述了如何解释这个封装在有效载荷内的 representation data。在一个回应给 HEAD 请求的响应报文里，与 representation 相关的报头域描述了如果相同的请求是一个 GET 请求的话，将会如何解释这个封装在有效载荷内的 representation data。

#+BEGIN_QUOTE
The following header fields convey representation metadata:
#+END_QUOTE

以下报头域负责传达 representation metadata：

| header Field Name | Defined in...   |
|-------------------+-----------------|
| Content-Type      | [[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][Section 3.1.1.5]] |
| Content-Encoding  | [[id:a10adb00-e955-42a6-8d28-ed6f942db085][Section 3.1.2.2]] |
| Content-Language  | [[id:80f3e8e8-dabb-49b8-b7e6-45f83648a732][Section 3.1.3.2]] |
| Content-Location  | [[id:91650144-4bfc-4362-b628-f96578a5c756][Section 3.1.4.2]] |

*** 3.1.1. 处理表示数据 / Processing Representation Data
**** 3.1.1.1. 媒体类型 / Media Type
:PROPERTIES:
:ID:       bc05d462-378f-4743-a1ee-543e01064a09
:END:
#+BEGIN_QUOTE
HTTP uses Internet media types [[[https://tools.ietf.org/html/rfc2046][RFC2046]]] in the =Content-Type= ([[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][Section 3.1.1.5]]) and =Accept= ([[id:95575604-c3d4-48d6-a061-325bd7798970][Section 5.3.2]]) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with each context in which it is received.
#+END_QUOTE

为了提供开放、可扩展的[[ruby:data%20typing][数据分类]]和[[ruby:type%20negotiation][类型协商]]，HTTP 在 =Content-Type= （[[id:fcfdf1e4-f733-4305-9ad4-761271a3dd69][章节 3.1.1.5]]）和 =Accept= （[[id:95575604-c3d4-48d6-a061-325bd7798970][章节 5.3.2]]）报头域中使用[[ruby:Internet%20media%20types][互联网媒体类型]][[https://tools.ietf.org/html/rfc2046][【RFC2046】]]。媒体类型定义了数据的格式及其各种处理模型，即如何根据接收数据的各个场景来处理该数据。

#+BEGIN_SRC text
  media-type = type "/" subtype *( OWS ";" OWS parameter )
  type       = token
  subtype    = token
#+END_SRC

#+BEGIN_QUOTE
The =type/subtype= *MAY* be followed by parameters in the form of =name=value= pairs.
#+END_QUOTE

=type/subtype= 后面 *可以* 跟着键值对 =name=value= 形式的多个参数。

#+BEGIN_SRC text
  parameter      = token "=" ( token / quoted-string )
#+END_SRC

#+BEGIN_QUOTE
The =type=, =subtype=, and =parameter name= tokens are case-insensitive. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name. The presence or absence of a parameter might be significant to the processing of a media-type, depending on its definition within the media type registry.
#+END_QUOTE

上面 ABNF 列出的规则里，=type=、=subtype= 以及 =parameter= 的 =name= 这三个 token（标记）是不区分大小写的。=parameter= 的 =value= 不一定区分大小写，取决于 =parameter= 的 =name= 的语义。一个 =parameter= 的出现与否可能会对一个媒体类型的处理有重要意义，取决于该 =parameter= 在[[ruby:media%20type%20registry][媒体类型注册表]]里的定义。

#+BEGIN_QUOTE
A parameter value that matches the token production can be transmitted either as a token or within a quoted-string. The quoted and unquoted values are equivalent. For example, the following examples are all equivalent, but the first is preferred for consistency:
#+END_QUOTE

如果 =parameter= 的 =value= 符合 [[id:d0012483-93a3-44cf-b019-29e12725d94a][token]] 的语法规则的话，那么，它既可以直接作为标记来传输，也可以用在[[ruby:quoted-string][双引号字符串]]里。使用双引号包裹与否都是等价的。例如，以下例子都是等价的，但是为了一致性，应优先使用第一种：

#+BEGIN_QUOTE
译注：token，标记、记号，编程语言中的变量名、常量名就是 token，token 在 ABNF 中有明确的定义，它的命名不能出现某些特殊字符，详情见[[id:d0012483-93a3-44cf-b019-29e12725d94a][【RFC7230】章节 3.2.6]]。
#+END_QUOTE

#+BEGIN_EXAMPLE
  text/html;charset=utf-8
  text/html;charset=UTF-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
#+END_EXAMPLE

#+BEGIN_QUOTE
Internet media types ought to be registered with IANA according to the procedures defined in [[[https://tools.ietf.org/html/rfc6838][BCP13]]].
#+END_QUOTE

应该按照[[https://tools.ietf.org/html/rfc6838][【BCP13】]]所定义的流程，将[[ruby:Internet%20media%20types][互联网媒体类型]]注册在 IANA 里。

#+BEGIN_QUOTE
*Note:* Unlike some similar constructs in other header fields, media type parameters do not allow whitespace (even "bad" whitespace) around the "=" character.
#+END_QUOTE

*注意：* 不像其他报头域里的某些类似结构，媒体类型的参数不允许在等号（"="）两边带有空格（即使是 [[id:f26527b6-d15c-4967-97e3-acc669609481][BWS]] 也不允许）。

**** 3.1.1.2. 字符集 / Charset
#+BEGIN_QUOTE
HTTP uses charset names to indicate or negotiate the character encoding scheme of a textual representation [[[https://tools.ietf.org/html/rfc2978][RFC6365]]]. A charset is identified by a case-insensitive token.
#+END_QUOTE

HTTP 使用[[ruby:charset%20names][字符集名称]]来指定或协商一个文本类型的 representation 的[[ruby:character%20encoding%20scheme][字符编码方案]]【[[https://tools.ietf.org/html/rfc6365][RFC6365]]】。字符集由一个不区分大小写的 token 来指定。

#+BEGIN_SRC text
  charset = token
#+END_SRC

#+BEGIN_QUOTE
Charset names ought to be registered in the IANA "Character Sets" registry (<http://www.iana.org/assignments/character-sets>) according to the procedures defined in [RFC2978].
#+END_QUOTE

应该按照定义在[[https://tools.ietf.org/html/rfc2978][【RFC2978】]]的流程，将[[ruby:charset%20names][字符集名称]]注册在 IANA 的 "Character Sets" 注册表里。

**** 3.1.1.3. 规范化和文本缺省 / Canonicalization and Text Defaults
#+BEGIN_QUOTE
Internet media types are registered with a canonical form in order to be interoperable among systems with varying native encoding formats. Representations selected or transferred via HTTP ought to be in canonical form, for many of the same reasons described by the Multipurpose Internet Mail Extensions (MIME) [[[https://tools.ietf.org/html/rfc2045][RFC2045]]]. However, the performance characteristics of email deployments (i.e., store and forward messages to peers) are significantly different from those common to HTTP and the Web (server-based information services). Furthermore, MIME's constraints for the sake of compatibility with older mail transfer protocols do not apply to HTTP (see [[id:84208afd-e458-4f40-97cc-2e9535523797][Appendix A]]).
#+END_QUOTE

[[ruby:Internet%20media%20types][互联网媒体类型]]是使用一种[[ruby:canonical%20form][规范形式]]来注册的，以便于在具有不同本地编码格式的系统之间能够相互操作。经由 HTTP 来选择或传输的 representations 应该使用规范形式，其原因已经在[[ruby:Multipurpose%20Internet%20Mail%20Extensions][多用途互联网邮件扩展]]（MIME）【[[https://tools.ietf.org/html/rfc2045][RFC2045]]】里描述过了。然而，电子邮件调度（即存储和转发报文到其他对方）的性能特征跟在 HTTP 和 Web（其于服务器的信息服务）中通用的性能特征有明显的区别。此外，在 MIME 里为了兼容旧的邮件传输协议所设计的约束并不适用于 HTTP（见[[id:84208afd-e458-4f40-97cc-2e9535523797][附录 A]]）。

#+BEGIN_QUOTE
译注：canonical form (or normal form, or standard form) 的解释见 [[https://en.wikipedia.org/wiki/Canonical_form][wikipedia: Canonical form]]。
#+END_QUOTE

#+BEGIN_QUOTE
MIME's canonical form requires that media subtypes of the "text" type use =CRLF= as the text line break. HTTP allows the transfer of text media with plain =CR= or =LF= alone representing a line break, when such line breaks are consistent for an entire representation. An HTTP sender *MAY* generate, and a recipient *MUST* be able to parse, line breaks in text media that consist of =CRLF=, bare =CR=, or bare =LF=. In addition, text media in HTTP is not limited to charsets that use octets 13 and 10 for =CR= and =LF=, respectively. This flexibility regarding line breaks applies only to text within a representation that has been assigned a "text" media type; it does not apply to "multipart" types or HTTP elements outside the payload body (e.g., header fields).
#+END_QUOTE

MIME 的规范形式要求文本（"text"）类型媒体的子类型使用 =CRLF= 来作为换行符。HTTP 允许文本类型媒体单独使用 =CR= 或者 =LF= 来表示一个换行符，只要求所使用的换行符在整个 representation 中是统一的。HTTP 发送端 *可以* 在文本类型媒体中生成由 =CRLF=、或者单纯是 =CR=、或者单纯是为 =LF= 组成的换行符。HTTP 接收端 *必须* 能够解析文本类型媒体中的由 =CRLF=、或者单纯是 =CR=、或者单纯是 =LF= 组成的换行符。而且，在 HTTP 里的文本类型媒体并不限于使用 13 作为 =CR=，10 作为 =LF= 的字符集。这种对于换行符的灵活性仅适用于一个声明为 "text" 媒体类型的 representation 以内的文本，它并不适用于 "multipart" 类型，也不适用于有效载荷以外的 HTTP 元素（例如，报头域）。

#+BEGIN_QUOTE
If a representation is encoded with a content-coding, the underlying data ought to be in a form defined above prior to being encoded.
#+END_QUOTE

如果一个 representation 使用了一种[[ruby:content-coding][内容编码值]]来编码，[[ruby:underlying%20data][基础数据]]应该在编码之前处于上述定义的那种规范形式。

#+BEGIN_QUOTE
译注："underlying data" 译为基础数据，指的是在编码之前的原始数据。
#+END_QUOTE

**** 3.1.1.4. Multipart 类型 / Multipart Types
MIME provides for a number of "multipart" types — encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in [[https://tools.ietf.org/html/rfc2046#section-5.1.1][Section 5.1.1]] of [RFC2046], and include a =boundary= parameter as part of the media type value. The message body is itself a protocol element; a sender *MUST* generate only =CRLF= to represent line breaks between body parts.

MIME 提供了大量的 "multipart" 类型，即在单独一个[[ruby:message%20body][报文正文]]里封装了一个或多个 representations。所有 multipart 类型共享一个通用的句法（见[[https://tools.ietf.org/html/rfc2046#section-5.1.1][【RFC2046】章节 5.1.1]]），并且包含一个 =boundary= 参数作为媒体类型的值的一部分。报文正文本身就是一个协议元素，发送端 *必须* 在报文正文的各个[[ruby:parts][分部]]之间仅生成 =CRLF= 来表示换行符。

#+BEGIN_QUOTE
译注：multipart 允许在一个报文正文里包含多个 representation，每个 representation 之间使用 =boundary= 所指定的定界符来分隔，这样就使得报文正文被分割为多个分部，分部与分部之间的内容仍然只能使用 =CRLF= 作为换行符。multipart 的一个例子可以参考[[https://tools.ietf.org/html/rfc2049#page-15][【RFC2049】附录 A]]。
#+END_QUOTE

HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the payload. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in [[[https://tools.ietf.org/html/rfc2388][RFC2388]]], and the "multipart/byteranges" type is defined by this specification for use in some =206 (Partial Content)= responses [[[https://tools.ietf.org/html/rfc7233][RFC7233]]].

HTTP [[ruby:message%20framing][报文分帧]] 并不会使用 multipart 的 =boundary= 作为报文正文长度的一个标识符，虽然它可能被[[ruby:implementations][实现]]用于生成或处理有效载荷。例如，"multipart/form-data" 类型通常用于在一个请求里携带表单数据，如【[[https://tools.ietf.org/html/rfc2388][RFC2388]]】所述。"multipart/byteranges" 类型是由本规范所定义的，用在某些 =206 (Partial Content)= 响应里【[[https://tools.ietf.org/html/rfc7233][RFC7233]]】。

**** 3.1.1.5. Content-Type
:PROPERTIES:
:ID:       fcfdf1e4-f733-4305-9ad4-761271a3dd69
:END:
#+BEGIN_QUOTE
The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by =Content-Encoding= are decoded.
#+END_QUOTE

=Content-Type= 报头域指明了它所关联的 representation 的媒体类型。所述“关联的 representation”，要不是封装在报文有效载荷内的 representation，要不是已选定的 representation，由报文语义所决定。 =Content-Type= 所指定的媒体类型定义了 representation 的数据格式以及期望该数据被接收端如何处理，在该报文的语义范围之内，在依照 =Content-Encoding= 里的所有内容编码进行解码之后。

#+BEGIN_SRC text
  Content-Type = media-type
#+END_SRC

#+BEGIN_QUOTE
Media types are defined in [[id:bc05d462-378f-4743-a1ee-543e01064a09][Section 3.1.1.1]]. An example of the field is
#+END_QUOTE

媒体类型定义在[[id:bc05d462-378f-4743-a1ee-543e01064a09][章节 3.1.1.1]]。以下是 =Content-Type= 报头域的一个例子：

#+BEGIN_SRC text
  Content-Type: text/html; charset=ISO-8859-4
#+END_SRC

#+BEGIN_QUOTE
A sender that generates a message containing a payload body *SHOULD* generate a =Content-Type= header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a =Content-Type= header field is not present, the recipient *MAY* either assume a media type of "application/octet-stream" ([RFC2046], [[https://tools.ietf.org/html/rfc2046#section-4.5.1][Section 4.5.1]]) or examine the data to determine its type.
#+END_QUOTE

如果发送端所生成的报文包含有一个有效载荷，那么发送端 *应当* 在该报文里生成一个 =Content-Type= 报头域，除非它并不知道应该对封装在有效载荷内的 representation 的指定哪一种媒体类型。如果没有出现 =Content-Type= 报头域，接收端 *可以* 要不假定为 "application/octet-stream" 媒体类型（[[https://tools.ietf.org/html/rfc2046#section-4.5.1][【RFC2046】章节 4.5.1]]），要不检查该数据来确定它的媒体类型。

#+BEGIN_QUOTE
In practice, resource owners do not always properly configure their origin server to provide the correct =Content-Type= for a given representation, with the result that some clients will examine a payload's content and override the specified type. Clients that do so risk drawing incorrect conclusions, which might expose additional security risks (e.g., "privilege escalation"). Furthermore, it is impossible to determine the sender's intent by examining the data format: many data formats match multiple media types that differ only in processing semantics. Implementers are encouraged to provide a means of disabling such "content sniffing" when it is used.
#+END_QUOTE

实际上，[[ruby:resource%20owners][资源所有者]]并不总是能恰当地配置它们的源服务器来为一个给定的 representation 提供正确的 =Content-Type=，出于这种原因，某些客户端会检查有效载荷的内容然后[[ruby:override][重写]]指定的类型。但是，客户端这样做可能会得出错误的论断，从而可能会暴露出额外的安全风险（例如，[[ruby:privilege%20escalation][特权提升]]）。而且，通过检查数据格式是不可能确定发送端的真正意图的，这是由于某些数据格式能够匹配多种媒体类型，而仅在语义处理会有所不同。鼓励实现者提供一种方法，当启用这种方法的时候可以禁用上述这种“[[ruby:content%20sniffing][内容嗅探]]”。

#+BEGIN_QUOTE
译注：特权提升的详细介绍见 [[https://en.wikipedia.org/wiki/Privilege_escalation][Wikipedia: Privilege escalation]] 或者 [[https://zh.wikipedia.org/wiki/%25E7%2589%25B9%25E6%259D%2583%25E6%258F%2590%25E5%258D%2587][维基百科（中文）]]。
#+END_QUOTE

*** 3.1.2. 为压缩或完整性而编码 / Encoding for Compression or Integrity
**** 3.1.2.1. Content Codings
#+BEGIN_QUOTE
Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.
#+END_QUOTE

content coding 的值指明了一种已经或能够应用到一个 representation 的[[ruby:encoding%20transformation][编码转换]]。content coding 主要用来允许在没有丢失 representation 之前的媒体类型的身份以及没有丢失信息的情况下，对该 representation 进行压缩或者进行其他方式的转换。representation 常常被存储为[[ruby:code%20form][编码过的形式]]，然后将其直接进行传输，最后仅到达最终接收端才会进行解码。

#+BEGIN_QUOTE
译文：本译文将 "encoding" 翻译为“编码”，为了与之区分，不会对 "content coding" 进行翻译（实际上是我不知道怎么翻译才好，意会，意会）。
#+END_QUOTE

#+BEGIN_SRC text
  content-coding   = token
#+END_SRC

#+BEGIN_QUOTE
All content-coding values are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as defined in [[id:87f2ed30-a48b-4c31-a181-8e3a33ba1080][Section 8.4]]. They are used in the =Accept-Encoding= ([[id:a8fcc101-3782-4ed0-aec0-561b933e6a5f][Section 5.3.4]]) and =Content-Encoding= ([[id:a10adb00-e955-42a6-8d28-ed6f942db085][Section 3.1.2.2]]) header fields.
#+END_QUOTE

所有 =content-coding= 的值都是不区分大小写的，并且应该注册到 "HTTP Content Coding Registry" 注册表里，如[[id:87f2ed30-a48b-4c31-a181-8e3a33ba1080][章节 8.4]] 所述。它们用在 =Accept-Encoding= （[[id:a8fcc101-3782-4ed0-aec0-561b933e6a5f][章节 5.3.4]]）和 =Content-Encoding= （[[id:a10adb00-e955-42a6-8d28-ed6f942db085][章节 3.1.2.2]]）报头域里。

#+BEGIN_QUOTE
The following content-coding values are defined by this specification:
- compress (and x-compress): See [[id:a785a05f-6fdc-44d8-9343-3a66a49cb655][Section 4.2.1]] of [RFC7230].
- deflate: See [[id:fa7b432f-071b-4e26-9d2c-8fc1b95b6b64][Section 4.2.2]] of [RFC7230].
- gzip (and x-gzip): See [[id:d1579c8b-312c-414b-b421-960669b0d389][Section 4.2.3]] of [RFC7230].
#+END_QUOTE

本规范定义了以下 =content-coding= 值：
- compress（以及 x-compress）：见[[id:a785a05f-6fdc-44d8-9343-3a66a49cb655][【RFC7230】章节 4.2.1]]。
- deflate：见[[id:fa7b432f-071b-4e26-9d2c-8fc1b95b6b64][【RFC7230】章节4.2.2]]。
- gzip（以及 x-gzip）：[[id:d1579c8b-312c-414b-b421-960669b0d389][【RFC7230】见章节 4.2.3]]。

**** 3.1.2.2. Content-Encoding
:PROPERTIES:
:ID:       a10adb00-e955-42a6-8d28-ed6f942db085
:END:
#+BEGIN_QUOTE
The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the =Content-Type= header field. =Content-Encoding= is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
#+END_QUOTE

=Content-Encoding= 报头域指明了已经对 representation 应用了哪些突破其固有的媒体类型的 content codings，因此得知，为了获得 =Content-Type= 报头域所提及的那种媒体类型的数据，需要应用哪一种解码机制。=Content-Encoding= 主要用来允许在没有丢失 representation 之前的媒体类型的身份的情况下，对一个 representation 的数据进行压缩。

#+BEGIN_SRC text
  Content-Encoding = 1#content-coding
#+END_SRC

#+BEGIN_QUOTE
An example of its use is
#+END_QUOTE

它的用法见下面这个例子：

#+BEGIN_EXAMPLE
  Content-Encoding: gzip
#+END_EXAMPLE

#+BEGIN_QUOTE
If one or more encodings have been applied to a representation, the sender that applied the encodings *MUST* generate a =Content-Encoding= header field that lists the content codings in the order in which they were applied. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
#+END_QUOTE

如果对一个 representation 应用了一种或多种编码，应用这些编码的发送端 *必须* 生成一个 =Content-Encoding= 报头域，以它们被应用的先后顺序来一一列出对应的 content codings。如果某种编码需要附带额外的参数信息，可以由其他未在本规范上定义过的报头域来提供。

#+BEGIN_QUOTE
Unlike =Transfer-Encoding= ([[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][Section 3.3.1]] of [RFC7230]), the codings listed in =Content-Encoding= are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.
#+END_QUOTE

不像 =Transfer-Encoding= （[[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][【RFC7230】章节 3.3.1]]），列在 =Content-Encoding= 报头域上的 codings 是 representation 的特性。representation 是依据其编码过的形式来进行定义的，除非在元数据的定义中另有注明，所有其他关于 representation 的元数据是对该形式进行描述的。通常，representation 仅在渲染呈现或类似的用途之前才会被解码。

#+BEGIN_QUOTE
If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in =Content-Encoding= even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of =Content-Type= or =Content-Encoding=, since some user agents will behave differently in their handling of each response (e.g., open a "Save as ..." dialog instead of automatic decompression and rendering of content).
#+END_QUOTE

如果媒体类型包含有一种[[ruby:inherent%20encoding][固有的编码]]，例如一种总是以压缩方式来表示的数据格式，那么，这种编码不要在 =Content-Encoding= 里重申，哪怕它恰巧与其中一个 content codings 的算法一致。这种 content coding 只会在以下这种情况下才需要在 =Content-Encoding= 列出：出于某些怪异的原因，需要应用该 content coding 两次才能形成正确的 representation。同样，原服务器可能选择将该同样的数据作为[[ruby:multiple%20representations][多种 representations]] 来发布，其区别仅在于 coding 是作为 Content-Type 的一部分还是作为 Content-Encoding 的一部分 ，这是因为某些用户代理处理各个响应的行为会有所不同（例如，打开一个“另存为...”对话框，而不是自动解缩并渲染内容）。

#+BEGIN_QUOTE
An origin server *MAY* respond with a status code of =415 (Unsupported Media Type)= if a representation in the request message has a content coding that is not acceptable.
#+END_QUOTE

如果请求报文里的某个 representation 应用了服务器不支持的 content coding，源服务器 *可以* 以 =415 (Unsupported Media Type)= 作为响应。

*** 3.1.3. 受众语言 / Audience Language
**** 3.1.3.1. 语言标签 / Language Tags
:PROPERTIES:
:ID:       0a52652d-e5e8-40f9-ba1a-f96c45969b85
:END:
#+BEGIN_QUOTE
A language tag, as defined in [[[https://tools.ietf.org/html/rfc5646][RFC5646]]], identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.
#+END_QUOTE

正如【[[https://tools.ietf.org/html/rfc5646][RFC5646]]】所定义，[[ruby:language%20tag][语言标签]]标识了一种人类出于交流信息的目的而通过说、写或其他方式来传达的自然语言。计算机语言被明确排除在外。

#+BEGIN_QUOTE
HTTP uses language tags within the =Accept-Language= and =Content-Language= header fields. =Accept-Language= uses the broader =language-range= production defined in Section 5.3.5, whereas =Content-Language= uses the =language-tag= production defined below.
#+END_QUOTE

HTTP 在 =Accept-Language= 和 =Content-Language= 报头域里使用语言标签。=Accept-Language= 使用了更广义的 =language-range= 规则（定义在章节 5.3.5），而 =Content-Language= 使用了 =language-tag= 规则，其定义如下：

#+BEGIN_SRC text
  language-tag = <Language-Tag, see [RFC5646], Section 2.1>
#+END_SRC

#+BEGIN_QUOTE
A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada). Whitespace is not allowed within a language tag. Example tags include:
#+END_QUOTE

一个[[ruby:language%20tag][语言标签]]是由一个或多个不区分大小写的子标签组成的，每个子标签之间使用连接符（"-"，"%x2D"）分隔。大多数情况下，一个语言标签包含一个标识一种相关语系的[[ruby:primary%20language%20subtag][主要语言子标签]]（例如，"en" 代表[[ruby:English][英语]]），另外还可以选择性地在其后面附加一连串的子标签来优化或缩小语言范围（例如，"en-CA" 代表一种[[ruby:Canada][加拿大]]英语）。语言标签里不允许存在空格。语言标签的几个例子如下：

#+BEGIN_EXAMPLE
  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
#+END_EXAMPLE

#+BEGIN_QUOTE
See [[[https://tools.ietf.org/html/rfc5646][RFC5646]]] for further information.
#+END_QUOTE

更多信息见【[[https://tools.ietf.org/html/rfc5646][RFC5616]]】。

**** 3.1.3.2. Content-Language
:PROPERTIES:
:ID:       80f3e8e8-dabb-49b8-b7e6-45f83648a732
:END:
#+BEGIN_QUOTE
The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.
#+END_QUOTE

=Content-Language= 报头域描述了 representation 的目标受众的（一种或多种）自然语言。需要注意的是，它可能并不等价于用在 representation 里的所有语言。

#+BEGIN_SRC text
  Content-Language = 1#language-tag
#+END_SRC

#+BEGIN_QUOTE
Language tags are defined in [[id:0a52652d-e5e8-40f9-ba1a-f96c45969b85][Section 3.1.3.1]]. The primary purpose of =Content-Language= is to allow a user to identify and differentiate representations according to the users' own preferred language. Thus, if the content is intended only for a Danish-literate audience, the appropriate field is
#+END_QUOTE

[[ruby:language%20tag][语言标签]]定义在[[id:0a52652d-e5e8-40f9-ba1a-f96c45969b85][章节 3.1.3.1]] 里。=Content-Language= 的主要目的是允许一个用户依据用户自身的首选语言来标识和区分 representations。所以，如果只想将[[ruby:Danish-literate][懂丹麦语]]的人作为内容的目标受众，那么报头域可以这样设置：

#+BEGIN_EXAMPLE
  Content-Language: da
#+END_EXAMPLE

#+BEGIN_QUOTE
If no =Content-Language= is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
#+END_QUOTE

如果没有指定 =Content-Language= 报头域，那么就默认内容是面向所有语言受众的。这可能意味着发送端并不认为它自已是面向具体任一种自然语言的，或者发送端并不知道它自己打算使用哪一种语言。

#+BEGIN_QUOTE
Multiple languages *MAY* be listed for content that is intended for multiple audiences. For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for
#+END_QUOTE

对于面向多种受众的内容，*可以* 在 =Content-Language= 列出多种语言，多种语言，例如，一份“[[ruby:Treaty%20of%20Waitangi][怀唐伊条约]]”的译文，会同时出现[[ruby:original%20Maori][毛利语原文]]以及英文版本，那么可以这样设置：

#+BEGIN_EXAMPLE
  Content-Language: mi, en
#+END_EXAMPLE

#+BEGIN_QUOTE
However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the =Content-Language= would properly only include "en".
#+END_QUOTE

然而，只因为在一个 representation 里出现了多种语言就认为它是打算面向认识多种语言的受众，这是错误的。举个例子，一本面向新手的语言入门读物，就称为《第一堂拉丁语课》吧，是明确打算面向懂英语的读者的，那么，最恰当的做法是 =Content-Language= 只包含 "en"。

#+BEGIN_QUOTE
=Content-Language= *MAY* be applied to any media type — it is not limited to textual documents.
#+END_QUOTE

=Content-Language= 可以应用于任意[[ruby:media%20type][媒体类型]] 的 representation 里，也就是说，它并不仅限于[[ruby:textual%20documents][文本类的文档]]。

*** 3.1.4. 标识 / Identification
**** 3.1.4.1. 标识一个 Representation / Identifying a Representation
#+BEGIN_QUOTE
When a complete or partial representation is transferred in a message payload, it is often desirable for the sender to supply, or the recipient to determine, an identifier for a resource corresponding to that representation.
#+END_QUOTE

当一个完整的或部分的 representation 被传入到一个[[ruby:message%20payload][报文的有效载荷]]里，该 representation 所对应的资源标识符通常交由发送端去提供，或者交由接收端去决定会更好一些。

#+BEGIN_QUOTE
For a request message:
- If the request has a =Content-Location= header field, then the sender asserts that the payload is a representation of the resource identified by the =Content-Location= field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification). The information might still be useful for revision history links.
- Otherwise, the payload is unidentified.
#+END_QUOTE

对于一个请求报文来说：
- *如果* 该请求有一个 =Content-Location= 报头域，意味着发送端[[ruby:assert][断言]]请求报文的有效载荷是某个资源的一个 representation，而该资源是由 =Content-Location= 的值所标识的。但是，除非这种[[ruby:assertion][断言]]能够通过其他途径（本规则并没有定义有什么途径）来验证，否则不能相信该断言。对于修正历史链接，该信息还是有用的。
- *否则*，该请求报文的有效载荷是[[ruby:unidentified][未标识]]的。

#+BEGIN_QUOTE
For a response message, the following rules are applied in order until a match is found:
1. If the request method is GET or HEAD and the response status code is =200 (OK)=, =204 (No Content)=, =206 (Partial Content)=, or =304 (Not Modified)=, the payload is a representation of the resource identified by the effective request URI ([[id:3265c21d-0d3b-4776-8e28-38278d168779][Section 5.5]] of [RFC7230]).
2. If the request method is GET or HEAD and the response status code is =203 (Non-Authoritative Information)=, the payload is a potentially modified or enhanced representation of the target resource as provided by an intermediary.
3. If the response has a =Content-Location= header field and its field-value is a reference to the same URI as the effective request URI, the payload is a representation of the resource identified by the effective request URI.
4. If the response has a =Content-Location= header field and its field-value is a reference to a URI different from the effective request URI, then the sender asserts that the payload is a representation of the resource identified by the =Content-Location= field-value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification).
5. Otherwise, the payload is unidentified.
#+END_QUOTE

对于一个响应报文来说，以下规则会被按顺序应用，直到匹配其中之一：
1. *如果* 请求方法是 GET 或者 HEAD，且响应状态码是 =200 (OK)=、=204 (No Content)=、=206 (Partial Content)= 或者 =304 (Not Modified)=，那么，响应报文的有效载荷是某个资源的 representation，而该资源是由[[ruby:effective%20request%20URI][有效请求 URI]] 所标识的（[[id:3265c21d-0d3b-4776-8e28-38278d168779][【RFC7230】章节 5.5]]）。
2. *如果* 请求方法是 GET 或者 HEAD，且响应状态码是 =203 (Non-Authoritative Information)=，那么，响应报文的有效载荷是某个资源的 可能已被修改过或增强过的 representation，该 representation 由某个中间人提供。
3. *如果* 响应带有一个 =Content-Location= 报头域并且它的域值是一个跟[[ruby:effective%20request%20URI][有效请求 URI]] 相同的 URI 引用，那么，响应报文的有效载荷是某个资源的 representation，而该资源是由有效请求 URI 所标识的。
4. *如果* 响应带有一个 =Content-Location= 报头域并且它的域值是一个跟[[ruby:effective%20request%20URI][有效请求 URI]] 不相同的 URI 引用，那么，发送端断言该有效载荷是某个资源的 representation，而该资源是由 =Content-Location= 的域值所标识的。但是，除非这种[[ruby:assertion][断言]]能够通过其他途径（本规则并没有定义有什么途径）来验证，否则不能相信该断言。
5. *否则*，该响应报文的有效载荷是未标识的。

**** 3.1.4.2. Content-Location
:PROPERTIES:
:ID:       91650144-4bfc-4362-b628-f96578a5c756
:END:
#+BEGIN_QUOTE
The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a 200 (OK) response would contain the same representation that is enclosed as payload in this message.
#+END_QUOTE

=Content-Location= 报头域是一个 URI，该 URI 能够用于作为一个与封装在报文有效载荷内的 representation 所对应的具体资源的标识符。换句话说，如果某个用户代理对这个 URI 执行了 GET 请求，那么会回应一个 =200 (OK)= 响应报文，该响应报文的有效载荷会封装相同的 representation。

#+BEGIN_SRC text
  Content-Location = absolute-URI / partial-URI
#+END_SRC

#+BEGIN_QUOTE
The =Content-Location= value is not a replacement for the effective Request URI ([[id:3265c21d-0d3b-4776-8e28-38278d168779][Section 5.5]] of [RFC7230]). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in [[https://tools.ietf.org/html/rfc2557#section-4][Section 4]] of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.
#+END_QUOTE

=Content-Location= 的值并不是用来替换[[ruby:effective%20request%20URI][有效请求 URI]]（[[id:3265c21d-0d3b-4776-8e28-38278d168779][【RFC7230】章节 5.5]]）的。它是一个 representation metadata。它具有与定义在 MIME 的同名报头域（[[https://tools.ietf.org/html/rfc2557#section-4][【RFC2557】章节 4]]）相同的句法和语义。但是，这个报头域出现在一个 HTTP 报头里是具有特殊含义的。

#+BEGIN_QUOTE
If =Content-Location= is included in a =2xx (Successful)= response message and its value refers (after conversion to absolute form) to a URI that is the same as the effective request URI, then the recipient *MAY* consider the payload to be a current representation of that resource at the time indicated by the message origination date. For a GET ([[id:698bab73-07b1-4349-8a03-5a4a89d966d8][Section 4.3.1]]) or HEAD ([[id:d00f1692-2d40-4b09-a634-9c87fce07bc4][Section 4.3.2]]) request, this is the same as the default semantics when no =Content-Location= is provided by the server. For a state-changing request like PUT ([[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][Section 4.3.4]]) or POST ([[id:d672d01b-615b-416a-a750-0442a6901ed0][Section 4.3.3]]), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.
#+END_QUOTE

如果 =Content-Location= 被包含在一个 =2xx (Successful)= 响应报文里，且它的值指向于（在转换为[[ruby:absolute%20form][绝对形式]]之后）一个与有效请求 URI 相同的 URI，那么，接收端 *可以* 将该有效载荷认为是一个在特定时间里的资源的 current representation，所述特定时间是由[[ruby:message%20origination%20date][报文始发日期]]所指定的时间。对于 GET（[[id:698bab73-07b1-4349-8a03-5a4a89d966d8][章节 4.3.1]]）或者 HEAD（[[id:d00f1692-2d40-4b09-a634-9c87fce07bc4][章节 4.3.2]]）请求来说，这与在服务器没有提供 =Content-Location= 报头域的情况下的默认语义相一致。对于类似 PUT（[[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][章节 4.3.4]]）或者 POST（[[id:d672d01b-615b-416a-a750-0442a6901ed0][章节 4.3.3]]）这些会[[ruby:state-changing][改变状态]]的请求来说，这意味着服务器的响应包含了该资源的新的 representation，由此与那些只报告动作方面的信息（例如，“[[ruby:It%20worked!][它生效了！]]”）的 representations 作区分。

#+BEGIN_QUOTE
If =Content-Location= is included in a =2xx (Successful)= response message and its field-value refers to a URI that differs from the effective request URI, then the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.
- For a response to a GET or HEAD request, this is an indication that the effective request URI refers to a resource that is subject to content negotiation and the =Content-Location= field-value is a more specific identifier for the selected representation.
- For a =201 (Created)= response to a state-changing method, a =Content-Location= field-value that is identical to the =Location= field-value indicates that this payload is a current representation of the newly created resource.
- Otherwise, such a =Content-Location= indicates that this payload is a representation reporting on the requested action's status and that the same report is available (for future access with GET) at the given URI. For example, a purchase transaction made via a POST request might include a receipt document as the payload of the =200 (OK)= response; the =Content-Location= field-value provides an identifier for retrieving a copy of that same receipt in the future.
#+END_QUOTE

如果 =Content-Location= 被包含在一个 =2xx (Successful)= 响应报文里，且它的域值指向于一个与有效请求 URI 不相同的 URI，那么，源服务器[[ruby:claim][声称]]该 URI 是一个与封装在该有效载荷内的 representation 相对应的不同资源的标识符。这种声称只能在这两个标识符具有相同的资源所有者，且该资源所有者不能经由 HTTP 以编程方式来确定的情况下才能被相信。
- 对于回应给 GET 或 HEAD 请求的一个响应，它表明了[[ruby:effective%20request%20URI][有效请求 URI]] 指向到一个服从[[ruby:content%20negotiation][内容协商]]的资源，并且针对[[ruby:selective%20representation][已选定的 representation]]  来说，=Content-Location= 的域值是一个更加具体的标识符。
- 对于回应给[[ruby:state-changing%20method][状态改变的请求方法]]的一个 =201 (Created)= 响应，如果 =Content-Location= 的域值与 =Location= 的域值相同，那么，这表明这个有效载荷是新近被创建的资源的[[ruby:current%20representation][当前 representation]]。
- 否则，这个 =Content-Location= 表明了这个有效载荷是一个对所请求的动作的状态方面进行报告的 representation，且对于给定的 URI ，同样的报告是可供使用的（用于将来 GET 请求对 representation 进行访问）。例如，一个经由 POST 请求而产生的购买交易可能包含一个以一份收款凭据作为 =200 (OK)= 响应的有效载荷，=Content-Location= 的域值提供了一个标识符，用于将来重新获取这份收款凭据的一个备份。

#+BEGIN_QUOTE
A user agent that sends =Content-Location= in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.
#+END_QUOTE

用户代理在其发送的请求报文里带有 =Content-Location= 是想表达它的域值里的 URI 指的是用户代理最开始是在哪里获得这个封装在有效载荷内的 representation 的内容的（在该用户代理对这个 representation 所作的任何更改之前）。也就是说，该用户代理提供了一种对于原始 representation 的[[ruby:source][来源]]的[[ruby:back%20link][反向链接]][fn:1]。

#+BEGIN_QUOTE
An origin server that receives a =Content-Location= field in a request message *MUST* treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server *MAY* use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server *MUST NOT* use such context information to alter the request semantics.
#+END_QUOTE

源服务器在一个请求报文中接收到 =Content-Location= 报头域的时候，*必须* 将该报头域的信息作为[[ruby:transitory%20request%20context][暂时的请求上下文]]来对待，而不是作为 representation metadata 来逐字保存。源服务器 *可以* 使用该上下文来指导请求的处理，或者将其保存起来留作其他用途，例如，用于[[ruby:source%20links][来源链接]]或[[ruby:versioning%20metadata][元数据的版本管理]]。但是，源服务器 *禁止* 使用这种上下文信息来改变该请求的语义。

#+BEGIN_QUOTE
For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the =Content-Location= cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the =Content-Location= URI.
#+END_QUOTE

例如，如果一个客户端对一个[[ruby:negotiated%20resource][协商过的资源]]发起一个 PUT 请求，并且源服务器接受了这个 PUT（没有经过[[ruby:redirection][重定向]]），那么，资源的新状态预期将与提供自该 PUT 请求的 representation 相一致；PUT 请求里的 =Content-Location= 报头域不能当作是一种[[ruby:reverse%20content%20selection%20identifier][反向内容选择标识符]]来仅对协商的 representations 中的其中一种进行更新。如果客户端想要后者这种语义，它可以直接对 =Content-Location= 的 URI 应用 PUT 请求。

** 3.2. 表示数据 / Representation Data
#+BEGIN_QUOTE
The representation data associated with an HTTP message is either provided as the payload body of the message or referred to by the message semantics and the effective request URI. The representation data is in a format and encoding defined by the representation metadata header fields.
#+END_QUOTE

一个 HTTP 报文相关联的 representation data 或者提供作为报文有效载荷，或者通过报文的语义和有效请求 URI 来引用它。representation data 是处于某种格式和编码中，这种格式和编码由 representation metadata 相关的报头域来定义。

#+BEGIN_QUOTE
The data type of the representation data is determined via the header fields =Content-Type= and =Content-Encoding=. These define a two-layer, ordered encoding model:
#+END_QUOTE

representation data 的数据类型是经由 =Content-Type= 和 =Content-Encoding= 报头域决定的。它们共同定义了一种[[ruby:two-layer,%20ordered%20encoding%20model][双层的、顺序编码的模型]]：

#+BEGIN_SRC text
  representation-data := Content-Encoding( Content-Type( bits ) )
#+END_SRC

** 3.3. 有效载荷的语义 / Payload Semantics
:PROPERTIES:
:ID:       4c395bab-baa6-4895-b677-5daa1584da6e
:END:
#+BEGIN_QUOTE
Some HTTP messages transfer a complete or partial representation as the message "payload". In some cases, a payload might contain only the associated representation's header fields (e.g., responses to HEAD) or only some part(s) of the representation data (e.g., the =206 (Partial Content)= status code).
#+END_QUOTE

某些 HTTP 报文传输一个完整或部分的 representation 作为报文的“[[ruby:payload][有效载荷]]”。在某些情况下，一个有效载荷可能只包含 representation 相关的报头域（例如，回应给 HEAD 的响应报文），或者只有 representation 的某（几）部分（例如，=206 (Partial Content)= 状态码）。

#+BEGIN_QUOTE
The purpose of a payload in a request is defined by the method semantics. For example, a representation in the payload of a PUT request ([[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][Section 4.3.4]]) represents the desired state of the target resource if the request is successfully applied, whereas a representation in the payload of a POST request ([[id:d672d01b-615b-416a-a750-0442a6901ed0][Section 4.3.3]]) represents information to be processed by the target resource.
#+END_QUOTE

对于请求报文里的有效载荷，其目的是由[[ruby:request%20method%20semantics][请求方法的语义]]来定义的。例如，在一个 PUT 请求（[[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][章节 4.3.4]]）的有效载荷内的 representation 表示如果成功应用该请求以后，[[ruby:target%20resource][目标资源]]的预期的状态。而一个 POST 请求（[[id:d672d01b-615b-416a-a750-0442a6901ed0][章节 4.3.3]]）的有效载荷内的 representation 表示交由目标资源来处理的信息。

#+BEGIN_QUOTE
In a response, the payload's purpose is defined by both the request method and the response status code. For example, the payload of a =200 (OK)= response to GET ([[id:698bab73-07b1-4349-8a03-5a4a89d966d8][Section 4.3.1]]) represents the current state of the target resource, as observed at the time of the message origination date ([[id:5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1][Section 7.1.1.2]]), whereas the payload of the same status code in a response to POST might represent either the processing result or the new state of the target resource after applying the processing. Response messages with an error status code usually contain a payload that represents the error condition, such that it describes the error state and what next steps are suggested for resolving it.
#+END_QUOTE

在一个响应报文里，有效载荷的目标是由[[ruby:request%20method][请求方法]]和[[ruby:reponse%20status%20code][响应状态码]]两者共同来定义的。例如，一个回应给 GET 请求（[[id:698bab73-07b1-4349-8a03-5a4a89d966d8][章节 4.3.1]]）的 =200 (OK)= 响应报文表示在[[ruby:message%20origination%20date][报文发起日期]]（[[id:5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1][章节 7.1.1.2]]）所观察到的[[ruby:target%20resource][目标资源]]的目前状态。而一个回应给 POST 请求的 =200 (OK)= 响应报文可能表示：或者是在应用该请求以后的处理结果，或者是在应用该请求以后目标资源的新状态。带有一个错误状态码的响应报文通常会包含一个表示该错误条件的有效载荷，以描述错误状态以及如何解决错误的下一步建议。

#+BEGIN_QUOTE
Header fields that specifically describe the payload, rather than the associated representation, are referred to as "payload header fields". Payload header fields are defined in other parts of this specification, due to their impact on message parsing.
#+END_QUOTE

特定用于描述有效载荷而不是描述相关的 representation 的报头域，被称为“[[ruby:payload%20header%20fields][有效载荷报头域]]”。有效载荷报头域被定义在本规范的其他部分中，由它们对[[ruby:message%20parsing][报文解析]]的影响来决定。

#+BEGIN_QUOTE
译注：有效载荷报头域并不是说这些报头域在有效载荷里，它们依然被放置在[[ruby:header%20section][报头块]]里。
#+END_QUOTE

| Header Field Name | Defined in...              |
|-------------------+----------------------------|
| Content-Length    | [[id:7b3e90b9-3ae5-402b-922c-2342d361c79f][Section 3.3.2]] of [RFC7230] |
| Content-Range     | [[https://tools.ietf.org/html/rfc7233][Section 4.2]] of [RFC7233]   |
| Trailer           | [[id:5ecf5800-1004-4acb-ba25-8772abdecd5a][Section 4.4]] of [RFC7230]   |
| Transfer-Encoding | [[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][Section 3.3.1]] of [RFC7230] |

** 3.4. 内容协商 / Content Negotiation
:PROPERTIES:
:ID:       c45cb9ca-1e51-4738-8c43-231e7316ea86
:END:
#+BEGIN_QUOTE
When responses convey payload information, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings. Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver. For this reason, HTTP provides mechanisms for content negotiation.
#+END_QUOTE

响应在传达有效载荷信息的时候，无论是表达成功还是失败，源服务器通常会有多种不同的方式来表示该信息，例如，以不同的格式、语言或编码来表示。同样，不同的用户或用户代理可能有不同的能力、特性或者偏好，会影响到源服务器——在所有可用的 representations 中，究竟响应哪一个 representation 才是最合适的。出于上述原因，HTTP 提供了[[ruby:content%20negotiation][内容协商]]的机制。

#+BEGIN_QUOTE
This specification defines two patterns of content negotiation that can be made visible within the protocol: "proactive", where the server selects the representation based upon the user agent's stated preferences, and "reactive" negotiation, where the server provides a list of representations for the user agent to choose from. Other patterns of content negotiation include "conditional content", where the representation consists of multiple parts that are selectively rendered based on user agent parameters, "active content", where the representation contains a script that makes additional (more specific) requests based on the user agent characteristics, and "Transparent Content Negotiation" ([[[https://tools.ietf.org/html/rfc2295][RFC2295]]]), where content selection is performed by an intermediary. These patterns are not mutually exclusive, and each has trade-offs in applicability and practicality.
#+END_QUOTE

本规范定义了两种内容协商的模式，使之能够在协议里可见：“[[ruby:proactive][主动型]]”和“[[ruby:reactive][被动型]]”。对于主动型内容协商，服务器会依据用户代理申明的偏好来选择 representation。对于被动型内容协商，服务会提供一系列的 representations 供用户代理选择。其他的内容协商的模式包括：“[[ruby:conditional%20content][条件内容]]”，representation 由多个部分组成，源服务器基于用户代理的参数来选择性地渲染各个部分；“[[ruby:active%20content][活动内容]]”，representation 包含有一个脚本，该脚本可以基于用户代理的特性来生成额外的（更加具体的）请求；“[[ruby:Transparent%20Content%20Negotiation][透明内容协商]]”（【[[https://tools.ietf.org/html/rfc2295][RFC2295]]】），由一个中间人来执行内容选择。这些模式不是[[ruby:mutually%20exclusive][互斥的]]，每种都有其[[ruby:applicability][适应性]]和[[ruby:practicality][实用性]]。

#+BEGIN_QUOTE
Note that, in all cases, HTTP is not aware of the resource semantics. The consistency with which an origin server responds to requests, over time and over the varying dimensions of content negotiation, and thus the "sameness" of a resource's observed representations over time, is determined entirely by whatever entity or algorithm selects or generates those responses. HTTP pays no attention to the man behind the curtain.
#+END_QUOTE

需要注意的是，不管什么情况下，HTTP 都不知道资源的语义。源服务器响应给请求所遵循的一致性，随着时间和内容协商的不同维度的变化，因然一个资源的观察到的 representations 随着时间所表现出的“相同性”，是完全取决于实体还是算法，选择还是生成了什么响应。HTTP 并不在意幕后的人物。

*** 3.4.1. 主动型协商 / Proactive Negotiation
:PROPERTIES:
:ID:       c1d92ed4-69d5-4575-88c2-090534949ccf
:END:
#+BEGIN_QUOTE
When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called proactive negotiation (a.k.a., server-driven negotiation). Selection is based on the available representations for a response (the dimensions over which it might vary, such as language, content-coding, etc.) compared to various information supplied in the request, including both the explicit negotiation fields of Section 5.3 and implicit characteristics, such as the client's network address or parts of the =User-Agent= field.
#+END_QUOTE

用户代理发送包含内容协商的偏好信息的请求到服务器，让服务器的某个算法来选择偏好 representation，称之为[[ruby:proactive%20negotiation][主动型协商]]（也称[[ruby:server-driven%20negotiation][服务器驱动型协商]]）。这种选择是基于供响应使用的 representations （维度有很多，例如语言、内容编码等），对比多种由请求提供的信息，包括显式协商报头域（章节 5.3）和隐式特性两者，例如客户端的网络地址或者 =User-Agent= 报头域的部分信息。

#+BEGIN_QUOTE
Proactive negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to a user agent, or when the server desires to send its "best guess" to the user agent along with the first response (hoping to avoid the round trip delay of a subsequent request if the "best guess" is good enough for the user). In order to improve the server's guess, a user agent *MAY* send request header fields that describe its preferences.
#+END_QUOTE

主动型协商适用于以下情况：当难以向用户代理描述清楚服务器的选择算法（如何从[[ruby:available%20representations][可使用的 representations]] 之中选择最佳的一个）；或者当服务器倾向于在发送第一个响应到用户代理的时候就附带上它的“[[ruby:best%20guess][最佳猜测]]”（希望如果该“最佳猜测”对于该用户来说已经足够好的话，就能够避免后续请求的[[ruby:round%20trip%20delay][往返延时]]）。为了提升服务器猜测的准确性，用户代理 *可以* 在其发送的请求报文中包含某些报头域来描述自身的[[ruby:preferences][偏好]]。

#+BEGIN_QUOTE
Proactive negotiation has serious disadvantages:
- It is impossible for the server to accurately determine what might be "best" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?);
- Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy;
- It complicates the implementation of an origin server and the algorithms for generating responses to a request; and,
- It limits the reusability of responses for shared caching.
#+END_QUOTE

主动型协商有以下严重的弊端：
- 对于任何给定的用户，要让服务器精准确定什么才是“最佳的 representation”是不可能的，这是因为这需要全面了解用户代理的[[ruby:capabilities][能力]]及其对响应的[[ruby:intended%20use][使用意图]]（例如，用户是否想在屏幕上浏览或者将其打印成纸质的？）；
- 让用户代理在每次请求里都要描述自身的能力是非常[[ruby:inefficient][低效的]]（假定只有一小部分响应带有[[ruby:multiple%20representations][多个 representations]]），而且对用户的隐私有潜在风险；
- 复杂化了源服务器的实现和生成响应给到请求的算法；
- 限制了[[ruby:shared%20caching][共享缓存]]的[[ruby:reusability][复用性]]。

#+BEGIN_QUOTE
A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a =406 (Not Acceptable)= response.
#+END_QUOTE

用户代理不能信赖主动型协商的[[ruby:preferences][预设]]会一直被遵循，这是因为源服务器可能没有对所请求的资源实现主动型协商，或者认为发送一个并不符合用户代理的偏好的响应比发送一个 =406 (Not Acceptable)= 响应要好。

#+BEGIN_QUOTE
A =Vary= header field ([[id:ca7f8781-b183-4563-a90a-b9b7ad4f1032][Section 7.1.4]]) is often sent in a response subject to proactive negotiation to indicate what parts of the request information were used in the selection algorithm.
#+END_QUOTE

=Vary= 报头域（[[id:ca7f8781-b183-4563-a90a-b9b7ad4f1032][章节 7.1.4]]）通常用来指明主动型协商的选择算法会用到请求信息的哪些部分。

*** 3.4.2. 被动型协商 / Reactive Negotiation
#+BEGIN_QUOTE
With reactive negotiation (a.k.a., agent-driven negotiation), selection of the best response representation (regardless of the status code) is performed by the user agent after receiving an initial response from the origin server that contains a list of resources for alternative representations. If the user agent is not satisfied by the initial response representation, it can perform a GET request on one or more of the alternative resources, selected based on metadata included in the list, to obtain a different form of representation for that response. Selection of alternatives might be performed automatically by the user agent or manually by the user selecting from a generated (possibly hypertext) menu.
#+END_QUOTE

使用[[ruby:reactive%20negotiation][被动型协商]]（也称[[ruby:agent-driven%20negotiation][代理驱动型协商]]），选择哪一个作为响应的最佳 representation（且不论[[ruby:response%20status%20code][响应状态码]]）是由用户代理在接收到一个来自源服务器的[[ruby:initial%20response][初始响应]]之后执行的。该初始响应包含一个[[ruby:alternative%20representations][备选 representations]] 列表。如果用户代理不满意初始响应的 representation，它可以（基于包含在上述列表中的元数据来）选择向一个或多个备选 representations 发起 GET 请求来获得不同形式的 representation。选择哪一种备选 representation 可能由用户代理自动执行，也可能由用户从一个生成好的菜单（也许是超文本）里手动选择。

#+BEGIN_QUOTE
Note that the above refers to representations of the response, in general, not representations of the resource. The alternative representations are only considered representations of the target resource if the response in which those alternatives are provided has the semantics of being a representation of the target resource (e.g., a =200 (OK)= response to a GET request) or has the semantics of providing links to alternative representations for the target resource (e.g., a =300 (Multiple Choices)= response to a GET request).
#+END_QUOTE

需要注意的是，上述所指的是响应的 representations，通常来说，并不是指资源的 representations。如果提供那些[[ruby:alternative%20representations][备选 representation]] 的响应带有如下语义：成为目标资源的一种 representation（例如，一个回应给 GET 请求的 =200 (OK)= 响应）；或者提供链接到该目标资源的备选 representations（例如，一个回应给 GET 请求的 =300 (Multiple Choices)= 响应），那么，备选 representations 仅考虑目标资源的 representations。

#+BEGIN_QUOTE
A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred. For example, the alternatives listed in responses with the =300 (Multiple Choices)= and =406 (Not Acceptable)= status codes include information about the available representations so that the user or user agent can react by making a selection.
#+END_QUOTE

服务器可能选择不发送一个初始 representation，而只发送[[ruby:list%20of%20alternatives][备选列表]]，从而表明它首选由用户代理来执行的被动型协商。例如，列在带有 =300 (Multiple Choices)= 和 =406 (Not Acceptable)= 状态码的响应里的[[ruby:alternatives][备选物]]，包含了关于[[ruby:available%20representations][可用 representations]] 的信息以便用户或用户代理作出选择。

#+BEGIN_QUOTE
Reactive negotiation is advantageous when the response would vary over commonly used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage.
#+END_QUOTE

被动型协商适用于以下情况：当响应会随常用维度（例如类型、语言、编码等）而变化；当源服务器无法通过检测请求而确定用户代理的能力；当使用[[ruby:public%20caches][公共缓存]]来分发服务器的负载和降低网络使用。

#+BEGIN_QUOTE
Reactive negotiation suffers from the disadvantages of transmitting a list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation. Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed as an extension.
#+END_QUOTE

被动型协商存在以下缺点：需要传递备选列表到用户代理，并且需要另一个请求来获得一种备选 representation。
在报头块里传递备选列表势必会导致[[ruby:degrades%20user-perceived%20latency][用户观感延时的降级]]。而且，本规范并没有定义用于支持自动选择的机制，但它也没有阻止这样一种机制发展成为扩展。

#+BEGIN_QUOTE
译注：[[https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation][MDN web docs]] 里对内容协商有更详细的描述。
#+END_QUOTE

* 4. 请求方法 / Request Methods
:PROPERTIES:
:ID:       e6ec0aa0-3e4d-4367-bffd-423e028210b0
:END:
** 4.1. 概况 / Overview
#+BEGIN_QUOTE
The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.
#+END_QUOTE

请求方法的[[ruby:token][标记]]是请求语义的主要来源，它指明了客户端发起这次请求的目的以及它期望什么作为成功结果。

#+BEGIN_QUOTE
The request method's semantics might be further specialized by the semantics of some header fields when present in a request ([[id:f8e7b063-496f-473e-95e8-88ec76f21582][Section 5]]) if those additional semantics do not conflict with the method. For example, a client can send conditional request header fields ([[id:b21923d5-a8f9-4560-8592-92fd9a098bf4][Section 5.2]]) to make the requested action conditional on the current state of the target resource ([[[https://tools.ietf.org/html/rfc7232][RFC7232]]]).
#+END_QUOTE

请求方法的语义可能由于某些请求报头域（[[id:f8e7b063-496f-473e-95e8-88ec76f21582][章节 5]]）的出现而被[[ruby:further%20specialized][进一步深化]]，如果这些报头域的语义与方法的语义并不冲突的话。例如，客户端能够发送[[ruby:conditional%20request%20header%20fields][条件请求报头域]]（[[id:b21923d5-a8f9-4560-8592-92fd9a098bf4][章节 5.2]]）以使对目标资源的当前状态的请求动作[[ruby:conditional][条件化]]（【[[https://tools.ietf.org/html/rfc7232][RFC7232]]】）。

#+BEGIN_SRC text
  method = token
#+END_SRC

#+BEGIN_QUOTE
HTTP was originally designed to be usable as an interface to distributed object systems. The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics. The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names.
#+END_QUOTE

HTTP 最初是被设计为用来作为[[ruby:distributed%20object%20systems][分布式对象系统]]的一种接口。请求方法被设想为向某个目标资源应用语义，这就跟在某个被标识的对象上执行某个已定义的方法会应用相应的语义一样。[[ruby:method%20tokens][方法标记]]是区分大小写的，这是因为它可能用作一种区分方法名称大小写的网关，来对[[ruby:object-based%20systems][基于对象的系统]]进行访问。

#+BEGIN_QUOTE
Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST]. Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.
#+END_QUOTE

不同于分布式对象，在 HTTP 里，[[ruby:standardized%20request%20methods][标准请求方法]]不是[[ruby:resource-specific][资源特定的]]，这是因为提供统一接口是为了在基于网络的系统中有更好的可见性和复用（【[[http://roy.gbiv.com/pubs/dissertation/top.htm][REST]]】）。一旦定义了标准化的方法，那么，当它被应用到任意资源的时候，它都应该具有同等的语义，虽然每种资源会自己决定是否实现或者允许这些语义。

#+BEGIN_QUOTE
This specification defines a number of standardized methods that are commonly used in HTTP, as outlined by the following table. By convention, standardized methods are defined in all-uppercase US-ASCII letters.
#+END_QUOTE

本规范定义了若干常用在 HTTP 里的标准方法，见下表的概括。按照惯例，标准方法是定义为纯大写的 US-ASCII 字母。

| 方法    | 描述                                                         |  章节 |
|---------+--------------------------------------------------------------+-------|
| GET     | 传输目标资源的一种 current representation                    | [[id:698bab73-07b1-4349-8a03-5a4a89d966d8][4.3.1]] |
| HEAD    | 与 GET 相同，除了仅传输状态行和报头块                        | [[id:d00f1692-2d40-4b09-a634-9c87fce07bc4][4.3.2]] |
| POST    | 对请求有效载荷执行特定资源的处理                             | [[id:d672d01b-615b-416a-a750-0442a6901ed0][4.3.3]] |
| PUT     | 使用请求有效载荷来替换目标资源的所有 current representations | [[id:28f69be8-26e9-4dd7-930e-7c683d7bcf8a][4.3.4]] |
| DELETE  | 删除目标资源的所有 current representations                   | [[id:9e649fa9-0f7f-40d0-adef-8af6a6f62e80][4.3.5]] |
| CONNECT | 与目标资源所标识的服务器建立隧道                             | [[id:630ab908-5d8e-400b-bed4-f6973b8c1549][4.3.6]] |
| OPTIONS | 描述关于目标资源的通信选项                                   | [[id:f659b35f-7510-4961-ad3a-3ab1b312a681][4.3.7]] |
| TRACE   | 执行一种沿着目标资源的路径的报文（消息）loop-back 测试       | [[id:bdc9e3b4-bac3-46c5-9319-31f7f4d6469d][4.3.8]] |

#+BEGIN_QUOTE
All general-purpose servers *MUST* support the methods GET and HEAD. All other methods are OPTIONAL.
#+END_QUOTE

所有通用服务器 *必须* 支持 GET 和 HEAD 方法。所有其他方法都是 *可选的*。

#+BEGIN_QUOTE
Additional methods, outside the scope of this specification, have been standardized for use in HTTP. All such methods ought to be registered within the "Hypertext Transfer Protocol (HTTP) Method Registry" maintained by IANA, as defined in [[id:193d7ad5-9c6d-4bf7-98f1-6984a42af639][Section 8.1]].
#+END_QUOTE

超出本规范所定义的额外方法，它们在 HTTP 的使用方式已经被标准化。应该把所有这些方法注册在由 IANA 维护的 "Hypertext Transfer Protocol (HTTP) Method Registry" 注册表中，其定义见[[id:193d7ad5-9c6d-4bf7-98f1-6984a42af639][章节 8.1]]。

#+BEGIN_QUOTE
The set of methods allowed by a target resource can be listed in an =Allow= header field ([[id:f8577773-512f-4d68-8f5d-444368db7c29][Section 7.4.1]]). However, the set of allowed methods can change dynamically. When a request method is received that is unrecognized or not implemented by an origin server, the origin server *SHOULD* respond with the =501 (Not Implemented)= status code. When a request method is received that is known by an origin server but not allowed for the target resource, the origin server *SHOULD* respond with the =405 (Method Not Allowed)= status code.
#+END_QUOTE

被[[ruby:target%20resource][目标资源]]所允许的方法集可以列在 =Allow= 报头域内（[[id:f8577773-512f-4d68-8f5d-444368db7c29][章节 7.4.1]]）。然而，目标资源可以动态改变其允许哪些方法。当源服务器接收到一个[[ruby:unrecognized][不能识别]]或自身[[ruby:not%20implemented][未实现的]]请求方法时，源服务器 *应当* 以 =501 (Not Implemented)= 作为响应。当服务器接收到一个能够识别但目标资源不允许的请求方法时，源服务器 *应当* 以 =405 (Method Not Allowed)= 作为响应。

** 4.2. 公共方法属性 / Common Method Properties
*** 4.2.1. 安全方法 / Safe Methods
:PROPERTIES:
:ID:       2f967e3d-8694-430b-ad06-e748fd39b281
:END:
#+BEGIN_QUOTE
Request methods are considered "safe" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.
#+END_QUOTE

如果请求方法所定义的语义本质上是[[ruby:read-only][只读]]的，那么，这种请求方法可以认为是“[[ruby:safe][安全的]]”。例如，在向源服务器的某个目标资源应用某个[[ruby:safe%20method][安全方法]]以后，客户端既[[ruby:not%20request][没有请求（要求）]]也[[ruby:not%20expect][没有期望]]源服务器有任何状态的变化。同样，安全方法的合理使用并不希望对源服务器造成任何损害、财产损失、或者异常负担。

#+BEGIN_QUOTE
This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server. Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account.
#+END_QUOTE

安全方法的这种定义并不妨碍将其[[ruby:implement][实现]]为一种可能包含有害行为的方法，表现为不完全只读，或者当执行某个安全方法时会引起[[ruby:side%20effects][副作用]]。然而，重要的是，客户端并没有请求（要求）服务器执行额外的行为，并且不能因此而追究客户端的责任。例如，大多数服务器在完成每个响应的时候，会附加上请求信息到访问日志文件里面，而不管这是什么请求方法，这就被认为是安全的，哪怕日志存储可能变满导致服务器崩溃。同样，在网站上发起一个安全的请求来进行广告甄选，通常会有广告账号记账的副作用（即产生广告费用的消耗）。

#+BEGIN_QUOTE
Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
#+END_QUOTE

本规范所定义的请求方法中，定义为安全的方法有：GET、HEAD、OPTIONS 和 TRACE。

#+BEGIN_QUOTE
The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm. In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content.
#+END_QUOTE

之所有要区分方法是否安全，是为了放心开启[[ruby:automated%20retrieval%20processes][自动检索程序]]（[[ruby:spider][爬虫]]）和[[ruby:cache%20performance%20optimization][缓存性能优化]]（[[ruby:pre-fetching][预取]]）而不需要担心引起问题。再者，它允许用户代理，在处理可能不受信任的内容的时候，对非安全方法的自动使用施加适当的约束。

#+BEGIN_QUOTE
A user agent *SHOULD* distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.
#+END_QUOTE

当呈现潜在的请求动作给用户的时候，用户代理 *应当* 区分好安全与非安全的方法，以便在这种请求动作被执行之前，用户能够意识到这是一种不安全的动作。

#+BEGIN_QUOTE
When a resource is constructed such that parameters within the effective request URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as "page?do=delete". If the purpose of such a resource is to perform an unsafe action, then the resource owner *MUST* disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.
#+END_QUOTE

构建一个资源，使在[[ruby:effective%20request%20URI][有效请求 URI]] 里的参数会影响到的请求动作选择，那么，确保该动作是否符合请求方法的语义是资源所有者的责任。例如，[[ruby:Web-based%20content%20editing%20software][基于网站的内容编辑软件]]常常会在[[ruby:query%20parameters][查询参数]]里使用某些动作，如 "page?do=delete"。如果这种资源的目的是为执行一个[[ruby:unsafe%20action][非安全的动作]]，那么，当使用一个[[ruby:safe%20request%20method][安全的请求方法]]来访问该资源的时候，资源所有者 *必须* 禁用或者拒绝该动作。否则的话，当[[ruby:automated%20processes][自动程序]]出于某种目的（为了链接维护，预取，生成搜索索引等）来对每个 URI 执行一个 GET 的时候，会导致不好的副作用。

#+BEGIN_QUOTE
译注：请求方法是否是安全的，其关注点在于该方法是否有改变资源的状态，而不是平常我们认为的安全性或保密性的概念。只要执行该请求方法后，资源的状态没有被改变，那么这个请求方法就是安全的（哪怕可能会导致数据泄漏、黑客入侵、硬件爆炸等），否则就是不安全的。换句话说，安全的请求方法都是“只读”的，并不会对资源造成任何“写入”，类似于编程语言中 Getter 的概念。
#+END_QUOTE

*** 4.2.2. 幂等方法 / Idempotent Methods
#+BEGIN_QUOTE
A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.
#+END_QUOTE

当执行多次相同的请求，与单次这样的请求，对服务器的预期效果是一样的，那么，该请求方法被认为是“[[ruby:idempotent][幂等的]]”。本规范所定义的请求方法中，幂等方法有：PUT、DELETE 以及所有[[id:2f967e3d-8694-430b-ad06-e748fd39b281][安全请求方法]]。

#+BEGIN_QUOTE
Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request.
#+END_QUOTE

跟安全的定义类似，请求方法的幂等性只适用于用户究竟请求到了什么，而服务器可以自由地单独记录每个请求的日志，保持一份版本管理历史，或者为每个幂等请求实现其他非幂等的副作用等等。

#+BEGIN_QUOTE
Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response. For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request. It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.
#+END_QUOTE

之所以要区分请求方法的幂等与否，是因为如果在客户端能够读取服务器的响应之前发生了通信失败，请求可以被自动重复发送（见[[id:0ca97f51-efc7-43d2-ab52-d998a92423e5][【RFC7230】6.3.1]]）。例如，如果客户端发送一个 PUT 请求，同时，之前建立好的连接在客户端接收到任何响应之前就被关闭了，那么，客户端可以建立一个新的连接并重试该幂等请求。客户端知道重复该请求会有相同的预期效果，即使原来的请求已经成功了。

*** 4.2.3. 可缓存方法 / Cacheable Methods
#+BEGIN_QUOTE
Request methods can be defined as "cacheable" to indicate that responses to them are allowed to be stored for future reuse; for specific requirements see [[[https://tools.ietf.org/html/rfc7234][RFC7234]]]. In general, safe methods that do not depend on a current or authoritative response are defined as cacheable; this specification defines GET, HEAD, and POST as cacheable, although the overwhelming majority of cache implementations only support GET and HEAD.
#+END_QUOTE

请求方法可以被定义为“[[ruby:cacheable][可缓存的]]”来指明：回应给它们的响应能够被保存起来，用于将来的复用，更具体的要求见【[[https://tools.ietf.org/html/rfc7234][RFC7234]]】。通常，不依赖某个[[ruby:current%20response][当前响应]]或[[ruby:authoritative%20response][权威响应]]的安全方法，就是[[ruby:cacheable][可缓存的]]方法。本规范定义了 GET、HEAD 和 POST 作为可缓存的方法，虽然绝大多数的[[ruby:cache%20implementations][缓存实现]]仅仅支持 GET 和 HEAD。

** 4.3. 方法的定义 / Method Definitions
*** 4.3.1. GET
:PROPERTIES:
:ID:       698bab73-07b1-4349-8a03-5a4a89d966d8
:END:
#+BEGIN_QUOTE
The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.
#+END_QUOTE

GET 方法请求获得目标资源的一种[[ruby:current%20selected%20representation][当前选定的 representation]]。GET 是信息获取的主要途径，同时，它也是几乎所有[[ruby:performance%20optimizations][性能优化]]的重点。因此，当人们谈及经由 HTTP 来获取某些可标识的信息的时候，他们一般指的是发起一个 GET 请求。

#+BEGIN_QUOTE
It is tempting to think of resource identifiers as remote file system pathnames and of representations as being a copy of the contents of such files. In fact, that is how many resources are implemented (see [[id:9195be98-bd4e-40ae-a5a0-6af920044f02][Section 9.1]] for related security considerations). However, there are no such limitations in practice. The HTTP interface for a resource is just as likely to be implemented as a tree of content objects, a programmatic view on various database records, or a gateway to other information systems. Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly. Regardless, only the origin server needs to know how each of its resource identifiers corresponds to an implementation and how each implementation manages to select and send a current representation of the target resource in a response to GET.
#+END_QUOTE

我们很容易想到将[[ruby:resource%20identifiers][资源标识]]符作为远程文件系统的路径名称，以及将 representations 作为这些远程文件的内容的一种拷贝。事件上，这也是许多资源的实现方式（安全相关注意事项见[[id:9195be98-bd4e-40ae-a5a0-6af920044f02][章节 9.1]]）。然而，实际上资源并没有被限制为只有这一种实现方式。资源的 HTTP 接口也有可能被实现为一种[[ruby:content%20object%20tree][内容对象树]][fn:2]、一种基于各种数据库记录的可编程视图、一种到其他信息系统的网关等等。甚至当 URI 的映射机制被捆绑到一种文件系统上，也可以将源服务器配置为将文件连同请求一起作为执行的输入，而输出结果则作为 representation 并发送给请求，而不是直接传输文件本身。无论如何，只有源服务器需要了解它的每个资源标识符如何对应到某种实现，以及每种实现如何在回应到 GET 的响应里达成选择和发送目标资源的某种 current representation。

#+BEGIN_QUOTE
A client can alter the semantics of GET to be a "range request", requesting transfer of only some part(s) of the selected representation, by sending a =Range= header field in the request ([[[https://tools.ietf.org/html/rfc7233][RFC7233]]]).
#+END_QUOTE

客户端能够将 GET 的语义改变为一种“[[ruby:range%20request][范围请求]]”，通过在其发送的请求报文中带有一个 =Range= 报头域，来实现只对已选择的 representation 中的某（几）部分进行请求传输（【[[https://tools.ietf.org/html/rfc7233][RFC7233]]】）。

#+BEGIN_QUOTE
A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.
#+END_QUOTE

在 GET 请求报文里的有效载荷是没有定义任何语义的，如果在 GET 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

#+BEGIN_QUOTE
The response to a GET request is cacheable; a cache *MAY* use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the =Cache-Control= header field ([[https://tools.ietf.org/html/rfc7234#section-5.2][Section 5.2]] of [RFC7234]).
#+END_QUOTE

回应给 GET 请求的响应是[[ruby:cacheable][可缓存的]]，[[ruby:cache][缓存]] *可以* 使用它来满足随后的 GET 和 HEAD 请求，除非 =Cache-Control= 报头域另有指定（[[https://tools.ietf.org/html/rfc7234#section-5.2][【RFC7234】章节 5.2]]）。

*** 4.3.2. HEAD
:PROPERTIES:
:ID:       d00f1692-2d40-4b09-a634-9c87fce07bc4
:END:
The HEAD method is identical to GET except that the server *MUST NOT* send a message body in the response (i.e., the response terminates at the end of the header section). The server *SHOULD* send the same header fields in response to a HEAD request as it would have sent if the request had been a GET, except that the payload header fields ([[id:4c395bab-baa6-4895-b677-5daa1584da6e][Section 3.3]]) *MAY* be omitted. This method can be used for obtaining metadata about the selected representation without transferring the representation data and is often used for testing hypertext links for validity, accessibility, and recent modification.

HEAD 方法几乎与 GET 方法等价，除了服务器 *禁止* 在回应 HEAD 请求的响应报文里带有[[ruby:message%20body][报文正文]]（也就是说，响应报文在[[ruby:header%20section][报头块]]之后就结束了）。服务器回应给 GET 请求的响应报文里带有什么报头域，回应给 HEAD 请求的响应报文里就 *应当* 带有什么报头域，除了[[ruby:payload%20header%20fields][有效载荷报头域]]（[[id:4c395bab-baa6-4895-b677-5daa1584da6e][章节 3.3]]） *可以* 被忽略以外。HEAD 方法能够用于在不需要传输 representation data 的情况下获取关于[[ruby:selected%20representation][已选定的 representation]]（[[id:7dd837af-fd6a-4918-9c62-cf12a4c31522][章节 3]]） 的元数据。同时，它也常用于测试[[ruby:hypertext%20links][超链接]]的正确性、可访问性和最近是否有修改。

A payload within a HEAD request message has no defined semantics; sending a payload body on a HEAD request might cause some existing implementations to reject the request.

在 HEAD 请求报文里的有效载荷是没有定义任何语义的，如果在 HEAD 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

The response to a HEAD request is cacheable; a cache *MAY* use it to satisfy subsequent HEAD requests unless otherwise indicated by the =Cache-Control= header field ([[https://tools.ietf.org/html/rfc7234#section-5.2][Section 5.2]] of [RFC7234]). A HEAD response might also have an effect on previously cached responses to GET; see [[https://tools.ietf.org/html/rfc7234#section-4.3.5][Section 4.3.5]] of [RFC7234].

回应给 HEAD 请求的响应是[[ruby:cacheable][可缓存的]]，[[ruby:cache][缓存]] *可以* 使用它来满足随后的 HEAD 请求，除非 =Cache-Control= 报头域另有指定（[[https://tools.ietf.org/html/rfc7234#section-5.2][【RFC7234】章节 5.2]]）。HEAD 响应还可能影响到之前已缓存的 GET 响应，见[[https://tools.ietf.org/html/rfc7234#section-4.3.5][【RFC7234】章节 4.3.5]]。

*** 4.3.3. POST
:PROPERTIES:
:ID:       d672d01b-615b-416a-a750-0442a6901ed0
:END:
#+BEGIN_QUOTE
The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others):

- Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;
- Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;
- Creating a new resource that has yet to be identified by the origin server; and
- Appending data to a resource's existing representation(s).
#+END_QUOTE

POST 方法请求目标资源按照资源自身的具体语义来处理封装在请求报文里的 representation。例如，POST 是用于以下（或其他）功能。

- 为某个数据处理进程提供[[ruby:a%20block%20of%20data][数据块]]，例如某个 HTML 表单的域；
- 发表一份报文到某个电子公告栏、新闻组、邮件列表、博客或者类似的文章组里；
- 创建一种还没有被源服务器所标识的新的资源；以及
- 附加数据到某个资源的现有 representation(s) 中。

#+BEGIN_QUOTE
An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification might be received in a response to POST (the exceptions being =206 (Partial Content)=, =304 (Not Modified)=, and =416 (Range Not Satisfiable)=).
#+END_QUOTE

源服务器根据 POST 请求的处理结果来选择一种恰当的状态码来指明响应的语义，几乎所有本规范定义的状态码都可以用在回应给 POST 的响应里，除了 =206 (Partial Content)=、=304 (Not Modified)= 以及 =416 (Range Not Satisfiable)= 是例外。

#+BEGIN_QUOTE
If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server *SHOULD* send a =201 (Created)= response containing a =Location= header field that provides an identifier for the primary resource created ([[id:bc2baf29-0bf6-4816-865c-3d33f5fe38e3][Section 7.1.2]]) and a representation that describes the status of the request while referring to the new resource(s).
#+END_QUOTE

如果一个或多个资源在源服务器上被创建，来作为对成功处理某个 POST 请求的结果，那么，源服务器 *应当* 发送一个 =201 (Created)= 响应，且该响应需带有一个 =Location= 报头域来提供一种标识符，来对应被创建的主要资源（[[id:bc2baf29-0bf6-4816-865c-3d33f5fe38e3][章节 7.1.2]]）；以及需要包含一种 representation，来描述当引用新资源的时候请求的状态。

#+BEGIN_QUOTE
Responses to POST requests are only cacheable when they include explicit freshness information (see [[https://tools.ietf.org/html/rfc7234#section-4.2.1][Section 4.2.1]] of [RFC7234]). However, POST caching is not widely implemented. For cases where an origin server wishes the client to be able to cache the result of a POST in a way that can be reused by a later GET, the origin server *MAY* send a =200 (OK)= response containing the result and a =Content-Location= header field that has the same value as the POST's effective request URI ([[id:91650144-4bfc-4362-b628-f96578a5c756][Section 3.1.4.2]]).
#+END_QUOTE

回应给 POST 请求的响应，仅当它们包含明确的[[ruby:freshness%20information][新鲜信息]]时，才是[[ruby:cacheable][可缓存的]]（见[[https://tools.ietf.org/html/rfc7234#section-4.2.1][【RFC7234】章节 4.2.1]]）。然而，对 POST 响应的缓存并没有被广泛实现。如果源服务器希望客户端以一种之后的 GET 能够复用的方式使客户端能够缓存 POST 的结果，面对这种情况，源服务器 *可以* 发送一个 =200 (OK)= 响应来包含该结果，并且，该响应还需带有与该 POST 的有效请求 URI 相同的值的一个 =Content-Location= 报头域（[[id:91650144-4bfc-4362-b628-f96578a5c756][章节 3.1.4.2]]）。

#+BEGIN_QUOTE
If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server *MAY* redirect the user agent to that resource by sending a =303 (See Other)= response with the existing resource's identifier in the =Location= field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.
#+END_QUOTE

如果处理某个 POST 请求的结果等价于某个现有资源的某种 representation 的话，源服务器 *可以* 发送一个 =303 (See Other)= 响应到用户代理，同时，响应里带有 =Location= 报头域，其值为该现有资源的标识符，让用户代理进行重定向。这样做的好处是可以向用户代理提供一种资源标识符，以及可以通过一种更适合缓存共享的方法来传输 representation，但坏处是可能需要一个额外的请求，如果用户代理还没有缓存过该 representation 的话。

*** 4.3.4. PUT
:PROPERTIES:
:ID:       28f69be8-26e9-4dd7-930e-7c683d7bcf8a
:END:
#+BEGIN_QUOTE
The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload. A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.
#+END_QUOTE

PUT 方法请求源服务器使用封装在请求报文有效载荷内的 representation 所定义的状态，来[[ruby:create][新建]]或[[ruby:replace][替换]]目标资源的状态。如果向目标资源[[ruby:successful%20PUT%20request][成功 PUT]] 了一个给定的 representation，那么我们可以认为，对相同目标资源的后续 GET 请求将会被回应一个 =200 (OK)= 响应，同时响应会携带一个（与之前 PUT 的 representation）等价的 representation。然而，不能保证这种状态的改变能够被客户端所观察到，这是因为在源服务器接收到任何来自该客户端的后续的 GET 请求之前，目标资源就可能被按照其他用户代理并行地执行动作，也有可能受到源服务器的动态处理。对 PUT 请求的[[ruby:successful%20response][成功响应]]，仅仅意味着在源服务器处理该请求的时候，用户代理达成了它的意图。

#+BEGIN_QUOTE
If the target resource does not have a current representation and the PUT successfully creates one, then the origin server *MUST* inform the user agent by sending a =201 (Created)= response. If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server *MUST* send either a =200 (OK)= or a =204 (No Content)= response to indicate successful completion of the request.
#+END_QUOTE

如果目标资源并没有 current representation，并且 PUT 成功地创建了一种 representation，那么，源服务器 *必须* 回应一个 =201 (Created)= 响应来告知用户代理。如果目标资源已有 current representation 并且该 representation 的状态被封装在 PUT 请求内的 representation 成功地更改了，那么，源服务器 *必须* 回应一个 =200 (OK)= 或者一个 =204 (No Content)= 来指明请求已经成功完成了。

#+BEGIN_QUOTE
译注：由此可见，PUT 会改变 representation 的状态，因此，它不是一个[[ruby:safe%20method][安全方法]]。而 PUT 是一个[[ruby:idempotent%20method][幂等方法]]，由上述可知，多次相同的 PUT 请求与一次 PUT 请求对 representation 的影响是一样的。试想一下，一个 PUT 请求，试图将用户 A 的年龄值更新为 18，无论发送一次还是多次这样的请求，用户 A 的年龄值最终依然是 18。
#+END_QUOTE

#+BEGIN_QUOTE
An origin server *SHOULD* ignore unrecognized header fields received in a PUT request (i.e., do not save them as part of the resource state).
#+END_QUOTE

源服务器 *应当* 忽略掉接收自某个 PUT 请求的[[ruby:unrecognized%20header%20fields][未识别的报头域]]（也就是说，不要保存它们作为资源状态的一部分）。

#+BEGIN_QUOTE
An origin server *SHOULD* verify that the PUT representation is consistent with any constraints the server has for the target resource that cannot or will not be changed by the PUT. This is particularly important when the origin server uses internal configuration information related to the URI in order to set the values for representation metadata on GET responses. When a PUT representation is inconsistent with the target resource, the origin server *SHOULD* either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The =409 (Conflict)= or =415 (Unsupported Media Type)= status codes are suggested, with the latter being specific to constraints on =Content-Type= values.
#+END_QUOTE

源服务器 *应当* 校验 PUT 的 representation 是否符合服务器对目标资源的任何[[ruby:constraints][约束]]，确保它们不能或不会被 PUT 所改变。当源服务器使用 URI 相关的内部配置信息来对回应给 GET 的响应的 representation 的元数据设置值的时候，这种校验是非常重要的。当一个 PUT 请求内的 representation 不符合[[ruby:target%20resource][目标资源]]的约束时，源服务器 *应当* 要不[[ruby:transform][转换]]这个 representation 或者改变资源的配置以使其符合约束条件；要不回应一种恰当的错误报文，包含足够的信息来解释为什么该 representation 并不适合。建议使用 =409 (Conflict)= 或者 =415 (Unsupported Media Type)= 状态码，而对于后者（=415 (Unsupported Media Type)=），带有 =Content-Type= 报头域以指定具体的约束类型。

#+BEGIN_QUOTE
For example, if the target resource is configured to always have a =Content-Type= of "text/html" and the representation being PUT has a =Content-Type= of "image/jpeg", the origin server ought to do one of:

- reconfigure the target resource to reflect the new media type;
- transform the PUT representation to a format consistent with that of the resource before saving it as the new resource state; or,
- reject the request with a =415 (Unsupported Media Type)= response indicating that the target resource is limited to "text/html", perhaps including a link to a different resource that would be a suitable target for the new representation.

#+END_QUOTE

例如，如果目标资源被配置为总是带有一个 "text/html" 的 =Content-Type=，并且 PUT 请求内的 representation 带有一个 "image/jpeg" 的 =Content-Type=，那么，源服务器的行为应该是以下其中之一：

- 将目标资源重新配置以体现该种新的媒体类型；
- 在保存 PUT 请求的 representation 作为目标资源的新状态之前，先将其[[ruby:transform][转换]]为一种符合资源约束的格式；或者
- 回应一个 =415 (Unsupported Media Type)= 响应来拒绝该请求并指明目标资源被限定为 "text/html"，响应内可能还包含一条[[ruby:link][链接]]，该链接指向到其他可能适用于该请求目标的资源。

#+BEGIN_QUOTE
HTTP does not define exactly how a PUT method affects the state of an origin server beyond what can be expressed by the intent of the user agent request and the semantics of the origin server response. It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP. It does not define how resource state is "stored", nor how such storage might change as a result of a change in resource state, nor how the origin server translates resource state into representations. Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server.
#+END_QUOTE

HTTP 并没有定义 PUT 方法究竟是如何影响源服务器的状态的，是因为这超出了用户代理的请求意图以及源服务器的响应语义所能表达的。HTTP 并没有定义[[ruby:resource][资源]]究竟是什么，在任何意义上，这超出了由 HTTP 所提供的接口所能表达的。HTTP 并没有定义[[ruby:resource%20state][资源的状态]]是被如何“[[ruby:stored][存储]]”的，也没有定义资源状态上的改变会导致这种存储如何改变，也没有定义源服务器是如何将资源的状态[[ruby:translate][翻译]]成[[ruby:representations][资源的表示]]的。一般而言，在资源接口后面的所有实现细节都被服务器有意地隐藏起来。

#+BEGIN_QUOTE
An origin server *MUST NOT* send a validator header field ([[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][Section 7.2]]), such as an =ETag= or =Last-Modified= field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the body (i.e., the resource's new representation data is identical to the representation data received in the PUT request) and the validator field value reflects the new representation. This requirement allows a user agent to know when the representation body it has in memory remains current as a result of the PUT, thus not in need of being retrieved again from the origin server, and that the new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 5.2).
#+END_QUOTE

源服务器 *禁止* 在回应给 PUT 的[[ruby:successful%20response][成功响应]]里带有任何[[ruby:validator%20header%20field][验证器报头域]]（[[id:efd98bfe-3f3c-4d75-9fa9-041a5af2f917][章节 7.2]]），例如 =ETag= 或者 =Last-Modified= 报头域，除非请求的 representation data 是保存在没有经过任何[[ruby:transformation][编码转换]]的报文正文（有效载荷）里（也就是说，响应内的新 representation data 是等价于接收自 PUT 请求内的 representation data），并且该验证器报头域反映的是新是 representation。上述这种要求使得用户代理能够知道这个在自己内存中的 representation 在什么时间内可以[[ruby:remain%20current][保持最新（保持为 current 状态）]]，由此知道其是否仍然可以继续作为 PUT 请求的结果而不需要从源服务器上再次获取，以及在响应内接收到的新验证器能够被用于将来的[[ruby:conditional%20requests][条件请求]]以避免新[[ruby:accidental%20overwrite][意外覆盖]]（章节 5.2）。

#+BEGIN_QUOTE
译注：未经过任何编码转换的[[ruby:message%20body][报文正文]]等价于[[ruby:payload%20body][有效载荷体]]，见[[id:1754823B-D0BC-410F-A17B-E7ADA1AA79BC][【RFC7230】章节 3.3.1]]。
#+END_QUOTE

#+BEGIN_QUOTE
The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation. The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the target resource. Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.
#+END_QUOTE

POST 与 PUT 两者的根本区别在于它们对封装的 representation 的不同意图。POST 所请求目标资源是意图依据该资源自身的语义来[[ruby:handle][处置]]请求内的 representation。而在 PUT 请求内的 representation 是定义为替换目标资源的状态的。因此，PUT 的意图是[[ruby:idempotent][幂等的]]且对[[ruby:intermediaries][中间人]]是[[ruby:visible][可见的]]，虽然只有源服务器了解其确切的作用。

#+BEGIN_QUOTE
Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, *SHOULD* be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server *MUST* send an appropriate =3xx (Redirection)= response; the user agent *MAY* then make its own decision regarding whether or not to redirect the request.
#+END_QUOTE

PUT 请求的[[ruby:proper%20interpretation][合理解释]]是相信用户代理是知道哪个目标才是它所期望的。一种为客户端选择恰当的 URI 的服务，在接收到一种[[ruby:state-changing%20request][会引起状态变化的请求]]以后，*应当* 被实现为使用 POST 方法而不是 PUT 方法。如果源服务器不将 PUT 所请求的状态改变到目标资源上，而是希望将其应用到另外一个不同的资源上，例如当资源被迁移到另一个不同的 URI 上了，那么，源服务器 *必须* 回应一个恰当的 =3xx (Redirection)= 响应给用户代理，然后，用户代理 *可以* 自行决定是否对请求进行[[ruby:redirect][重定向]]。

#+BEGIN_QUOTE
A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying "the current version" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on "the current version" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.
#+END_QUOTE

应用到[[ruby:target%20resource][目标资源]]的 PUT 请求可能会对其他资源带来[[ruby:side%20effects][副作用]]。例如，一篇文章可能会有一个用于标识“[[ruby:the%20current%20version][当前版本]]”（是一种资源）的 URI，独立于其他每一个标识特定版本的 URIs，不同的资源在某处共享同一种状态来作为“当前版本”所对应的资源。成功地向“当前版本”这个 URI 发起了一个 PUT 请求以后，可能除了改变目标资源的状态之外，还会创建额外一个“新版本”的资源，而且还有可能需要添加链接到相关的资源之中。 

#+BEGIN_QUOTE
An origin server that allows PUT on a given target resource *MUST* send a =400 (Bad Request)= response to a PUT request that contains a =Content-Range= header field ([[https://tools.ietf.org/html/rfc7233#section-4.2][Section 4.2]] of [RFC7233]), since the payload is likely to be partial content that has been mistakenly PUT as a full representation. Partial content updates are possible by targeting a separately identified resource with state that overlaps a portion of the larger resource, or by using a different method that has been specifically defined for partial updates (for example, the PATCH method defined in [[[https://tools.ietf.org/html/rfc5789][RFC5789]]]).
#+END_QUOTE

对于允许向给定目标资源发送 PUT 请求的源服务器来说，如果某个 PUT 请求包含有一个 =Content-Range= 报头域（[[https://tools.ietf.org/html/rfc7233#section-4.2][【RFC7233】章节 4.2]]），源服务器 *必须* 向该请求回应一个 =400 (Bad Request)= 响应，这是因为该请求的[[ruby:payload][有效载荷]]很有可能只是[[ruby:partial%20content][部分内容]]而被错误地当作一个完整的 representation。[[ruby:partial%20content%20updates][部分内容的更新]]很可能是通过使用[[ruby:larger%20resource][大型资源]]的一部分相重叠的状态来定位一个单独标识的资源，或者通过使用另外一种被定义为专门用于[[ruby:partial%20updates][部分更新]]的方法（例如，定义于【[[https://tools.ietf.org/html/rfc5789][RFC5789]]】里的 PATCH 方法）。

#+BEGIN_QUOTE
Responses to the PUT method are not cacheable. If a successful PUT request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see Section 4.4 of [RFC7234]).
#+END_QUOTE

回应给 PUT 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。如果一个[[ruby:successful%20PUT%20request][成功的 PUT 请求]]穿过一个[[ruby:cache][缓存]]，而该缓存已经存储（缓存）了该 PUT 请求的有效请求 URI 所对应的一个或多个响应（也就是说，缓存命中了这个 PUT 请求），那么这些已存储的（已缓存的）响应将会[[ruby:be%20invalidated][被失效]]（见【RFC7234】章节 4.4）。

*** 4.3.5. DELETE
:PROPERTIES:
:ID:       9e649fa9-0f7f-40d0-adef-8af6a6f62e80
:END:
#+BEGIN_QUOTE
The DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the =rm= command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.
#+END_QUOTE

DELETE 方法请求源服务器移除[[ruby:target%20resource][目标资源]]与它[[ruby:current%20functionality][当前的功能]]之间的关联。实际上，该方法与 UNIX 中的 =rm= 命令非常类似，DELETE 表达了一种作用在映射到源服务器的 URI 之上的删除操作，而不是表达一种删除之前相关联的信息的期望。

#+BEGIN_QUOTE
If the target resource has one or more current representations, they might or might not be destroyed by the origin server, and the associated storage might or might not be reclaimed, depending entirely on the nature of the resource and its implementation by the origin server (which are beyond the scope of this specification). Likewise, other implementation aspects of a resource might need to be deactivated or archived as a result of a DELETE, such as database or gateway connections. In general, it is assumed that the origin server will only allow DELETE on resources for which it has a prescribed mechanism for accomplishing the deletion.
#+END_QUOTE

如果目标资源有一个或多个 current representations，它们可能会也可能不会被源服务器所销毁，另外，它们所关联的存储可能会也可能不会被回收，这完全取决于资源的性质以及服务器对资源的[[ruby:implementation][实现]]（已经超出了本规范的范畴）。同样，还可能需要去[[ruby:deactivate][失效]]或[[ruby:archive][归档]]资源实现的其他方面，来作为一个 DELETE 操作的结果，比如数据库或者网关连接。总之，我们假设源服务器只会允许对这些资源进行 DELETE：具有某种规定机制来完成删除操作的资源。

#+BEGIN_QUOTE
Relatively few resources allow the DELETE method — its primary use is for remote authoring environments, where the user has some direction regarding its effect. For example, a resource that was previously created using a PUT request, or identified via the =Location= header field after a =201 (Created)= response to a POST request, might allow a corresponding DELETE request to undo those actions. Similarly, custom user agent implementations that implement an authoring function, such as revision control clients using HTTP for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository.
#+END_QUOTE

相对较少的资源会允许 DELETE 方法，它主要应用在用户会有某些关于它的影响效果的指导的[[ruby:remote%20authoring%20environments][远程编辑环境]]中。例如，在以前使用一个 PUT 请求来创建好的某个资源，或者是在回应给 POST 请求的一个 =201 (Created)= 响应以后，该响应里的 =Location= 报头域所标识的某个资源，可能会允许一个对应的 DELETE 请求来[[ruby:undo][撤消]]这些动作。类似的，实现某种[[ruby:authoring%20function][编辑方法]]的[[ruby:custom%20user%20agent%20implementations][定制的用户代理实现]]，比如使用 HTTP 来进行远程操作的[[ruby:revision%20control%20clients][版本管理客户端]]，可能会基于“服务器的 [[ruby:URI%20space][URI 空间]]是经过精心设计来对应某个版本仓库”的这种假设来使用 DELETE。

#+BEGIN_QUOTE
译注：URI space 参考【[[https://tools.ietf.org/html/rfc5785][RFC5785]]】Defining Well-Known Uniform Resource Identifiers (URIs)
#+END_QUOTE

#+BEGIN_QUOTE
If a DELETE method is successfully applied, the origin server *SHOULD* send a =202 (Accepted)= status code if the action will likely succeed but has not yet been enacted, a =204 (No Content)= status code if the action has been enacted and no further information is to be supplied, or a =200 (OK)= status code if the action has been enacted and the response message includes a representation describing the status.
#+END_QUOTE

如果成功执行了一次 DELETE 方法，如果该动作可能会成功但确定的结果还未[[ruby:enacted][出现]]，源服务器 *应当* 回应一个 =202 (Accepted)= 响应；如果该动作的结果已经出现了并且服务器不会再提供更多的信息，*应当* 回应一个 =204 (No Content)= 响应；或者如果该动作的结果已经出现了并且响应会包含一个 representation 来描述资源的状态，该响应的状态码 *应当* 是 =200 (OK)= 。

#+BEGIN_QUOTE
A payload within a DELETE request message has no defined semantics; sending a payload body on a DELETE request might cause some existing implementations to reject the request.
#+END_QUOTE

在 DELETE 请求里的[[ruby:payload][有效载荷]]并没有定义任何的语义，如果在 DELETE 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

#+BEGIN_QUOTE
Responses to the DELETE method are not cacheable. If a DELETE request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see [[https://tools.ietf.org/html/rfc7234#section-4.4][Section 4.4]] of [RFC7234]).
#+END_QUOTE

回应给 DELETE 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。如果一个 DELETE 请求穿过一个[[ruby:cache][缓存]]，而该缓存已经存储（缓存）了该 DELETE 请求的有效请求 URI 所对应的一个或多个响应（也就是说，缓存命中了这个 DELETE 请求），那么这些已存储的（已缓存的）响应将会[[ruby:be%20invalidated][被失效]]（见[[https://tools.ietf.org/html/rfc7234#section-4.4][【RFC7234】章节 4.4]]）。

*** 4.3.6. CONNECT
:PROPERTIES:
:ID:       630ab908-5d8e-400b-bed4-f6973b8c1549
:END:
#+BEGIN_QUOTE
The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed. Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security, [[[https://tools.ietf.org/html/rfc5246][RFC5246]]]).
#+END_QUOTE

CONNECT 方法请求让对方（接收端）与[[ruby:request-target][请求目标]]所标识的源服务器[[ruby:establish][建立]]一个[[ruby:tunnel][隧道]]，并且如果建立成功以后，将接收端的行为限制为双向[[ruby:blind%20forwarding][盲目转发]]数据包，直到隧道被关闭为止。隧道常常用于创建一种穿越一个或多个[[ruby:proxies][代理]]的[[ruby:end-to-end][端到端]]的[[ruby:virtual%20connection][虚拟连接]]，然后能够安全使用 TLS（Transport Layer Security，【[[https://tools.ietf.org/html/rfc5246][RFC5246]]】）。

#+BEGIN_QUOTE
译注：需要注意的是，并不是 CONNECT 请求的发送端与源服务器建立隧道，而是 CONNECT 接收端与源服务器建立隧道，这个要清楚。
#+END_QUOTE

#+BEGIN_QUOTE
CONNECT is intended only for use in requests to a proxy. An origin server that receives a CONNECT request for itself *MAY* respond with a =2xx (Successful)= status code to indicate that a connection is established. However, most origin servers do not implement CONNECT.
#+END_QUOTE

CONNECT 只能用在向代理发送的请求里。源服务器接收到一个发送给它自己的 CONNECT 请求时，*可以* 回应一个 =2xx (Successful)= 状态码来表明连接已被建立好。但是，大多数源服务器并没有[[ruby:implement][实现]] CONNECT。

#+BEGIN_QUOTE
A client sending a CONNECT request *MUST* send the authority form of request-target ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]); i.e., the request-target consists of only the host name and port number of the tunnel destination, separated by a colon. For example,
#+END_QUOTE

发送 CONNECT 请求的客户端 *必须* 以 authority-form（权威形式）的形式来发送[[ruby:request-target][请求目标]]（[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]），也就是说，请求目标仅由隧道终点的[[ruby:host%20name][主机名称]]以及[[ruby:port%20number][端口号]]组成，以冒号分隔。例如：

#+BEGIN_EXAMPLE
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80

#+END_EXAMPLE

#+BEGIN_QUOTE
译注：上例是有一个[[ruby:blank%20line][空行]]的，表示[[ruby:header%20section][报头块]]结束，报文结构的更多详情见[[id:6e9516fa-cde2-4693-b1e1-e763776d3186][【RFC7230】章节 3]]。
#+END_QUOTE

#+BEGIN_QUOTE
The recipient proxy can establish a tunnel either by directly connecting to the request-target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy. Any =2xx (Successful)= response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the blank line that concludes the successful response's header section; data received after that blank line is from the server identified by the request-target. Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.
#+END_QUOTE

作为接收端的[[ruby:proxy][代理]]能够通过以下方式建立一个隧道：直接连接到请求目标；或者，如果该代理被配置为使用另一个代理的话，转发该 CONNECT 请求到下一个[[ruby:inbound%20proxy][入站代理]]。任何 =2xx (Successful)= 响应都表明发送端（以及所有入站代理）将会在成功响应的[[ruby:header%20section][报头块]]末尾的空行（该空行表示报头块结束）以后，马上切换为[[ruby:tunnel%20mode][隧道模式]]，而在这个空行之后所接收到的数据，是来自由[[ruby:request%20target][请求目标]]所标识的源服务器的。其他任何不是表示成功的响应则表明这个隧道还没有形成，该连接仍然受到 HTTP 支配（而不是由隧道所扩展的协议来支配，例如 TLS）。

#+BEGIN_QUOTE
这里涉及到 HTTP 的报文结构和参与的多种角色，如果对这些概念还不够熟悉的话，请先浏览【[[file:RFC7230.org][RFC7230]]】里的章节 2 和 3。
#+END_QUOTE

#+BEGIN_QUOTE
A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary *MUST* attempt to send any outstanding data that came from the closed side to the other side, close both connections, and then discard any remaining data left undelivered.
#+END_QUOTE

当[[ruby:tunnel%20intermediary][隧道中间人]]检测到隧道两端都已关闭了连接的时候，隧道被关闭。中间人 *必须* 尝试发送所有[[ruby:outstanding%20data][未偿付的数据]]，从被关闭的一端发送到另一端，然后关闭两端的连接，最后丢弃掉任何还[[ruby:undelivered][未投递出去]]的数据。

#+BEGIN_QUOTE
Proxy authentication might be used to establish the authority to create a tunnel. For example,
#+END_QUOTE

[[ruby:proxy%20authentication][代理认证]]可能被用来[[ruby:establish%20authority][确立权威]]来创建一个隧道，例如：

#+BEGIN_EXAMPLE
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=

#+END_EXAMPLE

#+BEGIN_QUOTE
There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic. For example, a CONNECT to a request-target of "example.com:25" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support CONNECT *SHOULD* restrict its use to a limited set of known ports or a configurable whitelist of safe request targets.
#+END_QUOTE

向任意的服务器建立隧道会有严重的风险，特别是当隧道的终点是一个不作为[[ruby:Web%20traffic][网站流量]]的 TCP [[ruby:well-known%20port][知名端口]]或者[[ruby:reserved%20port][保留端口]]的时候。例如，请求目标为 "example.com:25" 的 CONNECT 请求会建议代理连接到用于 SMTP 流量的保留端口上，如果允许这样做，就会欺骗代理去[[ruby:relaying][中转]]垃圾邮件。因此，支持 CONNECT 的代理 *应当* 将 CONNECT 的使用限制到一个已知的有限的端口集合上，或者一个安全的可配置的请求目标白名单上。

#+BEGIN_QUOTE
A server *MUST NOT* send any =Transfer-Encoding= or =Content-Length= header fields in a =2xx (Successful)= response to CONNECT. A client *MUST* ignore any =Content-Length= or =Transfer-Encoding= header fields received in a successful response to CONNECT.
#+END_QUOTE

服务器 *禁止* 在一个回应给 CONNECT 的 =2xx (Successful)= 响应中带有任何 =Transfer-Encoding= 或者 =Content-Length= 报头域。客户端 *必须* 在其接收到的回应给 CONNECT 的成功响应里，忽略掉任何 =Content-Length= 或者 =Transfer-Encoding= 报头域。

#+BEGIN_QUOTE
A payload within a CONNECT request message has no defined semantics; sending a payload body on a CONNECT request might cause some existing implementations to reject the request.
#+END_QUOTE

在 CONNECT 请求报文里的有效载荷是没有定义任何语义的，如果在 CONNECT 请求里带有一个有效载荷可能会导致某些现有的[[ruby:implementations][实现]]拒绝该请求。

#+BEGIN_QUOTE
Responses to the CONNECT method are not cacheable.
#+END_QUOTE

回应给 CONNECT 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。

*** 4.3.7. OPTIONS
:PROPERTIES:
:ID:       f659b35f-7510-4961-ad3a-3ab1b312a681
:END:
#+BEGIN_QUOTE
The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action.
#+END_QUOTE

OPTIONS 方法请求获得可用于目标资源的[[ruby:communication%20options][通信选项]]的有关信息，这些信息是在源服务器或者介于客户端和源服务器之间的中间人上的。本方法允许客户端在没有对资源执行相关动作的情况下，就可以确定与资源有关的选项和（或者）要求，或者服务器的功能。

#+BEGIN_QUOTE
An OPTIONS request with an asterisk ("*") as the request-target ([[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][Section 5.3]] of [RFC7230]) applies to the server in general rather than to a specific resource. Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof).
#+END_QUOTE

如果要向服务器执行 OPTIONS 请求，一般是使用一个星号（"*"），而不是一个具体的资源，来作为请求目标（[[id:16a8fba9-40f8-4b2c-ba5f-2f6522362c3a][【RFC7230】章节 5.3]]）。这是因为服务器的通信选项一般依赖于资源，"*" 请求仅作为方法的一种 "ping" 或者“空操作” 时才有用处，除了允许客户端来测试服务器的功能以外，它并没有做任何其他事情。例如，用它来测试一个代理是否遵循 HTTP/1.1 规范。

#+BEGIN_QUOTE
If the request-target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.
#+END_QUOTE

如果请求目标不是使用[[ruby:asterisk-form][星号形式]]，那么，OPTIONS 请求所应用到的选项是可用在与目标资源通信的。

#+BEGIN_QUOTE
A server generating a successful response to OPTIONS *SHOULD* send any header fields that might indicate optional features implemented by the server and applicable to the target resource (e.g., =Allow=), including potential extensions not defined by this specification. The response payload, if any, might also describe the communication options in a machine or human-readable representation. A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP. A server *MUST* generate a =Content-Length= field with a value of "0" if no payload body is to be sent in the response.
#+END_QUOTE

服务器在向 OPTIONS 生成一个成功响应的时候，*应当* 带有所有可能指明以下信息的报头域：由服务器所实现的可选功能，并且这些可选功能是可作用于目标资源的（例如，=Allow=）。这些报头域还应当包括那些未定义在本规范里的扩展报头域，如果有的话。如果响应里包含有效载荷，那么还可能描述了机器的通信选项，或者供人类阅读的 representation 的通信选项。对于这样一种 representation，本规范并没有定义一种标准格式，但可能会在将来的 HTTP 扩展中进行定义。服务器 *禁止* 生成带有一个 "0" 值的 =Content-Length= 报头域，如果该响应没有包含有效载荷的话。

#+BEGIN_QUOTE
A client *MAY* send a =Max-Forwards= header field in an OPTIONS request to target a specific recipient in the request chain (see [[id:4c0e6435-a276-48fb-8cb8-32b8ef5a2780][Section 5.1.2]]). A proxy *MUST NOT* generate a =Max-Forwards= header field while forwarding a request unless that request was received with a =Max-Forwards= field.
#+END_QUOTE

客户端 *可以* 在一个 OPTIONS 请求中带有一个 =Max-Forwards= 报头域，以便在请求链路中对一个具体的接收端进行定位（见[[id:4c0e6435-a276-48fb-8cb8-32b8ef5a2780][章节 5.1.2]]）。代理 *禁止* 在转发请求的时候生成一个 =Max-Forwards= 报头域，除非该请求本身已带有一个 =Max-Forwards= 报头域。

#+BEGIN_QUOTE
A client that generates an OPTIONS request containing a payload body *MUST* send a valid =Content-Type= header field describing the representation media type. Although this specification does not define any use for such a payload, future extensions to HTTP might use the OPTIONS body to make more detailed queries about the target resource.
#+END_QUOTE

客户端生成一个 OPTIONS 请求的时候，如果该请求包含一个有效载荷，那么，该请求 *必须* 带有一个有效的 =Content-Type= 报头域来描述 representation 的媒体类型。虽然本规范并没有对这样一种有效载荷的用途进行过任何定义，但将来的 HTTP 扩展中可能会使用 OPTIONS 请求的报文正文来携带目标资源有关的更细致的查询信息。

#+BEGIN_QUOTE
Responses to the OPTIONS method are not cacheable.
#+END_QUOTE

回应给 OPTIONS 方法的响应是[[ruby:not%20cacheable][不可缓存的]]。

*** 4.3.8. TRACE
:PROPERTIES:
:ID:       bdc9e3b4-bac3-46c5-9319-31f7f4d6469d
:END:
#+BEGIN_QUOTE
The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request *SHOULD* reflect the message received, excluding some fields described below, back to the client as the message body of a =200 (OK)= response with a =Content-Type= of "message/http" (Section 8.3.1 of [RFC7230]). The final recipient is either the origin server or the first server to receive a =Max-Forwards= value of zero (0) in the request (Section 5.1.2).
#+END_QUOTE

#+BEGIN_QUOTE
A client *MUST NOT* generate header fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials [RFC7235] or cookies [RFC6265] in a TRACE request. The final recipient of the request *SHOULD* exclude any request header fields that are likely to contain sensitive data when that recipient generates the response body.
#+END_QUOTE

#+BEGIN_QUOTE
TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the =Via= header field (Section 5.7.1 of [RFC7230]) is of particular interest, since it acts as a trace of the request chain. Use of the =Max-Forwards= header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
#+END_QUOTE

#+BEGIN_QUOTE
A client *MUST NOT* send a message body in a TRACE request.
#+END_QUOTE

#+BEGIN_QUOTE
Responses to the TRACE method are not cacheable.
#+END_QUOTE

* 5. 请求报头域 / Request Header Fields
:PROPERTIES:
:ID:       f8e7b063-496f-473e-95e8-88ec76f21582
:END:
** 5.1. Controls
*** 5.1.1. Expect
*** 5.1.2. Max-Forwards
:PROPERTIES:
:ID:       4c0e6435-a276-48fb-8cb8-32b8ef5a2780
:END:
** 5.2. Conditionals
:PROPERTIES:
:ID:       b21923d5-a8f9-4560-8592-92fd9a098bf4
:END:
** 5.3. Content Negotiation
*** 5.3.1. Quality Values
*** 5.3.2. Accept
:PROPERTIES:
:ID:       95575604-c3d4-48d6-a061-325bd7798970
:END:
*** 5.3.3. Accept-Charset
*** 5.3.4. Accept-Encoding
:PROPERTIES:
:ID:       a8fcc101-3782-4ed0-aec0-561b933e6a5f
:END:
*** 5.3.5. Accept-Language
** 5.4. 身份验证凭证 / Authentication Credentials
** 5.5. 请求上下文/ Request Context
*** 5.5.1. Form
*** 5.5.2. Referer
*** 5.5.3. User-Agent
* 6. 响应状态码 / Response Status Codes
:PROPERTIES:
:ID:       5a69d0cc-628c-4897-a089-45f906b94a92
:END:
** 6.1. 状态码概况 / Overview of Status Codes
** 6.2. 信息性 1xx / Informational 1xx
*** 6.2.1. 100 Continue
*** 6.2.2. 101 Switching Protocols
** 6.3. 成功 2xx / Successful 2xx
*** 6.3.1. 200 OK
*** 6.3.2. 201 Created
*** 6.3.3. 202 Accepted
*** 6.3.4. 203 Non-Authoritative Information
*** 6.3.5. 204 No Content
*** 6.3.6. 205 Reset Content
** 6.4. 重定向 3xx / Redirection 3xx
*** 6.4.1. 300 Multiple Choices
*** 6.4.2. 301 Moved Permanently
*** 6.4.3. 302 Found
*** 6.4.4. 303 See Other
*** 6.4.5. 305 Use Proxy
*** 6.4.6. 306 (Unused)
*** 6.4.7. 307 Temporary Redirect
** 6.5. 客户端错误 / Client Error 4xx
*** 6.5.1. 400 Bad Request
*** 6.5.2. 402 Payment Required
*** 6.5.3. 403 Forbidden
*** 6.5.4. 404 Not Found
*** 6.5.5. 405 Method Not Allowed
*** 6.5.6. 406 Not Acceptable
*** 6.5.7. 408 Request Timeout
*** 6.5.8. 409 Conflict
*** 6.5.9. 410 Gone
*** 6.5.10. 411 Length Required
*** 6.5.11. 413 Payload Too Large
*** 6.5.12. 414 URI Too Long
*** 6.5.13. 415 Unsupported Media Type
*** 6.5.14. 417 Expectation Failed
*** 6.5.15. 426 Upgrade Required
** 6.6 服务器错误 / Server Error 5xx
*** 6.6.1. 500 Internal Server Error
*** 6.6.2. 501 Not Implemented
*** 6.6.3. 502 Bad Gateway
*** 6.6.4. 503 Service Unavailable
*** 6.6.5. 504 Gateway Timeout
*** 6.6.6. 505 HTTP Version Not Supported
* 7. 响应报头域 / Response Header Fields
:PROPERTIES:
:ID:       30e7b781-4a14-4519-abb9-63ec43516b98
:END:
** 7.1. Control Data
*** 7.1.1. Origination Date
**** 7.1.1.1. Date/Time Formats
**** 7.1.1.2. Data
:PROPERTIES:
:ID:       5a5ac74d-bb4e-4564-bd10-3c8e580d6ff1
:END:
*** 7.1.2. Location
:PROPERTIES:
:ID:       bc2baf29-0bf6-4816-865c-3d33f5fe38e3
:END:
*** 7.1.3. Retry-After
*** 7.1.4. Vary
:PROPERTIES:
:ID:       ca7f8781-b183-4563-a90a-b9b7ad4f1032
:END:
** 7.2. Validator Header Fields
:PROPERTIES:
:ID:       efd98bfe-3f3c-4d75-9fa9-041a5af2f917
:END:
** 7.3. Authentication Challenges
** 7.4. Response Context
*** 7.4.1. Allow
:PROPERTIES:
:ID:       f8577773-512f-4d68-8f5d-444368db7c29
:END:
*** 7.4.2. Server
* 8. IANA 注意事项 / IANA Considerations
** 8.1. 方法注册表 / Method Registry
:PROPERTIES:
:ID:       193d7ad5-9c6d-4bf7-98f1-6984a42af639
:END:
*** 8.1.1. Procedure
*** 8.1.2. Considerations for New Methods
*** 8.1.3. Registrations
** 8.2. 状态码注册表 / Status Code Registry
*** 8.2.1. Procedure
*** 8.2.2. Considerations for New Status Codes
*** 8.2.3. Registrations
** 8.3. 报头域注册表 / Header Field Registry
*** 8.3.1. Considerations for New Header Fields
*** 8.3.2. Registrations
** 8.4. 内容编码值注册表 / Content Coding Registry
:PROPERTIES:
:ID:       87f2ed30-a48b-4c31-a181-8e3a33ba1080
:END:
*** 8.4.1. Procedure
*** 8.4.2. Registrations
* 9. 安全注意事项 / Security Considerations
** 9.1. 基于文件和路径名称的攻击 / Attacks Based on File and Path Names
:PROPERTIES:
:ID:       9195be98-bd4e-40ae-a5a0-6af920044f02
:END:
** 9.2. 基于命令、代码、查询注入 / Attacks Based on Command, Code, or Query Injection
** 9.3. 个人信息的披露 / Disclosure of Personal Information
** 9.4. URLs 敏感信息的披露 / Disclosure of Sensitive Information in URLs
** 9.5. Disclosure of Fragment after Redirects
** 9.6. Disclosure of Product Information
** 9.7. 浏览器指纹识别 / Browser Fingerprinting
* 10. 鸣谢 / Acknowledgements
* 11. 参考资料 / References
** 11.1. Normative References
** 11.2. Informative References
* A. HTTP 与 MIME 的区别 / Defferences between HTTP and MIME
:PROPERTIES:
:ID:       84208afd-e458-4f40-97cc-2e9535523797
:END:
** A.1. MIME-VERSION
** A.2. Conversion to Canonical Form
** A.3. Conversion of Date Formats
** A.4. Conversion of Content-Encoding
** A.5. Conversion of Content-Transfer-Encoding
** A.6. MHTML and Line Length Limitations
* B. 相对 RFC 2616 的变化 / Changes from RFC 2616
* C. 引入的 ABNF 规则 / Imported ABNF
* D. ABNF 规则集合 Collected ABNF
* Index
* Author' Addresses

* Footnotes

[fn:2] Content Object Tree
#+BEGIN_QUOTE
a *Content Object* is a single piece of managed content. Often referred to as simply "content".

The suffx of "object" is often used specifically to differentiate an object from its defining content type. For example: The "2016 Annual Report" content object is based on the "Managed Document" content type.

a *Content Tree* is the aggregation of content in a hierarchical tree.

Each content object in the tree has a parent (except, of course, for the object at the base of the tree -- the "root" object), zero or more siblings, and zero or more children. The tree can be used to represent relationships between content objects

-- O'REILLY "[[http://flyingsquirrelbook.com/glossary/term/content-object][Web Content Management, SYSTEMS, FEATURES, AND BEST PRACTICES]]" Deane Barker
#+END_QUOTE

[fn:1] Backlink，反向连接，参考 [[https://en.wikipedia.org/wiki/Backlink][Wikipedia: Backlink]]。
